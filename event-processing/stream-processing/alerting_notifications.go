package stream_processing

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"go.uber.org/zap"
)

// sendWebhookNotification sends a webhook notification
func (a *AlertingSystem) sendWebhookNotification(alert *Alert) {
	if a.webhookChannel == nil {
		return
	}
	
	// Create webhook payload
	payload := map[string]interface{}{
		"alert_id":    alert.ID,
		"type":        alert.Type,
		"severity":    alert.Severity,
		"title":       alert.Title,
		"description": alert.Description,
		"component":   alert.Component,
		"timestamp":   alert.Timestamp.Format(time.RFC3339),
		"status":      alert.Status,
		"labels":      alert.Labels,
		"annotations": alert.Annotations,
	}
	
	// Add metric values if available
	if len(alert.MetricValues) > 0 {
		payload["metrics"] = alert.MetricValues
	}
	
	// Add event data if available
	if len(alert.EventData) > 0 {
		payload["event_data"] = alert.EventData
	}
	
	jsonData, err := json.Marshal(payload)
	if err != nil {
		a.logger.Error("Failed to marshal webhook payload", zap.Error(err))
		a.recordNotification(alert, "webhook", false, err.Error())
		return
	}
	
	// Send HTTP request
	req, err := http.NewRequest("POST", a.webhookChannel.URL, bytes.NewBuffer(jsonData))
	if err != nil {
		a.logger.Error("Failed to create webhook request", zap.Error(err))
		a.recordNotification(alert, "webhook", false, err.Error())
		return
	}
	
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("User-Agent", "iSECTECH-StreamProcessor-Alerting/1.0")
	
	resp, err := a.webhookChannel.HTTPClient.Do(req)
	if err != nil {
		a.logger.Error("Failed to send webhook notification", zap.Error(err))
		a.recordNotification(alert, "webhook", false, err.Error())
		return
	}
	defer resp.Body.Close()
	
	if resp.StatusCode >= 200 && resp.StatusCode < 300 {
		a.logger.Info("Webhook notification sent successfully",
			zap.String("alert_id", alert.ID),
			zap.String("webhook_url", a.webhookChannel.URL),
		)
		a.recordNotification(alert, "webhook", true, "")
	} else {
		errorMsg := fmt.Sprintf("HTTP %d", resp.StatusCode)
		a.logger.Error("Webhook notification failed",
			zap.String("alert_id", alert.ID),
			zap.Int("status_code", resp.StatusCode),
		)
		a.recordNotification(alert, "webhook", false, errorMsg)
	}
}

// sendEmailNotification sends an email notification
func (a *AlertingSystem) sendEmailNotification(alert *Alert) {
	if a.emailChannel == nil || len(a.emailChannel.Recipients) == 0 {
		return
	}
	
	// Create email content
	subject := fmt.Sprintf("[iSECTECH] %s Alert: %s", alert.Severity, alert.Title)
	
	body := fmt.Sprintf(`
Alert Details:
--------------
Alert ID: %s
Type: %s
Severity: %s
Component: %s
Title: %s
Description: %s
Timestamp: %s
Status: %s

`,
		alert.ID,
		alert.Type,
		alert.Severity,
		alert.Component,
		alert.Title,
		alert.Description,
		alert.Timestamp.Format("2006-01-02 15:04:05 UTC"),
		alert.Status,
	)
	
	// Add labels
	if len(alert.Labels) > 0 {
		body += "Labels:\n"
		for key, value := range alert.Labels {
			body += fmt.Sprintf("  %s: %s\n", key, value)
		}
		body += "\n"
	}
	
	// Add metric values
	if len(alert.MetricValues) > 0 {
		body += "Metric Values:\n"
		for metric, value := range alert.MetricValues {
			body += fmt.Sprintf("  %s: %.2f\n", metric, value)
		}
		body += "\n"
	}
	
	// Add footer
	body += fmt.Sprintf(`
---
This alert was generated by iSECTECH Stream Processing System
Alert ID: %s
Generated at: %s
`, alert.ID, time.Now().Format("2006-01-02 15:04:05 UTC"))
	
	// For this implementation, we'll use a simple HTTP-based email service
	// In production, you would use a proper SMTP client
	emailPayload := map[string]interface{}{
		"to":      a.emailChannel.Recipients,
		"subject": subject,
		"body":    body,
		"from":    "alerts@isectech.local",
	}
	
	jsonData, err := json.Marshal(emailPayload)
	if err != nil {
		a.logger.Error("Failed to marshal email payload", zap.Error(err))
		a.recordNotification(alert, "email", false, err.Error())
		return
	}
	
	// Send to email service endpoint
	emailServiceURL := fmt.Sprintf("http://%s:%d/send", a.emailChannel.SMTPServer, a.emailChannel.SMTPPort)
	req, err := http.NewRequest("POST", emailServiceURL, bytes.NewBuffer(jsonData))
	if err != nil {
		a.logger.Error("Failed to create email request", zap.Error(err))
		a.recordNotification(alert, "email", false, err.Error())
		return
	}
	
	req.Header.Set("Content-Type", "application/json")
	if a.emailChannel.Username != "" && a.emailChannel.Password != "" {
		req.SetBasicAuth(a.emailChannel.Username, a.emailChannel.Password)
	}
	
	resp, err := a.emailChannel.HTTPClient.Do(req)
	if err != nil {
		a.logger.Error("Failed to send email notification", zap.Error(err))
		a.recordNotification(alert, "email", false, err.Error())
		return
	}
	defer resp.Body.Close()
	
	if resp.StatusCode >= 200 && resp.StatusCode < 300 {
		a.logger.Info("Email notification sent successfully",
			zap.String("alert_id", alert.ID),
			zap.Strings("recipients", a.emailChannel.Recipients),
		)
		a.recordNotification(alert, "email", true, "")
	} else {
		errorMsg := fmt.Sprintf("HTTP %d", resp.StatusCode)
		a.logger.Error("Email notification failed",
			zap.String("alert_id", alert.ID),
			zap.Int("status_code", resp.StatusCode),
		)
		a.recordNotification(alert, "email", false, errorMsg)
	}
}

// sendSlackNotification sends a Slack notification
func (a *AlertingSystem) sendSlackNotification(alert *Alert) {
	if a.slackChannel == nil {
		return
	}
	
	// Determine color based on severity
	var color string
	var emoji string
	switch alert.Severity {
	case AlertSeverityInfo:
		color = "#36a64f" // Green
		emoji = ":information_source:"
	case AlertSeverityWarning:
		color = "#ff9900" // Orange
		emoji = ":warning:"
	case AlertSeverityError:
		color = "#ff0000" // Red
		emoji = ":exclamation:"
	case AlertSeverityCritical:
		color = "#ff0000" // Red
		emoji = ":rotating_light:"
	default:
		color = "#36a64f" // Green
		emoji = ":bell:"
	}
	
	// Create Slack attachment
	attachment := map[string]interface{}{
		"color":      color,
		"title":      fmt.Sprintf("%s %s Alert: %s", emoji, alert.Severity, alert.Title),
		"text":       alert.Description,
		"timestamp":  alert.Timestamp.Unix(),
		"footer":     "iSECTECH Stream Processing",
		"footer_icon": "https://isectech.com/favicon.ico",
		"fields": []map[string]interface{}{
			{
				"title": "Alert ID",
				"value": alert.ID,
				"short": true,
			},
			{
				"title": "Component",
				"value": alert.Component,
				"short": true,
			},
			{
				"title": "Type",
				"value": string(alert.Type),
				"short": true,
			},
			{
				"title": "Status",
				"value": string(alert.Status),
				"short": true,
			},
		},
	}
	
	// Add metric fields if available
	if len(alert.MetricValues) > 0 {
		fields := attachment["fields"].([]map[string]interface{})
		for metric, value := range alert.MetricValues {
			fields = append(fields, map[string]interface{}{
				"title": metric,
				"value": fmt.Sprintf("%.2f", value),
				"short": true,
			})
		}
		attachment["fields"] = fields
	}
	
	// Create Slack payload
	payload := map[string]interface{}{
		"username":    "iSECTECH Alerts",
		"icon_emoji":  ":shield:",
		"attachments": []map[string]interface{}{attachment},
	}
	
	// Add channel if specified
	if a.slackChannel.Channel != "" {
		payload["channel"] = a.slackChannel.Channel
	}
	
	jsonData, err := json.Marshal(payload)
	if err != nil {
		a.logger.Error("Failed to marshal Slack payload", zap.Error(err))
		a.recordNotification(alert, "slack", false, err.Error())
		return
	}
	
	// Send HTTP request
	req, err := http.NewRequest("POST", a.slackChannel.WebhookURL, bytes.NewBuffer(jsonData))
	if err != nil {
		a.logger.Error("Failed to create Slack request", zap.Error(err))
		a.recordNotification(alert, "slack", false, err.Error())
		return
	}
	
	req.Header.Set("Content-Type", "application/json")
	
	resp, err := a.slackChannel.HTTPClient.Do(req)
	if err != nil {
		a.logger.Error("Failed to send Slack notification", zap.Error(err))
		a.recordNotification(alert, "slack", false, err.Error())
		return
	}
	defer resp.Body.Close()
	
	if resp.StatusCode >= 200 && resp.StatusCode < 300 {
		a.logger.Info("Slack notification sent successfully",
			zap.String("alert_id", alert.ID),
			zap.String("channel", a.slackChannel.Channel),
		)
		a.recordNotification(alert, "slack", true, "")
	} else {
		errorMsg := fmt.Sprintf("HTTP %d", resp.StatusCode)
		a.logger.Error("Slack notification failed",
			zap.String("alert_id", alert.ID),
			zap.Int("status_code", resp.StatusCode),
		)
		a.recordNotification(alert, "slack", false, errorMsg)
	}
}

// recordNotification records a notification attempt
func (a *AlertingSystem) recordNotification(alert *Alert, channel string, success bool, errorMsg string) {
	notification := NotificationRecord{
		Channel:   channel,
		Timestamp: time.Now(),
		Success:   success,
		Error:     errorMsg,
	}
	
	alert.NotificationsSent = append(alert.NotificationsSent, notification)
	
	// Record metric
	if a.metricsCollector != nil {
		status := "success"
		if !success {
			status = "failed"
		}
		a.metricsCollector.RecordEventProcessed("notification", status, channel)
	}
}

// CreatePerformanceAlert creates a performance-related alert
func (a *AlertingSystem) CreatePerformanceAlert(component string, metricName string, currentValue, threshold float64, description string) *Alert {
	severity := AlertSeverityWarning
	if currentValue > threshold*1.5 {
		severity = AlertSeverityError
	}
	if currentValue > threshold*2.0 {
		severity = AlertSeverityCritical
	}
	
	title := fmt.Sprintf("High %s detected", metricName)
	
	labels := map[string]string{
		"metric_name": metricName,
		"threshold":   fmt.Sprintf("%.2f", threshold),
	}
	
	eventData := map[string]interface{}{
		"metric_name":    metricName,
		"current_value":  currentValue,
		"threshold":      threshold,
		"deviation":      (currentValue - threshold) / threshold * 100,
	}
	
	return a.CreateAlert(AlertTypePerformance, severity, title, description, component, labels, eventData)
}

// CreateHealthAlert creates a health-related alert
func (a *AlertingSystem) CreateHealthAlert(component string, healthStatus HealthStatus, description string) *Alert {
	var severity AlertSeverity
	switch healthStatus {
	case HealthStatusDegraded:
		severity = AlertSeverityWarning
	case HealthStatusUnhealthy:
		severity = AlertSeverityError
	default:
		severity = AlertSeverityInfo
	}
	
	title := fmt.Sprintf("Component %s is %s", component, healthStatus)
	
	labels := map[string]string{
		"health_status": string(healthStatus),
	}
	
	eventData := map[string]interface{}{
		"health_status": healthStatus,
		"timestamp":     time.Now(),
	}
	
	return a.CreateAlert(AlertTypeHealth, severity, title, description, component, labels, eventData)
}

// CreateSecurityAlert creates a security-related alert
func (a *AlertingSystem) CreateSecurityAlert(component string, threatType string, severity AlertSeverity, description string, eventData map[string]interface{}) *Alert {
	title := fmt.Sprintf("Security threat detected: %s", threatType)
	
	labels := map[string]string{
		"threat_type": threatType,
		"source":      component,
	}
	
	return a.CreateAlert(AlertTypeSecurity, severity, title, description, component, labels, eventData)
}

// CreateInfrastructureAlert creates an infrastructure-related alert
func (a *AlertingSystem) CreateInfrastructureAlert(component string, issue string, severity AlertSeverity, description string) *Alert {
	title := fmt.Sprintf("Infrastructure issue: %s", issue)
	
	labels := map[string]string{
		"issue_type": issue,
	}
	
	eventData := map[string]interface{}{
		"issue_type": issue,
		"timestamp":  time.Now(),
	}
	
	return a.CreateAlert(AlertTypeInfrastructure, severity, title, description, component, labels, eventData)
}

// CreateDataAlert creates a data-related alert
func (a *AlertingSystem) CreateDataAlert(component string, dataIssue string, severity AlertSeverity, description string, eventData map[string]interface{}) *Alert {
	title := fmt.Sprintf("Data issue detected: %s", dataIssue)
	
	labels := map[string]string{
		"data_issue": dataIssue,
	}
	
	return a.CreateAlert(AlertTypeData, severity, title, description, component, labels, eventData)
}