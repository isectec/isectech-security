package remediation

import (
	"context"
	"fmt"
	"log/slog"
	"sync"
	"time"
)

// ExceptionManager handles vulnerability exception requests and approval workflows
type ExceptionManager struct {
	config              ExceptionManagerConfig
	logger              *slog.Logger
	approvalWorkflow    *ApprovalWorkflowEngine
	riskAssessment      *ExceptionRiskAssessment
	complianceValidator *ComplianceValidator
	notificationService NotificationService
	auditLogger         *AuditLogger
	documentGenerator   *DocumentGenerator
	cache               CacheService
	statistics          ExceptionStatistics
	mutex               sync.RWMutex
}

// ExceptionManagerConfig defines configuration for exception management
type ExceptionManagerConfig struct {
	// Exception settings
	AllowExceptions             bool          `json:"allow_exceptions"`
	MaxExceptionDuration        time.Duration `json:"max_exception_duration"`
	RequireJustification        bool          `json:"require_justification"`
	RequireRiskAssessment       bool          `json:"require_risk_assessment"`
	RequireCompensatingControls bool          `json:"require_compensating_controls"`

	// Approval workflow
	DefaultWorkflow          string            `json:"default_workflow"`
	WorkflowsByPriority      map[string]string `json:"workflows_by_priority"`
	WorkflowsByCompliance    map[string]string `json:"workflows_by_compliance"`
	RequireMultipleApprovers bool              `json:"require_multiple_approvers"`
	ApprovalTimeout          time.Duration     `json:"approval_timeout"`

	// Risk thresholds
	AutoApprovalRiskThreshold float64 `json:"auto_approval_risk_threshold"`
	RequireExecutiveApproval  float64 `json:"require_executive_approval"`
	MaxRiskScore              float64 `json:"max_risk_score"`

	// Review and renewal
	EnablePeriodicReview bool          `json:"enable_periodic_review"`
	ReviewFrequency      time.Duration `json:"review_frequency"`
	AutoRenewal          bool          `json:"auto_renewal"`
	MaxRenewalCount      int           `json:"max_renewal_count"`

	// Documentation requirements
	RequireDocumentation   bool              `json:"require_documentation"`
	DocumentationTemplates map[string]string `json:"documentation_templates"`
	RetentionPeriod        time.Duration     `json:"retention_period"`

	// Compliance settings
	ComplianceFrameworks []string        `json:"compliance_frameworks"`
	ComplianceOverrides  map[string]bool `json:"compliance_overrides"`
	AuditTrailRequired   bool            `json:"audit_trail_required"`

	// Notification settings
	NotifyOnSubmission   bool     `json:"notify_on_submission"`
	NotifyOnApproval     bool     `json:"notify_on_approval"`
	NotifyOnRejection    bool     `json:"notify_on_rejection"`
	NotifyOnExpiration   bool     `json:"notify_on_expiration"`
	NotificationChannels []string `json:"notification_channels"`

	// Business rules
	BusinessHoursOnly bool `json:"business_hours_only"`
	EmergencyBypass   bool `json:"emergency_bypass"`
	ExecutiveOverride bool `json:"executive_override"`

	// Performance settings
	CacheEnabled           bool          `json:"cache_enabled"`
	CacheExpiration        time.Duration `json:"cache_expiration"`
	BatchProcessingEnabled bool          `json:"batch_processing_enabled"`

	// iSECTECH specific
	TenantIsolation          bool `json:"tenant_isolation"`
	CustomerApprovalRequired bool `json:"customer_approval_required"`
	RegionalCompliance       bool `json:"regional_compliance"`
	ExecutiveVisibility      bool `json:"executive_visibility"`
}

// VulnerabilityException represents a vulnerability exception request
type VulnerabilityException struct {
	ID              string `json:"id"`
	VulnerabilityID string `json:"vulnerability_id"`
	AssetID         string `json:"asset_id"`
	RequestedBy     string `json:"requested_by"`

	// Exception details
	ExceptionType          string        `json:"exception_type"`
	Reason                 string        `json:"reason"`
	BusinessJustification  string        `json:"business_justification"`
	TechnicalJustification string        `json:"technical_justification"`
	Duration               time.Duration `json:"duration"`

	// Risk assessment
	RiskAssessment *RiskAssessment `json:"risk_assessment,omitempty"`
	RiskScore      float64         `json:"risk_score"`
	RiskLevel      string          `json:"risk_level"`
	AcceptedRisk   float64         `json:"accepted_risk"`

	// Compensating controls
	CompensatingControls  []CompensatingControl `json:"compensating_controls"`
	ControlsEffectiveness float64               `json:"controls_effectiveness"`
	ControlsValidated     bool                  `json:"controls_validated"`

	// Approval workflow
	WorkflowID        string           `json:"workflow_id"`
	ApprovalStatus    string           `json:"approval_status"`
	CurrentApprover   string           `json:"current_approver"`
	ApprovalHistory   []ApprovalRecord `json:"approval_history"`
	RequiredApprovers []string         `json:"required_approvers"`

	// Timeline
	RequestedAt    time.Time `json:"requested_at"`
	SubmittedAt    time.Time `json:"submitted_at"`
	ApprovedAt     time.Time `json:"approved_at"`
	EffectiveDate  time.Time `json:"effective_date"`
	ExpirationDate time.Time `json:"expiration_date"`
	LastReviewDate time.Time `json:"last_review_date"`
	NextReviewDate time.Time `json:"next_review_date"`

	// Status tracking
	Status       string `json:"status"`
	State        string `json:"state"`
	AutoRenewed  bool   `json:"auto_renewed"`
	RenewalCount int    `json:"renewal_count"`

	// Documentation
	SupportingDocuments   []Document `json:"supporting_documents"`
	GeneratedDocuments    []Document `json:"generated_documents"`
	DocumentationComplete bool       `json:"documentation_complete"`

	// Compliance
	ComplianceFrameworks []string             `json:"compliance_frameworks"`
	ComplianceOverrides  []ComplianceOverride `json:"compliance_overrides"`
	ComplianceApproved   bool                 `json:"compliance_approved"`
	ComplianceNotes      string               `json:"compliance_notes"`

	// Monitoring and validation
	MonitoringRequired  bool               `json:"monitoring_required"`
	MonitoringFrequency time.Duration      `json:"monitoring_frequency"`
	LastValidation      time.Time          `json:"last_validation"`
	ValidationResults   []ValidationResult `json:"validation_results"`

	// Business context
	BusinessUnit     string  `json:"business_unit"`
	CriticalityLevel string  `json:"criticality_level"`
	BusinessImpact   string  `json:"business_impact"`
	CustomerImpact   string  `json:"customer_impact"`
	RevenueImpact    float64 `json:"revenue_impact"`

	// Communication
	Comments         []ExceptionComment   `json:"comments"`
	Notifications    []NotificationRecord `json:"notifications"`
	CommunicationLog []CommunicationEntry `json:"communication_log"`

	// Audit trail
	AuditTrail          []ExceptionAuditEntry `json:"audit_trail"`
	StateHistory        []StateTransition     `json:"state_history"`
	ModificationHistory []ModificationRecord  `json:"modification_history"`

	// Integration
	TicketID           string `json:"ticket_id,omitempty"`
	ChangeRequestID    string `json:"change_request_id,omitempty"`
	WorkflowInstanceID string `json:"workflow_instance_id,omitempty"`

	// Metadata
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	Version   int       `json:"version"`

	// Custom fields
	CustomFields map[string]interface{} `json:"custom_fields"`
	Tags         []string               `json:"tags"`
	TenantID     string                 `json:"tenant_id,omitempty"`
}

// ExceptionStatistics tracks exception management performance
type ExceptionStatistics struct {
	// Request metrics
	TotalRequests     int64 `json:"total_requests"`
	PendingRequests   int64 `json:"pending_requests"`
	ApprovedRequests  int64 `json:"approved_requests"`
	RejectedRequests  int64 `json:"rejected_requests"`
	ExpiredExceptions int64 `json:"expired_exceptions"`

	// Approval metrics
	ApprovalRate        float64       `json:"approval_rate"`
	AverageApprovalTime time.Duration `json:"average_approval_time"`
	MedianApprovalTime  time.Duration `json:"median_approval_time"`
	ApprovalTimeouts    int64         `json:"approval_timeouts"`

	// Risk metrics
	AverageRiskScore     float64 `json:"average_risk_score"`
	HighRiskExceptions   int64   `json:"high_risk_exceptions"`
	AutoApprovedRequests int64   `json:"auto_approved_requests"`
	ExecutiveApprovals   int64   `json:"executive_approvals"`

	// Compliance metrics
	ComplianceViolations int64 `json:"compliance_violations"`
	ComplianceOverrides  int64 `json:"compliance_overrides"`
	AuditFindings        int64 `json:"audit_findings"`

	// Business metrics
	TotalBusinessImpact   float64 `json:"total_business_impact"`
	AverageBusinessImpact float64 `json:"average_business_impact"`
	CostSavings           float64 `json:"cost_savings"`

	// Quality metrics
	DocumentationCompliance float64 `json:"documentation_compliance"`
	ReviewCompliance        float64 `json:"review_compliance"`
	ControlsEffectiveness   float64 `json:"controls_effectiveness"`

	// Time periods
	StatisticsPeriod string    `json:"statistics_period"`
	LastUpdated      time.Time `json:"last_updated"`

	// Breakdown metrics
	RequestsByType      map[string]int64 `json:"requests_by_type"`
	RequestsByPriority  map[string]int64 `json:"requests_by_priority"`
	RequestsByFramework map[string]int64 `json:"requests_by_framework"`
	RequestsByTenant    map[string]int64 `json:"requests_by_tenant"`
}

// NewExceptionManager creates a new exception manager instance
func NewExceptionManager(config ExceptionManagerConfig, logger *slog.Logger) (*ExceptionManager, error) {
	em := &ExceptionManager{
		config:     config,
		logger:     logger,
		statistics: ExceptionStatistics{},
	}

	// Initialize components
	if err := em.initializeComponents(); err != nil {
		return nil, fmt.Errorf("failed to initialize components: %w", err)
	}

	logger.Info("Exception manager initialized successfully",
		"allow_exceptions", config.AllowExceptions,
		"require_risk_assessment", config.RequireRiskAssessment,
		"require_compensating_controls", config.RequireCompensatingControls)

	return em, nil
}

// SubmitException submits a new vulnerability exception request
func (em *ExceptionManager) SubmitException(ctx context.Context, request *ExceptionRequest) (*VulnerabilityException, error) {
	if !em.config.AllowExceptions {
		return nil, fmt.Errorf("vulnerability exceptions are not allowed")
	}

	// Validate request
	if err := em.validateExceptionRequest(request); err != nil {
		return nil, fmt.Errorf("invalid exception request: %w", err)
	}

	// Check if exception already exists
	existing, err := em.getExistingException(request.VulnerabilityID, request.AssetID)
	if err == nil && existing != nil {
		return nil, fmt.Errorf("exception already exists for vulnerability %s on asset %s", request.VulnerabilityID, request.AssetID)
	}

	// Create exception
	exception := &VulnerabilityException{
		ID:                     em.generateExceptionID(),
		VulnerabilityID:        request.VulnerabilityID,
		AssetID:                request.AssetID,
		RequestedBy:            request.RequestedBy,
		ExceptionType:          request.ExceptionType,
		Reason:                 request.Reason,
		BusinessJustification:  request.BusinessJustification,
		TechnicalJustification: request.TechnicalJustification,
		Duration:               request.Duration,
		CompensatingControls:   request.CompensatingControls,
		BusinessUnit:           request.BusinessUnit,
		CriticalityLevel:       request.CriticalityLevel,
		Status:                 "draft",
		State:                  "preparation",
		RequestedAt:            time.Now(),
		CreatedAt:              time.Now(),
		UpdatedAt:              time.Now(),
		CustomFields:           make(map[string]interface{}),
		TenantID:               request.TenantID,
	}

	// Perform risk assessment if required
	if em.config.RequireRiskAssessment {
		riskAssessment, err := em.performRiskAssessment(ctx, exception)
		if err != nil {
			return nil, fmt.Errorf("risk assessment failed: %w", err)
		}
		exception.RiskAssessment = riskAssessment
		exception.RiskScore = riskAssessment.RiskScore
		exception.RiskLevel = riskAssessment.RiskLevel
	}

	// Validate compensating controls if required
	if em.config.RequireCompensatingControls && len(exception.CompensatingControls) > 0 {
		effectiveness, err := em.validateCompensatingControls(ctx, exception)
		if err != nil {
			return nil, fmt.Errorf("compensating controls validation failed: %w", err)
		}
		exception.ControlsEffectiveness = effectiveness
		exception.ControlsValidated = true
	}

	// Determine approval workflow
	workflowID, err := em.determineApprovalWorkflow(exception)
	if err != nil {
		return nil, fmt.Errorf("failed to determine approval workflow: %w", err)
	}
	exception.WorkflowID = workflowID

	// Set expiration date
	exception.ExpirationDate = time.Now().Add(exception.Duration)
	exception.NextReviewDate = em.calculateNextReview(exception.ExpirationDate)

	// Store exception
	if err := em.storeException(exception); err != nil {
		return nil, fmt.Errorf("failed to store exception: %w", err)
	}

	// Add audit entry
	em.addAuditEntry(exception, "exception_submitted", request.RequestedBy, "Exception request submitted", request)

	// Send notifications
	if em.config.NotifyOnSubmission {
		em.sendSubmissionNotification(exception)
	}

	// Update statistics
	em.updateStatistics("exception_submitted", exception)

	em.logger.Info("Exception request submitted",
		"exception_id", exception.ID,
		"vulnerability_id", request.VulnerabilityID,
		"requested_by", request.RequestedBy)

	return exception, nil
}

// StartApprovalProcess starts the approval process for an exception
func (em *ExceptionManager) StartApprovalProcess(ctx context.Context, exceptionID string) error {
	exception, err := em.getException(exceptionID)
	if err != nil {
		return fmt.Errorf("failed to get exception: %w", err)
	}

	if exception.Status != "draft" {
		return fmt.Errorf("exception is not in draft status")
	}

	// Validate completeness
	if err := em.validateCompleteness(exception); err != nil {
		return fmt.Errorf("exception is incomplete: %w", err)
	}

	// Check for auto-approval
	if em.canAutoApprove(exception) {
		return em.autoApproveException(ctx, exception)
	}

	// Start workflow
	workflowInstance, err := em.approvalWorkflow.StartWorkflow(ctx, exception.WorkflowID, exception)
	if err != nil {
		return fmt.Errorf("failed to start approval workflow: %w", err)
	}

	exception.WorkflowInstanceID = workflowInstance.ID
	exception.Status = "pending_approval"
	exception.State = "approval"
	exception.SubmittedAt = time.Now()
	exception.UpdatedAt = time.Now()

	// Get required approvers
	approvers, err := em.getRequiredApprovers(exception)
	if err != nil {
		return fmt.Errorf("failed to get required approvers: %w", err)
	}
	exception.RequiredApprovers = approvers
	exception.CurrentApprover = approvers[0] // Start with first approver

	// Store updated exception
	if err := em.storeException(exception); err != nil {
		return fmt.Errorf("failed to store updated exception: %w", err)
	}

	// Add audit entry
	em.addAuditEntry(exception, "approval_process_started", "system", "Approval process started", nil)

	// Send approval request notifications
	em.sendApprovalRequestNotifications(exception)

	em.logger.Info("Approval process started",
		"exception_id", exceptionID,
		"workflow_id", exception.WorkflowID,
		"required_approvers", len(approvers))

	return nil
}

// ApproveException approves an exception request
func (em *ExceptionManager) ApproveException(ctx context.Context, exceptionID, approverID, comments string) error {
	exception, err := em.getException(exceptionID)
	if err != nil {
		return fmt.Errorf("failed to get exception: %w", err)
	}

	if exception.Status != "pending_approval" {
		return fmt.Errorf("exception is not pending approval")
	}

	// Verify approver authority
	if !em.canApprove(exception, approverID) {
		return fmt.Errorf("user %s is not authorized to approve this exception", approverID)
	}

	// Add approval record
	approval := ApprovalRecord{
		ApproverID:   approverID,
		ApproverName: em.getApproverName(approverID),
		Status:       "approved",
		Comments:     comments,
		Timestamp:    time.Now(),
	}
	exception.ApprovalHistory = append(exception.ApprovalHistory, approval)

	// Check if all required approvals are complete
	if em.hasAllRequiredApprovals(exception) {
		exception.Status = "approved"
		exception.State = "active"
		exception.ApprovalStatus = "approved"
		exception.ApprovedAt = time.Now()
		exception.EffectiveDate = time.Now()

		// Perform compliance validation
		if err := em.performComplianceValidation(ctx, exception); err != nil {
			em.logger.Warn("Compliance validation failed for approved exception", "error", err, "exception_id", exceptionID)
		}

		// Send approval notification
		if em.config.NotifyOnApproval {
			em.sendApprovalNotification(exception)
		}

		// Update statistics
		em.updateStatistics("exception_approved", exception)

		em.logger.Info("Exception approved",
			"exception_id", exceptionID,
			"approved_by", approverID)
	} else {
		// Move to next approver
		exception.CurrentApprover = em.getNextApprover(exception)
		em.sendApprovalRequestNotifications(exception)
	}

	exception.UpdatedAt = time.Now()

	// Store updated exception
	if err := em.storeException(exception); err != nil {
		return fmt.Errorf("failed to store approved exception: %w", err)
	}

	// Add audit entry
	em.addAuditEntry(exception, "exception_approved", approverID, "Exception approved by "+approverID, map[string]interface{}{
		"comments": comments,
	})

	return nil
}

// RejectException rejects an exception request
func (em *ExceptionManager) RejectException(ctx context.Context, exceptionID, approverID, reason string) error {
	exception, err := em.getException(exceptionID)
	if err != nil {
		return fmt.Errorf("failed to get exception: %w", err)
	}

	if exception.Status != "pending_approval" {
		return fmt.Errorf("exception is not pending approval")
	}

	// Verify approver authority
	if !em.canApprove(exception, approverID) {
		return fmt.Errorf("user %s is not authorized to reject this exception", approverID)
	}

	// Add rejection record
	rejection := ApprovalRecord{
		ApproverID:   approverID,
		ApproverName: em.getApproverName(approverID),
		Status:       "rejected",
		Comments:     reason,
		Timestamp:    time.Now(),
	}
	exception.ApprovalHistory = append(exception.ApprovalHistory, rejection)

	exception.Status = "rejected"
	exception.State = "closed"
	exception.ApprovalStatus = "rejected"
	exception.UpdatedAt = time.Now()

	// Store updated exception
	if err := em.storeException(exception); err != nil {
		return fmt.Errorf("failed to store rejected exception: %w", err)
	}

	// Add audit entry
	em.addAuditEntry(exception, "exception_rejected", approverID, "Exception rejected by "+approverID, map[string]interface{}{
		"reason": reason,
	})

	// Send rejection notification
	if em.config.NotifyOnRejection {
		em.sendRejectionNotification(exception, reason)
	}

	// Update statistics
	em.updateStatistics("exception_rejected", exception)

	em.logger.Info("Exception rejected",
		"exception_id", exceptionID,
		"rejected_by", approverID,
		"reason", reason)

	return nil
}

// RenewException renews an existing exception
func (em *ExceptionManager) RenewException(ctx context.Context, exceptionID string, renewalRequest *RenewalRequest) (*VulnerabilityException, error) {
	exception, err := em.getException(exceptionID)
	if err != nil {
		return nil, fmt.Errorf("failed to get exception: %w", err)
	}

	if exception.Status != "approved" {
		return nil, fmt.Errorf("only approved exceptions can be renewed")
	}

	// Check renewal eligibility
	if exception.RenewalCount >= em.config.MaxRenewalCount {
		return nil, fmt.Errorf("maximum renewal count (%d) reached", em.config.MaxRenewalCount)
	}

	// Validate renewal request
	if err := em.validateRenewalRequest(renewalRequest); err != nil {
		return nil, fmt.Errorf("invalid renewal request: %w", err)
	}

	// Update exception
	exception.Duration = renewalRequest.NewDuration
	exception.ExpirationDate = time.Now().Add(renewalRequest.NewDuration)
	exception.NextReviewDate = em.calculateNextReview(exception.ExpirationDate)
	exception.RenewalCount++
	exception.UpdatedAt = time.Now()

	// If auto-renewal is not enabled, require approval
	if !em.config.AutoRenewal {
		exception.Status = "pending_renewal_approval"
		exception.State = "renewal_approval"
	} else {
		exception.AutoRenewed = true
	}

	// Store updated exception
	if err := em.storeException(exception); err != nil {
		return nil, fmt.Errorf("failed to store renewed exception: %w", err)
	}

	// Add audit entry
	em.addAuditEntry(exception, "exception_renewed", renewalRequest.RequestedBy, "Exception renewal requested", renewalRequest)

	// Update statistics
	em.updateStatistics("exception_renewed", exception)

	em.logger.Info("Exception renewal requested",
		"exception_id", exceptionID,
		"new_duration", renewalRequest.NewDuration,
		"renewal_count", exception.RenewalCount)

	return exception, nil
}

// ExpireException expires an exception that has reached its end date
func (em *ExceptionManager) ExpireException(ctx context.Context, exceptionID string) error {
	exception, err := em.getException(exceptionID)
	if err != nil {
		return fmt.Errorf("failed to get exception: %w", err)
	}

	if exception.Status != "approved" {
		return fmt.Errorf("only approved exceptions can expire")
	}

	exception.Status = "expired"
	exception.State = "closed"
	exception.UpdatedAt = time.Now()

	// Store updated exception
	if err := em.storeException(exception); err != nil {
		return fmt.Errorf("failed to store expired exception: %w", err)
	}

	// Add audit entry
	em.addAuditEntry(exception, "exception_expired", "system", "Exception expired", nil)

	// Send expiration notification
	if em.config.NotifyOnExpiration {
		em.sendExpirationNotification(exception)
	}

	// Update statistics
	em.updateStatistics("exception_expired", exception)

	em.logger.Info("Exception expired",
		"exception_id", exceptionID,
		"expiration_date", exception.ExpirationDate)

	return nil
}

// GetException retrieves an exception by ID
func (em *ExceptionManager) GetException(ctx context.Context, exceptionID string) (*VulnerabilityException, error) {
	// Try cache first
	if em.config.CacheEnabled {
		if cached := em.getCachedException(exceptionID); cached != nil {
			return cached, nil
		}
	}

	exception, err := em.getException(exceptionID)
	if err != nil {
		return nil, fmt.Errorf("failed to get exception: %w", err)
	}

	// Cache result
	if em.config.CacheEnabled {
		em.cacheException(exception)
	}

	return exception, nil
}

// GetExceptionStatistics returns current exception management statistics
func (em *ExceptionManager) GetExceptionStatistics() ExceptionStatistics {
	em.mutex.RLock()
	defer em.mutex.RUnlock()
	return em.statistics
}

// GetExceptionsByStatus returns exceptions filtered by status
func (em *ExceptionManager) GetExceptionsByStatus(ctx context.Context, status string, tenantID string) ([]*VulnerabilityException, error) {
	criteria := &ExceptionSearchCriteria{
		Status:   []string{status},
		TenantID: tenantID,
	}

	return em.searchExceptions(criteria)
}

// GetExpiredExceptions returns all expired exceptions
func (em *ExceptionManager) GetExpiredExceptions(ctx context.Context, tenantID string) ([]*VulnerabilityException, error) {
	criteria := &ExceptionSearchCriteria{
		Status:      []string{"approved"},
		ExpiredOnly: true,
		TenantID:    tenantID,
	}

	return em.searchExceptions(criteria)
}

// GetExceptionsForReview returns exceptions that need review
func (em *ExceptionManager) GetExceptionsForReview(ctx context.Context, tenantID string) ([]*VulnerabilityException, error) {
	criteria := &ExceptionSearchCriteria{
		Status:         []string{"approved"},
		ReviewRequired: true,
		TenantID:       tenantID,
	}

	return em.searchExceptions(criteria)
}

// Implementation helper methods
func (em *ExceptionManager) initializeComponents() error {
	em.approvalWorkflow = NewApprovalWorkflowEngine(em.config)
	em.riskAssessment = NewExceptionRiskAssessment(em.config)
	em.complianceValidator = NewComplianceValidator(em.config.ComplianceFrameworks)
	em.auditLogger = NewAuditLogger(em.config)
	em.documentGenerator = NewDocumentGenerator(em.config.DocumentationTemplates)
	return nil
}

func (em *ExceptionManager) validateExceptionRequest(request *ExceptionRequest) error {
	if request.VulnerabilityID == "" {
		return fmt.Errorf("vulnerability ID is required")
	}
	if request.AssetID == "" {
		return fmt.Errorf("asset ID is required")
	}
	if request.RequestedBy == "" {
		return fmt.Errorf("requestor is required")
	}
	if request.Reason == "" {
		return fmt.Errorf("reason is required")
	}
	if em.config.RequireJustification && request.BusinessJustification == "" {
		return fmt.Errorf("business justification is required")
	}
	if request.Duration > em.config.MaxExceptionDuration {
		return fmt.Errorf("requested duration exceeds maximum allowed duration")
	}
	return nil
}

func (em *ExceptionManager) performRiskAssessment(ctx context.Context, exception *VulnerabilityException) (*RiskAssessment, error) {
	return em.riskAssessment.AssessRisk(ctx, exception)
}

func (em *ExceptionManager) validateCompensatingControls(ctx context.Context, exception *VulnerabilityException) (float64, error) {
	// Compensating controls validation logic
	return 0.8, nil // Placeholder
}

func (em *ExceptionManager) determineApprovalWorkflow(exception *VulnerabilityException) (string, error) {
	// Workflow determination logic based on risk, compliance, etc.
	if workflow, exists := em.config.WorkflowsByPriority[exception.CriticalityLevel]; exists {
		return workflow, nil
	}
	return em.config.DefaultWorkflow, nil
}

func (em *ExceptionManager) canAutoApprove(exception *VulnerabilityException) bool {
	return exception.RiskScore <= em.config.AutoApprovalRiskThreshold &&
		exception.ControlsEffectiveness >= 0.8 &&
		!em.hasComplianceConstraints(exception)
}

func (em *ExceptionManager) hasComplianceConstraints(exception *VulnerabilityException) bool {
	// Check if compliance frameworks have constraints
	return len(exception.ComplianceFrameworks) > 0
}

func (em *ExceptionManager) autoApproveException(ctx context.Context, exception *VulnerabilityException) error {
	exception.Status = "approved"
	exception.State = "active"
	exception.ApprovalStatus = "auto_approved"
	exception.ApprovedAt = time.Now()
	exception.EffectiveDate = time.Now()
	exception.SubmittedAt = time.Now()
	exception.UpdatedAt = time.Now()

	// Add auto-approval record
	approval := ApprovalRecord{
		ApproverID:   "system",
		ApproverName: "Auto-Approval System",
		Status:       "approved",
		Comments:     "Automatically approved based on low risk score and effective compensating controls",
		Timestamp:    time.Now(),
	}
	exception.ApprovalHistory = append(exception.ApprovalHistory, approval)

	// Store updated exception
	if err := em.storeException(exception); err != nil {
		return fmt.Errorf("failed to store auto-approved exception: %w", err)
	}

	// Add audit entry
	em.addAuditEntry(exception, "exception_auto_approved", "system", "Exception automatically approved", nil)

	// Send approval notification
	if em.config.NotifyOnApproval {
		em.sendApprovalNotification(exception)
	}

	// Update statistics
	em.updateStatistics("exception_auto_approved", exception)

	return nil
}

func (em *ExceptionManager) calculateNextReview(expirationDate time.Time) time.Time {
	if !em.config.EnablePeriodicReview {
		return time.Time{}
	}
	return time.Now().Add(em.config.ReviewFrequency)
}

func (em *ExceptionManager) validateCompleteness(exception *VulnerabilityException) error {
	if em.config.RequireDocumentation && !exception.DocumentationComplete {
		return fmt.Errorf("documentation is required")
	}
	if em.config.RequireRiskAssessment && exception.RiskAssessment == nil {
		return fmt.Errorf("risk assessment is required")
	}
	if em.config.RequireCompensatingControls && len(exception.CompensatingControls) == 0 {
		return fmt.Errorf("compensating controls are required")
	}
	return nil
}

func (em *ExceptionManager) getRequiredApprovers(exception *VulnerabilityException) ([]string, error) {
	// Get approvers based on workflow and risk level
	approvers := []string{"security_team"}

	if exception.RiskScore >= em.config.RequireExecutiveApproval {
		approvers = append(approvers, "executive_team")
	}

	if em.hasComplianceConstraints(exception) {
		approvers = append(approvers, "compliance_team")
	}

	return approvers, nil
}

func (em *ExceptionManager) canApprove(exception *VulnerabilityException, approverID string) bool {
	// Check if approver is in required approvers list
	for _, required := range exception.RequiredApprovers {
		if required == approverID {
			return true
		}
	}
	return false
}

func (em *ExceptionManager) hasAllRequiredApprovals(exception *VulnerabilityException) bool {
	approvedBy := make(map[string]bool)
	for _, approval := range exception.ApprovalHistory {
		if approval.Status == "approved" {
			approvedBy[approval.ApproverID] = true
		}
	}

	for _, required := range exception.RequiredApprovers {
		if !approvedBy[required] {
			return false
		}
	}

	return true
}

func (em *ExceptionManager) getNextApprover(exception *VulnerabilityException) string {
	approvedBy := make(map[string]bool)
	for _, approval := range exception.ApprovalHistory {
		if approval.Status == "approved" {
			approvedBy[approval.ApproverID] = true
		}
	}

	for _, required := range exception.RequiredApprovers {
		if !approvedBy[required] {
			return required
		}
	}

	return ""
}

func (em *ExceptionManager) performComplianceValidation(ctx context.Context, exception *VulnerabilityException) error {
	return em.complianceValidator.ValidateException(ctx, exception)
}

func (em *ExceptionManager) validateRenewalRequest(request *RenewalRequest) error {
	if request.NewDuration > em.config.MaxExceptionDuration {
		return fmt.Errorf("renewal duration exceeds maximum allowed duration")
	}
	if request.RequestedBy == "" {
		return fmt.Errorf("requestor is required for renewal")
	}
	return nil
}

func (em *ExceptionManager) addAuditEntry(exception *VulnerabilityException, action, user, description string, details interface{}) {
	entry := ExceptionAuditEntry{
		ID:          em.generateAuditID(),
		Action:      action,
		User:        user,
		Timestamp:   time.Now(),
		Description: description,
		Details:     details,
	}
	exception.AuditTrail = append(exception.AuditTrail, entry)
}

func (em *ExceptionManager) updateStatistics(event string, exception *VulnerabilityException) {
	em.mutex.Lock()
	defer em.mutex.Unlock()

	switch event {
	case "exception_submitted":
		em.statistics.TotalRequests++
		em.statistics.PendingRequests++
	case "exception_approved":
		em.statistics.ApprovedRequests++
		em.statistics.PendingRequests--
		em.statistics.ApprovalRate = float64(em.statistics.ApprovedRequests) / float64(em.statistics.TotalRequests)
	case "exception_auto_approved":
		em.statistics.ApprovedRequests++
		em.statistics.AutoApprovedRequests++
		em.statistics.PendingRequests--
		em.statistics.ApprovalRate = float64(em.statistics.ApprovedRequests) / float64(em.statistics.TotalRequests)
	case "exception_rejected":
		em.statistics.RejectedRequests++
		em.statistics.PendingRequests--
		em.statistics.ApprovalRate = float64(em.statistics.ApprovedRequests) / float64(em.statistics.TotalRequests)
	case "exception_expired":
		em.statistics.ExpiredExceptions++
	}

	em.statistics.LastUpdated = time.Now()
}

// Notification methods
func (em *ExceptionManager) sendSubmissionNotification(exception *VulnerabilityException) {
	// Send submission notification
}

func (em *ExceptionManager) sendApprovalRequestNotifications(exception *VulnerabilityException) {
	// Send approval request notifications
}

func (em *ExceptionManager) sendApprovalNotification(exception *VulnerabilityException) {
	// Send approval notification
}

func (em *ExceptionManager) sendRejectionNotification(exception *VulnerabilityException, reason string) {
	// Send rejection notification
}

func (em *ExceptionManager) sendExpirationNotification(exception *VulnerabilityException) {
	// Send expiration notification
}

// Utility methods
func (em *ExceptionManager) getApproverName(approverID string) string {
	// Get approver name from ID
	return approverID // Placeholder
}

func (em *ExceptionManager) generateExceptionID() string {
	return fmt.Sprintf("exc_%d", time.Now().UnixNano())
}

func (em *ExceptionManager) generateAuditID() string {
	return fmt.Sprintf("audit_%d", time.Now().UnixNano())
}

// Placeholder storage methods
func (em *ExceptionManager) storeException(exception *VulnerabilityException) error { return nil }
func (em *ExceptionManager) getException(exceptionID string) (*VulnerabilityException, error) {
	return nil, nil
}
func (em *ExceptionManager) getExistingException(vulnID, assetID string) (*VulnerabilityException, error) {
	return nil, fmt.Errorf("not found")
}
func (em *ExceptionManager) searchExceptions(criteria *ExceptionSearchCriteria) ([]*VulnerabilityException, error) {
	return nil, nil
}
func (em *ExceptionManager) getCachedException(exceptionID string) *VulnerabilityException {
	return nil
}
func (em *ExceptionManager) cacheException(exception *VulnerabilityException) {}

// Supporting types and structures

type ExceptionRequest struct {
	VulnerabilityID        string                `json:"vulnerability_id"`
	AssetID                string                `json:"asset_id"`
	RequestedBy            string                `json:"requested_by"`
	ExceptionType          string                `json:"exception_type"`
	Reason                 string                `json:"reason"`
	BusinessJustification  string                `json:"business_justification"`
	TechnicalJustification string                `json:"technical_justification"`
	Duration               time.Duration         `json:"duration"`
	CompensatingControls   []CompensatingControl `json:"compensating_controls"`
	BusinessUnit           string                `json:"business_unit"`
	CriticalityLevel       string                `json:"criticality_level"`
	TenantID               string                `json:"tenant_id,omitempty"`
}

type RenewalRequest struct {
	RequestedBy      string        `json:"requested_by"`
	NewDuration      time.Duration `json:"new_duration"`
	RenewalReason    string        `json:"renewal_reason"`
	BusinessImpact   string        `json:"business_impact"`
	RiskReassessment bool          `json:"risk_reassessment"`
}

type RiskAssessment struct {
	RiskScore   float64      `json:"risk_score"`
	RiskLevel   string       `json:"risk_level"`
	RiskFactors []RiskFactor `json:"risk_factors"`
	Mitigations []Mitigation `json:"mitigations"`
	Assessment  string       `json:"assessment"`
	AssessedBy  string       `json:"assessed_by"`
	AssessedAt  time.Time    `json:"assessed_at"`
	Methodology string       `json:"methodology"`
	Confidence  float64      `json:"confidence"`
}

type RiskFactor struct {
	Factor      string  `json:"factor"`
	Impact      float64 `json:"impact"`
	Likelihood  float64 `json:"likelihood"`
	Score       float64 `json:"score"`
	Description string  `json:"description"`
}

type Mitigation struct {
	Control        string  `json:"control"`
	Effectiveness  float64 `json:"effectiveness"`
	Implementation string  `json:"implementation"`
	Status         string  `json:"status"`
}

type ComplianceOverride struct {
	Framework     string    `json:"framework"`
	Control       string    `json:"control"`
	Override      bool      `json:"override"`
	Justification string    `json:"justification"`
	ApprovedBy    string    `json:"approved_by"`
	ApprovedAt    time.Time `json:"approved_at"`
}

type ExceptionComment struct {
	ID         string    `json:"id"`
	Author     string    `json:"author"`
	Content    string    `json:"content"`
	Type       string    `json:"type"`
	Timestamp  time.Time `json:"timestamp"`
	Visibility string    `json:"visibility"`
}

type NotificationRecord struct {
	ID         string                 `json:"id"`
	Type       string                 `json:"type"`
	Timestamp  time.Time              `json:"timestamp"`
	Recipients []string               `json:"recipients"`
	Subject    string                 `json:"subject"`
	Content    string                 `json:"content"`
	Success    bool                   `json:"success"`
	Error      string                 `json:"error,omitempty"`
	Metadata   map[string]interface{} `json:"metadata"`
}

type CommunicationEntry struct {
	ID        string    `json:"id"`
	Type      string    `json:"type"`
	Direction string    `json:"direction"`
	From      string    `json:"from"`
	To        []string  `json:"to"`
	Subject   string    `json:"subject"`
	Content   string    `json:"content"`
	Timestamp time.Time `json:"timestamp"`
	Channel   string    `json:"channel"`
}

type ExceptionAuditEntry struct {
	ID          string      `json:"id"`
	Action      string      `json:"action"`
	User        string      `json:"user"`
	Timestamp   time.Time   `json:"timestamp"`
	Description string      `json:"description"`
	Details     interface{} `json:"details"`
	IPAddress   string      `json:"ip_address,omitempty"`
	UserAgent   string      `json:"user_agent,omitempty"`
}

type StateTransition struct {
	ID        string    `json:"id"`
	OldState  string    `json:"old_state"`
	NewState  string    `json:"new_state"`
	Reason    string    `json:"reason"`
	Timestamp time.Time `json:"timestamp"`
	User      string    `json:"user"`
}

type ModificationRecord struct {
	ID        string                 `json:"id"`
	Field     string                 `json:"field"`
	OldValue  interface{}            `json:"old_value"`
	NewValue  interface{}            `json:"new_value"`
	Reason    string                 `json:"reason"`
	Timestamp time.Time              `json:"timestamp"`
	User      string                 `json:"user"`
	Context   map[string]interface{} `json:"context"`
}

type ExceptionSearchCriteria struct {
	Status           []string  `json:"status,omitempty"`
	ExceptionType    string    `json:"exception_type,omitempty"`
	RequestedBy      string    `json:"requested_by,omitempty"`
	BusinessUnit     string    `json:"business_unit,omitempty"`
	CriticalityLevel string    `json:"criticality_level,omitempty"`
	CreatedAfter     time.Time `json:"created_after,omitempty"`
	CreatedBefore    time.Time `json:"created_before,omitempty"`
	ExpiresAfter     time.Time `json:"expires_after,omitempty"`
	ExpiresBefore    time.Time `json:"expires_before,omitempty"`
	ExpiredOnly      bool      `json:"expired_only,omitempty"`
	ReviewRequired   bool      `json:"review_required,omitempty"`
	TenantID         string    `json:"tenant_id,omitempty"`
	Limit            int       `json:"limit,omitempty"`
	Offset           int       `json:"offset,omitempty"`
}

// Placeholder component types
type ApprovalWorkflowEngine struct{}
type ExceptionRiskAssessment struct{}
type ComplianceValidator struct{}
type AuditLogger struct{}
type DocumentGenerator struct{}

type WorkflowInstance struct {
	ID string `json:"id"`
}

func NewApprovalWorkflowEngine(config ExceptionManagerConfig) *ApprovalWorkflowEngine {
	return &ApprovalWorkflowEngine{}
}

func NewExceptionRiskAssessment(config ExceptionManagerConfig) *ExceptionRiskAssessment {
	return &ExceptionRiskAssessment{}
}

func NewComplianceValidator(frameworks []string) *ComplianceValidator {
	return &ComplianceValidator{}
}

func NewAuditLogger(config ExceptionManagerConfig) *AuditLogger {
	return &AuditLogger{}
}

func NewDocumentGenerator(templates map[string]string) *DocumentGenerator {
	return &DocumentGenerator{}
}

func (awe *ApprovalWorkflowEngine) StartWorkflow(ctx context.Context, workflowID string, exception *VulnerabilityException) (*WorkflowInstance, error) {
	return &WorkflowInstance{ID: "workflow_" + fmt.Sprintf("%d", time.Now().UnixNano())}, nil
}

func (era *ExceptionRiskAssessment) AssessRisk(ctx context.Context, exception *VulnerabilityException) (*RiskAssessment, error) {
	return &RiskAssessment{
		RiskScore:   5.5,
		RiskLevel:   "medium",
		Assessment:  "Moderate risk with effective compensating controls",
		AssessedBy:  "system",
		AssessedAt:  time.Now(),
		Methodology: "iSECTECH Risk Assessment Framework",
		Confidence:  0.85,
	}, nil
}

func (cv *ComplianceValidator) ValidateException(ctx context.Context, exception *VulnerabilityException) error {
	return nil
}
