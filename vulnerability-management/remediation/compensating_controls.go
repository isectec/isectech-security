package remediation

import (
	"context"
	"fmt"
	"log/slog"
	"sync"
	"time"
)

// CompensatingControlsManager manages compensating controls for vulnerability remediation
type CompensatingControlsManager struct {
	config              CompensatingControlsConfig
	logger              *slog.Logger
	controlLibrary      *ControlLibrary
	deploymentEngine    *ControlDeploymentEngine
	validationEngine    *ControlValidationEngine
	monitoringEngine    *ControlMonitoringEngine
	effectivenessEngine *EffectivenessEngine
	notificationService NotificationService
	cache               CacheService
	statistics          CompensatingControlsStatistics
	mutex               sync.RWMutex
}

// CompensatingControlsConfig defines configuration for compensating controls management
type CompensatingControlsConfig struct {
	// Control library settings
	EnabledControlTypes   []string `json:"enabled_control_types"`
	ControlLibrarySource  string   `json:"control_library_source"`
	CustomControlsEnabled bool     `json:"custom_controls_enabled"`
	ControlVersioning     bool     `json:"control_versioning"`

	// Deployment settings
	AutoDeployment     bool          `json:"auto_deployment"`
	DeploymentMethods  []string      `json:"deployment_methods"`
	DeploymentTimeout  time.Duration `json:"deployment_timeout"`
	RollbackCapability bool          `json:"rollback_capability"`

	// Validation settings
	RequireValidation    bool          `json:"require_validation"`
	ValidationMethods    []string      `json:"validation_methods"`
	ValidationTimeout    time.Duration `json:"validation_timeout"`
	MinimumEffectiveness float64       `json:"minimum_effectiveness"`

	// Monitoring settings
	ContinuousMonitoring  bool               `json:"continuous_monitoring"`
	MonitoringFrequency   time.Duration      `json:"monitoring_frequency"`
	AlertThresholds       map[string]float64 `json:"alert_thresholds"`
	PerformanceMonitoring bool               `json:"performance_monitoring"`

	// Effectiveness assessment
	EffectivenessModels      []string `json:"effectiveness_models"`
	RiskReductionCalculation string   `json:"risk_reduction_calculation"`
	ContextualFactors        []string `json:"contextual_factors"`

	// Lifecycle management
	TemporaryControlsOnly bool          `json:"temporary_controls_only"`
	MaxControlDuration    time.Duration `json:"max_control_duration"`
	AutoExpiration        bool          `json:"auto_expiration"`
	RenewalProcess        bool          `json:"renewal_process"`

	// Compliance settings
	ComplianceMapping     bool     `json:"compliance_mapping"`
	ComplianceFrameworks  []string `json:"compliance_frameworks"`
	AuditRequirements     bool     `json:"audit_requirements"`
	DocumentationRequired bool     `json:"documentation_required"`

	// Integration settings
	IntegrateWithFirewall bool `json:"integrate_with_firewall"`
	IntegrateWithSIEM     bool `json:"integrate_with_siem"`
	IntegrateWithEDR      bool `json:"integrate_with_edr"`
	IntegrateWithWAF      bool `json:"integrate_with_waf"`
	IntegrateWithDLP      bool `json:"integrate_with_dlp"`

	// Quality settings
	QualityGates        []QualityGate `json:"quality_gates"`
	TestingRequired     bool          `json:"testing_required"`
	TestingEnvironments []string      `json:"testing_environments"`

	// Performance settings
	CacheEnabled    bool          `json:"cache_enabled"`
	CacheExpiration time.Duration `json:"cache_expiration"`
	BatchProcessing bool          `json:"batch_processing"`
	MaxBatchSize    int           `json:"max_batch_size"`

	// iSECTECH specific
	TenantIsolation      bool                `json:"tenant_isolation"`
	CustomControlTypes   []CustomControlType `json:"custom_control_types"`
	BusinessContextAware bool                `json:"business_context_aware"`
	CostOptimization     bool                `json:"cost_optimization"`
	ZeroTrustIntegration bool                `json:"zero_trust_integration"`
}

// CompensatingControlDefinition represents a compensating control definition
type CompensatingControlDefinition struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	Description string `json:"description"`
	Type        string `json:"type"`
	Category    string `json:"category"`

	// Control characteristics
	Purpose        string   `json:"purpose"`
	Mechanism      string   `json:"mechanism"`
	Implementation string   `json:"implementation"`
	Technology     []string `json:"technology"`

	// Effectiveness
	BaseEffectiveness    float64               `json:"base_effectiveness"`
	EffectivenessFactors []EffectivenessFactor `json:"effectiveness_factors"`
	RiskReduction        float64               `json:"risk_reduction"`
	CoverageScope        []string              `json:"coverage_scope"`

	// Applicability
	VulnerabilityTypes []string `json:"vulnerability_types"`
	AssetTypes         []string `json:"asset_types"`
	AttackVectors      []string `json:"attack_vectors"`
	CVSSVectorSupport  []string `json:"cvss_vector_support"`

	// Deployment requirements
	DeploymentMethod     string        `json:"deployment_method"`
	DeploymentComplexity string        `json:"deployment_complexity"`
	DeploymentTime       time.Duration `json:"deployment_time"`
	Prerequisites        []string      `json:"prerequisites"`
	Dependencies         []string      `json:"dependencies"`

	// Configuration
	ConfigurationTemplate   map[string]interface{} `json:"configuration_template"`
	ConfigurationValidation []ValidationRule       `json:"configuration_validation"`
	DefaultConfiguration    map[string]interface{} `json:"default_configuration"`

	// Monitoring and validation
	MonitoringCapabilities []string         `json:"monitoring_capabilities"`
	ValidationTests        []ValidationTest `json:"validation_tests"`
	HealthChecks           []HealthCheck    `json:"health_checks"`
	PerformanceMetrics     []string         `json:"performance_metrics"`

	// Business impact
	ImplementationCost       float64 `json:"implementation_cost"`
	OperationalCost          float64 `json:"operational_cost"`
	PerformanceImpact        string  `json:"performance_impact"`
	UserExperienceImpact     string  `json:"user_experience_impact"`
	BusinessContinuityImpact string  `json:"business_continuity_impact"`

	// Compliance and governance
	ComplianceMapping  []ComplianceMapping `json:"compliance_mapping"`
	RegulatoryApproval []string            `json:"regulatory_approval"`
	AuditEvidence      []string            `json:"audit_evidence"`

	// Lifecycle
	MaxDuration        time.Duration `json:"max_duration"`
	RenewalRequired    bool          `json:"renewal_required"`
	ReviewFrequency    time.Duration `json:"review_frequency"`
	ExpirationHandling string        `json:"expiration_handling"`

	// Quality and maturity
	MaturityLevel    string         `json:"maturity_level"`
	QualityAssurance []QualityCheck `json:"quality_assurance"`
	TestingResults   []TestResult   `json:"testing_results"`
	KnownLimitations []string       `json:"known_limitations"`

	// Integration capabilities
	IntegrationPoints []IntegrationPoint `json:"integration_points"`
	APIEndpoints      []APIEndpoint      `json:"api_endpoints"`
	EventSources      []string           `json:"event_sources"`

	// Metadata
	Version      string    `json:"version"`
	CreatedAt    time.Time `json:"created_at"`
	UpdatedAt    time.Time `json:"updated_at"`
	CreatedBy    string    `json:"created_by"`
	UpdatedBy    string    `json:"updated_by"`
	Approved     bool      `json:"approved"`
	ApprovedBy   string    `json:"approved_by"`
	ApprovalDate time.Time `json:"approval_date"`

	// Custom fields
	CustomFields map[string]interface{} `json:"custom_fields"`
	Tags         []string               `json:"tags"`
	TenantID     string                 `json:"tenant_id,omitempty"`
}

// DeployedControl represents an active compensating control deployment
type DeployedControl struct {
	ID               string `json:"id"`
	DefinitionID     string `json:"definition_id"`
	VulnerabilityID  string `json:"vulnerability_id"`
	AssetID          string `json:"asset_id"`
	RemediationJobID string `json:"remediation_job_id"`

	// Deployment information
	DeployedBy       string                 `json:"deployed_by"`
	DeploymentMethod string                 `json:"deployment_method"`
	DeploymentTime   time.Time              `json:"deployment_time"`
	Configuration    map[string]interface{} `json:"configuration"`

	// Status and health
	Status            string    `json:"status"`
	Health            string    `json:"health"`
	OperationalStatus string    `json:"operational_status"`
	LastHealthCheck   time.Time `json:"last_health_check"`

	// Effectiveness tracking
	CurrentEffectiveness  float64                `json:"current_effectiveness"`
	BaselineEffectiveness float64                `json:"baseline_effectiveness"`
	EffectivenessHistory  []EffectivenessReading `json:"effectiveness_history"`
	RiskReductionAchieved float64                `json:"risk_reduction_achieved"`

	// Validation results
	ValidationStatus  string                    `json:"validation_status"`
	ValidationResults []ControlValidationResult `json:"validation_results"`
	LastValidation    time.Time                 `json:"last_validation"`
	NextValidation    time.Time                 `json:"next_validation"`

	// Monitoring data
	MonitoringEnabled  bool                  `json:"monitoring_enabled"`
	MonitoringData     []MonitoringDataPoint `json:"monitoring_data"`
	Alerts             []ControlAlert        `json:"alerts"`
	PerformanceMetrics map[string]float64    `json:"performance_metrics"`

	// Lifecycle management
	EffectiveDate  time.Time `json:"effective_date"`
	ExpirationDate time.Time `json:"expiration_date"`
	RenewalDate    time.Time `json:"renewal_date"`
	AutoRenew      bool      `json:"auto_renew"`

	// Business context
	BusinessJustification string  `json:"business_justification"`
	BusinessOwner         string  `json:"business_owner"`
	TechnicalOwner        string  `json:"technical_owner"`
	CostImpact            float64 `json:"cost_impact"`

	// Compliance tracking
	ComplianceStatus   map[string]string    `json:"compliance_status"`
	ComplianceEvidence []ComplianceEvidence `json:"compliance_evidence"`
	AuditTrail         []ControlAuditEntry  `json:"audit_trail"`

	// Integration status
	IntegrationStatus map[string]string  `json:"integration_status"`
	IntegrationHealth map[string]string  `json:"integration_health"`
	IntegrationErrors []IntegrationError `json:"integration_errors"`

	// Quality metrics
	QualityScore      float64 `json:"quality_score"`
	ReliabilityScore  float64 `json:"reliability_score"`
	AvailabilityScore float64 `json:"availability_score"`

	// Error tracking
	ErrorCount   int            `json:"error_count"`
	LastError    string         `json:"last_error"`
	ErrorHistory []ControlError `json:"error_history"`

	// Metadata
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	Version   int       `json:"version"`

	// Custom fields
	CustomFields map[string]interface{} `json:"custom_fields"`
	Tags         []string               `json:"tags"`
	TenantID     string                 `json:"tenant_id,omitempty"`
}

// CompensatingControlsStatistics tracks compensating controls performance
type CompensatingControlsStatistics struct {
	// Control metrics
	TotalControls    int64 `json:"total_controls"`
	ActiveControls   int64 `json:"active_controls"`
	InactiveControls int64 `json:"inactive_controls"`
	FailedControls   int64 `json:"failed_controls"`

	// Deployment metrics
	TotalDeployments      int64         `json:"total_deployments"`
	SuccessfulDeployments int64         `json:"successful_deployments"`
	FailedDeployments     int64         `json:"failed_deployments"`
	AverageDeploymentTime time.Duration `json:"average_deployment_time"`

	// Effectiveness metrics
	AverageEffectiveness      float64          `json:"average_effectiveness"`
	EffectivenessDistribution map[string]int64 `json:"effectiveness_distribution"`
	AverageRiskReduction      float64          `json:"average_risk_reduction"`
	TotalRiskReduction        float64          `json:"total_risk_reduction"`

	// Quality metrics
	AverageQualityScore float64          `json:"average_quality_score"`
	QualityDistribution map[string]int64 `json:"quality_distribution"`
	ReliabilityScore    float64          `json:"reliability_score"`
	AvailabilityScore   float64          `json:"availability_score"`

	// Business metrics
	TotalImplementationCost float64 `json:"total_implementation_cost"`
	TotalOperationalCost    float64 `json:"total_operational_cost"`
	CostPerControl          float64 `json:"cost_per_control"`
	ROI                     float64 `json:"roi"`

	// Compliance metrics
	ComplianceRate       float64 `json:"compliance_rate"`
	ComplianceViolations int64   `json:"compliance_violations"`
	AuditFindings        int64   `json:"audit_findings"`

	// Performance metrics
	UptimePercentage float64       `json:"uptime_percentage"`
	ResponseTime     time.Duration `json:"response_time"`
	ThroughputRate   float64       `json:"throughput_rate"`
	ErrorRate        float64       `json:"error_rate"`

	// Time periods
	StatisticsPeriod string    `json:"statistics_period"`
	LastUpdated      time.Time `json:"last_updated"`

	// Breakdown metrics
	ControlsByType      map[string]int64 `json:"controls_by_type"`
	ControlsByCategory  map[string]int64 `json:"controls_by_category"`
	ControlsByAssetType map[string]int64 `json:"controls_by_asset_type"`
	ControlsByVulnType  map[string]int64 `json:"controls_by_vuln_type"`
}

// NewCompensatingControlsManager creates a new compensating controls manager
func NewCompensatingControlsManager(config CompensatingControlsConfig, logger *slog.Logger) (*CompensatingControlsManager, error) {
	ccm := &CompensatingControlsManager{
		config:     config,
		logger:     logger,
		statistics: CompensatingControlsStatistics{},
	}

	// Initialize components
	if err := ccm.initializeComponents(); err != nil {
		return nil, fmt.Errorf("failed to initialize components: %w", err)
	}

	logger.Info("Compensating controls manager initialized successfully",
		"enabled_control_types", config.EnabledControlTypes,
		"auto_deployment", config.AutoDeployment,
		"continuous_monitoring", config.ContinuousMonitoring)

	return ccm, nil
}

// RecommendControls recommends compensating controls for a vulnerability
func (ccm *CompensatingControlsManager) RecommendControls(ctx context.Context, vulnerabilityID, assetID string, constraints *ControlConstraints) ([]*ControlRecommendation, error) {
	// Get vulnerability details
	vulnerability, err := ccm.getVulnerabilityDetails(vulnerabilityID)
	if err != nil {
		return nil, fmt.Errorf("failed to get vulnerability details: %w", err)
	}

	// Get asset details
	asset, err := ccm.getAssetDetails(assetID)
	if err != nil {
		return nil, fmt.Errorf("failed to get asset details: %w", err)
	}

	// Find applicable controls
	applicableControls, err := ccm.controlLibrary.FindApplicableControls(ctx, vulnerability, asset)
	if err != nil {
		return nil, fmt.Errorf("failed to find applicable controls: %w", err)
	}

	// Filter by constraints
	filteredControls := ccm.filterControlsByConstraints(applicableControls, constraints)

	// Calculate effectiveness and rank controls
	recommendations := make([]*ControlRecommendation, 0, len(filteredControls))
	for _, control := range filteredControls {
		effectiveness, err := ccm.effectivenessEngine.CalculateEffectiveness(ctx, control, vulnerability, asset)
		if err != nil {
			ccm.logger.Warn("Failed to calculate effectiveness", "control_id", control.ID, "error", err)
			continue
		}

		if effectiveness.OverallEffectiveness >= ccm.config.MinimumEffectiveness {
			recommendation := &ControlRecommendation{
				Control:                 control,
				Effectiveness:           effectiveness,
				DeploymentComplexity:    control.DeploymentComplexity,
				EstimatedCost:           control.ImplementationCost + control.OperationalCost,
				EstimatedDeploymentTime: control.DeploymentTime,
				RiskReduction:           effectiveness.RiskReduction,
				RecommendationScore:     ccm.calculateRecommendationScore(effectiveness, control, constraints),
				Justification:           ccm.generateJustification(control, effectiveness, vulnerability),
			}
			recommendations = append(recommendations, recommendation)
		}
	}

	// Sort by recommendation score
	ccm.sortRecommendations(recommendations)

	ccm.logger.Info("Control recommendations generated",
		"vulnerability_id", vulnerabilityID,
		"asset_id", assetID,
		"total_recommendations", len(recommendations))

	return recommendations, nil
}

// DeployControl deploys a compensating control
func (ccm *CompensatingControlsManager) DeployControl(ctx context.Context, request *ControlDeploymentRequest) (*DeployedControl, error) {
	// Validate deployment request
	if err := ccm.validateDeploymentRequest(request); err != nil {
		return nil, fmt.Errorf("invalid deployment request: %w", err)
	}

	// Get control definition
	controlDef, err := ccm.controlLibrary.GetControlDefinition(request.ControlID)
	if err != nil {
		return nil, fmt.Errorf("failed to get control definition: %w", err)
	}

	// Validate configuration
	if err := ccm.validateConfiguration(controlDef, request.Configuration); err != nil {
		return nil, fmt.Errorf("invalid configuration: %w", err)
	}

	// Create deployed control record
	deployedControl := &DeployedControl{
		ID:                    ccm.generateDeployedControlID(),
		DefinitionID:          request.ControlID,
		VulnerabilityID:       request.VulnerabilityID,
		AssetID:               request.AssetID,
		RemediationJobID:      request.RemediationJobID,
		DeployedBy:            request.DeployedBy,
		DeploymentMethod:      request.DeploymentMethod,
		Configuration:         request.Configuration,
		Status:                "deploying",
		OperationalStatus:     "initializing",
		DeploymentTime:        time.Now(),
		EffectiveDate:         request.EffectiveDate,
		ExpirationDate:        request.ExpirationDate,
		BusinessJustification: request.BusinessJustification,
		BusinessOwner:         request.BusinessOwner,
		TechnicalOwner:        request.TechnicalOwner,
		CreatedAt:             time.Now(),
		UpdatedAt:             time.Now(),
		TenantID:              request.TenantID,
		CustomFields:          make(map[string]interface{}),
	}

	// Store initial record
	if err := ccm.storeDeployedControl(deployedControl); err != nil {
		return nil, fmt.Errorf("failed to store deployed control: %w", err)
	}

	// Execute deployment
	if err := ccm.deploymentEngine.Deploy(ctx, controlDef, deployedControl); err != nil {
		deployedControl.Status = "failed"
		deployedControl.LastError = err.Error()
		deployedControl.UpdatedAt = time.Now()
		ccm.storeDeployedControl(deployedControl)

		// Update statistics
		ccm.updateStatistics("deployment_failed", deployedControl)

		return deployedControl, fmt.Errorf("deployment failed: %w", err)
	}

	// Update status
	deployedControl.Status = "active"
	deployedControl.OperationalStatus = "operational"
	deployedControl.UpdatedAt = time.Now()

	// Perform initial validation if required
	if ccm.config.RequireValidation {
		if err := ccm.performInitialValidation(ctx, deployedControl); err != nil {
			ccm.logger.Warn("Initial validation failed", "control_id", deployedControl.ID, "error", err)
		}
	}

	// Start monitoring if configured
	if ccm.config.ContinuousMonitoring {
		go ccm.startControlMonitoring(ctx, deployedControl.ID)
	}

	// Store updated record
	if err := ccm.storeDeployedControl(deployedControl); err != nil {
		ccm.logger.Error("Failed to store updated deployed control", "error", err)
	}

	// Add audit entry
	ccm.addAuditEntry(deployedControl, "control_deployed", request.DeployedBy, "Compensating control deployed", request)

	// Update statistics
	ccm.updateStatistics("deployment_successful", deployedControl)

	ccm.logger.Info("Compensating control deployed successfully",
		"control_id", deployedControl.ID,
		"definition_id", controlDef.ID,
		"vulnerability_id", request.VulnerabilityID)

	return deployedControl, nil
}

// ValidateControl validates a deployed control's effectiveness
func (ccm *CompensatingControlsManager) ValidateControl(ctx context.Context, controlID string) (*ControlValidationResult, error) {
	// Get deployed control
	deployedControl, err := ccm.getDeployedControl(controlID)
	if err != nil {
		return nil, fmt.Errorf("failed to get deployed control: %w", err)
	}

	// Get control definition
	controlDef, err := ccm.controlLibrary.GetControlDefinition(deployedControl.DefinitionID)
	if err != nil {
		return nil, fmt.Errorf("failed to get control definition: %w", err)
	}

	// Perform validation
	validationResult, err := ccm.validationEngine.ValidateControl(ctx, controlDef, deployedControl)
	if err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Update deployed control with validation results
	deployedControl.ValidationStatus = validationResult.OverallStatus
	deployedControl.ValidationResults = append(deployedControl.ValidationResults, *validationResult)
	deployedControl.LastValidation = time.Now()
	deployedControl.NextValidation = ccm.calculateNextValidation(deployedControl)
	deployedControl.CurrentEffectiveness = validationResult.EffectivenessScore
	deployedControl.UpdatedAt = time.Now()

	// Store updated control
	if err := ccm.storeDeployedControl(deployedControl); err != nil {
		ccm.logger.Error("Failed to store validation results", "error", err)
	}

	// Add audit entry
	ccm.addAuditEntry(deployedControl, "control_validated", "system", "Control validation performed", validationResult)

	ccm.logger.Info("Control validation completed",
		"control_id", controlID,
		"validation_status", validationResult.OverallStatus,
		"effectiveness_score", validationResult.EffectivenessScore)

	return validationResult, nil
}

// MonitorControl monitors a deployed control's health and performance
func (ccm *CompensatingControlsManager) startControlMonitoring(ctx context.Context, controlID string) {
	ticker := time.NewTicker(ccm.config.MonitoringFrequency)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			if err := ccm.performMonitoringCheck(ctx, controlID); err != nil {
				ccm.logger.Error("Monitoring check failed", "control_id", controlID, "error", err)
			}
		case <-ctx.Done():
			return
		}
	}
}

// PerformMonitoringCheck performs a monitoring check on a control
func (ccm *CompensatingControlsManager) performMonitoringCheck(ctx context.Context, controlID string) error {
	deployedControl, err := ccm.getDeployedControl(controlID)
	if err != nil {
		return fmt.Errorf("failed to get deployed control: %w", err)
	}

	if deployedControl.Status != "active" {
		return nil // Skip monitoring for inactive controls
	}

	// Perform health check
	healthResult, err := ccm.monitoringEngine.CheckHealth(ctx, deployedControl)
	if err != nil {
		return fmt.Errorf("health check failed: %w", err)
	}

	// Update health status
	deployedControl.Health = healthResult.Status
	deployedControl.LastHealthCheck = time.Now()
	deployedControl.PerformanceMetrics = healthResult.Metrics

	// Check for alerts
	alerts := ccm.checkAlertConditions(deployedControl, healthResult)
	if len(alerts) > 0 {
		deployedControl.Alerts = append(deployedControl.Alerts, alerts...)
		ccm.sendControlAlerts(deployedControl, alerts)
	}

	// Store monitoring data
	monitoringData := MonitoringDataPoint{
		Timestamp:       time.Now(),
		HealthStatus:    healthResult.Status,
		Metrics:         healthResult.Metrics,
		AlertsTriggered: len(alerts),
	}
	deployedControl.MonitoringData = append(deployedControl.MonitoringData, monitoringData)

	// Update effectiveness based on monitoring
	effectiveness, err := ccm.effectivenessEngine.CalculateCurrentEffectiveness(ctx, deployedControl, healthResult)
	if err != nil {
		ccm.logger.Warn("Failed to calculate current effectiveness", "control_id", controlID, "error", err)
	} else {
		deployedControl.CurrentEffectiveness = effectiveness
	}

	deployedControl.UpdatedAt = time.Now()

	// Store updated control
	return ccm.storeDeployedControl(deployedControl)
}

// ExpireControl expires a compensating control
func (ccm *CompensatingControlsManager) ExpireControl(ctx context.Context, controlID string) error {
	deployedControl, err := ccm.getDeployedControl(controlID)
	if err != nil {
		return fmt.Errorf("failed to get deployed control: %w", err)
	}

	// Update status
	deployedControl.Status = "expired"
	deployedControl.OperationalStatus = "inactive"
	deployedControl.UpdatedAt = time.Now()

	// Perform cleanup if required
	if err := ccm.deploymentEngine.Cleanup(ctx, deployedControl); err != nil {
		ccm.logger.Warn("Cleanup failed", "control_id", controlID, "error", err)
	}

	// Store updated control
	if err := ccm.storeDeployedControl(deployedControl); err != nil {
		return fmt.Errorf("failed to store expired control: %w", err)
	}

	// Add audit entry
	ccm.addAuditEntry(deployedControl, "control_expired", "system", "Control expired", nil)

	// Update statistics
	ccm.updateStatistics("control_expired", deployedControl)

	ccm.logger.Info("Control expired", "control_id", controlID)

	return nil
}

// GetDeployedControl retrieves a deployed control by ID
func (ccm *CompensatingControlsManager) GetDeployedControl(ctx context.Context, controlID string) (*DeployedControl, error) {
	return ccm.getDeployedControl(controlID)
}

// GetControlsForVulnerability returns all controls deployed for a vulnerability
func (ccm *CompensatingControlsManager) GetControlsForVulnerability(ctx context.Context, vulnerabilityID string) ([]*DeployedControl, error) {
	return ccm.getControlsByVulnerability(vulnerabilityID)
}

// GetCompensatingControlsStatistics returns current statistics
func (ccm *CompensatingControlsManager) GetCompensatingControlsStatistics() CompensatingControlsStatistics {
	ccm.mutex.RLock()
	defer ccm.mutex.RUnlock()
	return ccm.statistics
}

// Helper methods
func (ccm *CompensatingControlsManager) initializeComponents() error {
	ccm.controlLibrary = NewControlLibrary(ccm.config)
	ccm.deploymentEngine = NewControlDeploymentEngine(ccm.config)
	ccm.validationEngine = NewControlValidationEngine(ccm.config)
	ccm.monitoringEngine = NewControlMonitoringEngine(ccm.config)
	ccm.effectivenessEngine = NewEffectivenessEngine(ccm.config)
	return nil
}

func (ccm *CompensatingControlsManager) validateDeploymentRequest(request *ControlDeploymentRequest) error {
	if request.ControlID == "" {
		return fmt.Errorf("control ID is required")
	}
	if request.VulnerabilityID == "" {
		return fmt.Errorf("vulnerability ID is required")
	}
	if request.AssetID == "" {
		return fmt.Errorf("asset ID is required")
	}
	if request.DeployedBy == "" {
		return fmt.Errorf("deployed by is required")
	}
	return nil
}

func (ccm *CompensatingControlsManager) validateConfiguration(controlDef *CompensatingControlDefinition, config map[string]interface{}) error {
	// Configuration validation logic
	return nil
}

func (ccm *CompensatingControlsManager) performInitialValidation(ctx context.Context, deployedControl *DeployedControl) error {
	// Initial validation logic
	return nil
}

func (ccm *CompensatingControlsManager) calculateNextValidation(deployedControl *DeployedControl) time.Time {
	// Calculate next validation time based on control definition
	return time.Now().Add(24 * time.Hour) // Default: daily validation
}

func (ccm *CompensatingControlsManager) checkAlertConditions(deployedControl *DeployedControl, healthResult *HealthResult) []ControlAlert {
	var alerts []ControlAlert

	// Check alert thresholds
	for metric, value := range healthResult.Metrics {
		if threshold, exists := ccm.config.AlertThresholds[metric]; exists {
			if value < threshold {
				alert := ControlAlert{
					ID:        ccm.generateAlertID(),
					Type:      "threshold_violation",
					Severity:  "warning",
					Metric:    metric,
					Value:     value,
					Threshold: threshold,
					Message:   fmt.Sprintf("Metric %s (%.2f) below threshold (%.2f)", metric, value, threshold),
					Timestamp: time.Now(),
				}
				alerts = append(alerts, alert)
			}
		}
	}

	return alerts
}

func (ccm *CompensatingControlsManager) sendControlAlerts(deployedControl *DeployedControl, alerts []ControlAlert) {
	// Send alert notifications
	for _, alert := range alerts {
		ccm.logger.Warn("Control alert triggered",
			"control_id", deployedControl.ID,
			"alert_type", alert.Type,
			"severity", alert.Severity,
			"message", alert.Message)
	}
}

func (ccm *CompensatingControlsManager) filterControlsByConstraints(controls []*CompensatingControlDefinition, constraints *ControlConstraints) []*CompensatingControlDefinition {
	if constraints == nil {
		return controls
	}

	var filtered []*CompensatingControlDefinition
	for _, control := range controls {
		if ccm.meetsConstraints(control, constraints) {
			filtered = append(filtered, control)
		}
	}
	return filtered
}

func (ccm *CompensatingControlsManager) meetsConstraints(control *CompensatingControlDefinition, constraints *ControlConstraints) bool {
	// Check cost constraints
	if constraints.MaxCost > 0 && (control.ImplementationCost+control.OperationalCost) > constraints.MaxCost {
		return false
	}

	// Check deployment time constraints
	if constraints.MaxDeploymentTime > 0 && control.DeploymentTime > constraints.MaxDeploymentTime {
		return false
	}

	// Check technology constraints
	if len(constraints.RequiredTechnologies) > 0 {
		for _, required := range constraints.RequiredTechnologies {
			found := false
			for _, tech := range control.Technology {
				if tech == required {
					found = true
					break
				}
			}
			if !found {
				return false
			}
		}
	}

	return true
}

func (ccm *CompensatingControlsManager) calculateRecommendationScore(effectiveness *EffectivenessResult, control *CompensatingControlDefinition, constraints *ControlConstraints) float64 {
	// Base score from effectiveness
	score := effectiveness.OverallEffectiveness * 100

	// Adjust for cost efficiency
	if control.ImplementationCost > 0 {
		costEfficiency := effectiveness.RiskReduction / control.ImplementationCost
		score += costEfficiency * 10
	}

	// Adjust for deployment complexity
	switch control.DeploymentComplexity {
	case "low":
		score += 10
	case "medium":
		score += 5
	case "high":
		score -= 5
	}

	// Adjust for maturity level
	switch control.MaturityLevel {
	case "production":
		score += 10
	case "beta":
		score += 5
	case "alpha":
		score -= 5
	}

	return score
}

func (ccm *CompensatingControlsManager) sortRecommendations(recommendations []*ControlRecommendation) {
	// Sort by recommendation score (descending)
	for i := 0; i < len(recommendations)-1; i++ {
		for j := i + 1; j < len(recommendations); j++ {
			if recommendations[i].RecommendationScore < recommendations[j].RecommendationScore {
				recommendations[i], recommendations[j] = recommendations[j], recommendations[i]
			}
		}
	}
}

func (ccm *CompensatingControlsManager) generateJustification(control *CompensatingControlDefinition, effectiveness *EffectivenessResult, vulnerability *Vulnerability) string {
	return fmt.Sprintf("Control %s provides %.1f%% risk reduction for %s vulnerability through %s mechanism",
		control.Name, effectiveness.RiskReduction*100, vulnerability.Type, control.Mechanism)
}

func (ccm *CompensatingControlsManager) addAuditEntry(deployedControl *DeployedControl, action, user, description string, details interface{}) {
	entry := ControlAuditEntry{
		ID:          ccm.generateAuditID(),
		Action:      action,
		User:        user,
		Timestamp:   time.Now(),
		Description: description,
		Details:     details,
	}
	deployedControl.AuditTrail = append(deployedControl.AuditTrail, entry)
}

func (ccm *CompensatingControlsManager) updateStatistics(event string, deployedControl *DeployedControl) {
	ccm.mutex.Lock()
	defer ccm.mutex.Unlock()

	switch event {
	case "deployment_successful":
		ccm.statistics.TotalDeployments++
		ccm.statistics.SuccessfulDeployments++
		ccm.statistics.ActiveControls++
		ccm.statistics.TotalControls++
	case "deployment_failed":
		ccm.statistics.TotalDeployments++
		ccm.statistics.FailedDeployments++
		ccm.statistics.FailedControls++
	case "control_expired":
		ccm.statistics.ActiveControls--
		ccm.statistics.InactiveControls++
	}

	ccm.statistics.LastUpdated = time.Now()
}

func (ccm *CompensatingControlsManager) generateDeployedControlID() string {
	return fmt.Sprintf("ctrl_%d", time.Now().UnixNano())
}

func (ccm *CompensatingControlsManager) generateAlertID() string {
	return fmt.Sprintf("alert_%d", time.Now().UnixNano())
}

func (ccm *CompensatingControlsManager) generateAuditID() string {
	return fmt.Sprintf("audit_%d", time.Now().UnixNano())
}

// Placeholder storage and utility methods
func (ccm *CompensatingControlsManager) getVulnerabilityDetails(vulnerabilityID string) (*Vulnerability, error) {
	return nil, nil
}
func (ccm *CompensatingControlsManager) getAssetDetails(assetID string) (*Asset, error) {
	return nil, nil
}
func (ccm *CompensatingControlsManager) storeDeployedControl(control *DeployedControl) error {
	return nil
}
func (ccm *CompensatingControlsManager) getDeployedControl(controlID string) (*DeployedControl, error) {
	return nil, nil
}
func (ccm *CompensatingControlsManager) getControlsByVulnerability(vulnerabilityID string) ([]*DeployedControl, error) {
	return nil, nil
}

// Supporting types and structures

type ControlConstraints struct {
	MaxCost              float64       `json:"max_cost"`
	MaxDeploymentTime    time.Duration `json:"max_deployment_time"`
	RequiredTechnologies []string      `json:"required_technologies"`
	ExcludedTypes        []string      `json:"excluded_types"`
	BusinessHoursOnly    bool          `json:"business_hours_only"`
	NoUserImpact         bool          `json:"no_user_impact"`
	ComplianceRequired   []string      `json:"compliance_required"`
}

type ControlRecommendation struct {
	Control                 *CompensatingControlDefinition `json:"control"`
	Effectiveness           *EffectivenessResult           `json:"effectiveness"`
	DeploymentComplexity    string                         `json:"deployment_complexity"`
	EstimatedCost           float64                        `json:"estimated_cost"`
	EstimatedDeploymentTime time.Duration                  `json:"estimated_deployment_time"`
	RiskReduction           float64                        `json:"risk_reduction"`
	RecommendationScore     float64                        `json:"recommendation_score"`
	Justification           string                         `json:"justification"`
	Pros                    []string                       `json:"pros"`
	Cons                    []string                       `json:"cons"`
	Prerequisites           []string                       `json:"prerequisites"`
	AlternativeOptions      []string                       `json:"alternative_options"`
}

type ControlDeploymentRequest struct {
	ControlID             string                 `json:"control_id"`
	VulnerabilityID       string                 `json:"vulnerability_id"`
	AssetID               string                 `json:"asset_id"`
	RemediationJobID      string                 `json:"remediation_job_id"`
	DeployedBy            string                 `json:"deployed_by"`
	DeploymentMethod      string                 `json:"deployment_method"`
	Configuration         map[string]interface{} `json:"configuration"`
	EffectiveDate         time.Time              `json:"effective_date"`
	ExpirationDate        time.Time              `json:"expiration_date"`
	BusinessJustification string                 `json:"business_justification"`
	BusinessOwner         string                 `json:"business_owner"`
	TechnicalOwner        string                 `json:"technical_owner"`
	TenantID              string                 `json:"tenant_id,omitempty"`
}

type EffectivenessFactor struct {
	Factor      string  `json:"factor"`
	Weight      float64 `json:"weight"`
	Value       float64 `json:"value"`
	Description string  `json:"description"`
}

type EffectivenessResult struct {
	OverallEffectiveness float64               `json:"overall_effectiveness"`
	RiskReduction        float64               `json:"risk_reduction"`
	CoveragePercentage   float64               `json:"coverage_percentage"`
	Factors              []EffectivenessFactor `json:"factors"`
	CalculationMethod    string                `json:"calculation_method"`
	CalculatedAt         time.Time             `json:"calculated_at"`
	Confidence           float64               `json:"confidence"`
}

type EffectivenessReading struct {
	Timestamp     time.Time             `json:"timestamp"`
	Effectiveness float64               `json:"effectiveness"`
	Factors       []EffectivenessFactor `json:"factors"`
	Source        string                `json:"source"`
}

type ControlValidationResult struct {
	ID                 string                 `json:"id"`
	ControlID          string                 `json:"control_id"`
	ValidationType     string                 `json:"validation_type"`
	OverallStatus      string                 `json:"overall_status"`
	EffectivenessScore float64                `json:"effectiveness_score"`
	TestResults        []ValidationTestResult `json:"test_results"`
	Issues             []ValidationIssue      `json:"issues"`
	Recommendations    []string               `json:"recommendations"`
	ValidatedAt        time.Time              `json:"validated_at"`
	ValidatedBy        string                 `json:"validated_by"`
	NextValidation     time.Time              `json:"next_validation"`
}

type ValidationTestResult struct {
	TestID   string                 `json:"test_id"`
	TestName string                 `json:"test_name"`
	Status   string                 `json:"status"`
	Score    float64                `json:"score"`
	Results  map[string]interface{} `json:"results"`
	Duration time.Duration          `json:"duration"`
	Error    string                 `json:"error,omitempty"`
}

type ValidationIssue struct {
	ID          string    `json:"id"`
	Severity    string    `json:"severity"`
	Category    string    `json:"category"`
	Description string    `json:"description"`
	Impact      string    `json:"impact"`
	Resolution  string    `json:"resolution"`
	Status      string    `json:"status"`
	DetectedAt  time.Time `json:"detected_at"`
}

type MonitoringDataPoint struct {
	Timestamp       time.Time          `json:"timestamp"`
	HealthStatus    string             `json:"health_status"`
	Metrics         map[string]float64 `json:"metrics"`
	AlertsTriggered int                `json:"alerts_triggered"`
	Source          string             `json:"source"`
}

type ControlAlert struct {
	ID             string    `json:"id"`
	Type           string    `json:"type"`
	Severity       string    `json:"severity"`
	Metric         string    `json:"metric"`
	Value          float64   `json:"value"`
	Threshold      float64   `json:"threshold"`
	Message        string    `json:"message"`
	Timestamp      time.Time `json:"timestamp"`
	Acknowledged   bool      `json:"acknowledged"`
	AcknowledgedBy string    `json:"acknowledged_by,omitempty"`
	AcknowledgedAt time.Time `json:"acknowledged_at,omitempty"`
}

type HealthResult struct {
	Status        string             `json:"status"`
	Score         float64            `json:"score"`
	Metrics       map[string]float64 `json:"metrics"`
	Issues        []HealthIssue      `json:"issues"`
	Timestamp     time.Time          `json:"timestamp"`
	CheckDuration time.Duration      `json:"check_duration"`
}

type HealthIssue struct {
	Type        string `json:"type"`
	Severity    string `json:"severity"`
	Description string `json:"description"`
	Impact      string `json:"impact"`
}

type ComplianceEvidence struct {
	ID           string                 `json:"id"`
	Framework    string                 `json:"framework"`
	Control      string                 `json:"control"`
	EvidenceType string                 `json:"evidence_type"`
	Content      string                 `json:"content"`
	URL          string                 `json:"url"`
	CollectedAt  time.Time              `json:"collected_at"`
	CollectedBy  string                 `json:"collected_by"`
	Metadata     map[string]interface{} `json:"metadata"`
}

type IntegrationError struct {
	ID          string    `json:"id"`
	Integration string    `json:"integration"`
	ErrorType   string    `json:"error_type"`
	Message     string    `json:"message"`
	Timestamp   time.Time `json:"timestamp"`
	Resolved    bool      `json:"resolved"`
	ResolvedAt  time.Time `json:"resolved_at,omitempty"`
}

type ControlError struct {
	ID         string    `json:"id"`
	ErrorType  string    `json:"error_type"`
	Severity   string    `json:"severity"`
	Message    string    `json:"message"`
	Context    string    `json:"context"`
	Timestamp  time.Time `json:"timestamp"`
	Resolved   bool      `json:"resolved"`
	Resolution string    `json:"resolution,omitempty"`
}

type ControlAuditEntry struct {
	ID          string      `json:"id"`
	Action      string      `json:"action"`
	User        string      `json:"user"`
	Timestamp   time.Time   `json:"timestamp"`
	Description string      `json:"description"`
	Details     interface{} `json:"details"`
	IPAddress   string      `json:"ip_address,omitempty"`
	UserAgent   string      `json:"user_agent,omitempty"`
}

type CustomControlType struct {
	Name        string           `json:"name"`
	Category    string           `json:"category"`
	Description string           `json:"description"`
	Properties  []string         `json:"properties"`
	Validation  []ValidationRule `json:"validation"`
}

type QualityGate struct {
	Name        string  `json:"name"`
	Metric      string  `json:"metric"`
	Threshold   float64 `json:"threshold"`
	Required    bool    `json:"required"`
	Description string  `json:"description"`
}

type ValidationRule struct {
	Field         string        `json:"field"`
	Type          string        `json:"type"`
	Required      bool          `json:"required"`
	MinValue      interface{}   `json:"min_value,omitempty"`
	MaxValue      interface{}   `json:"max_value,omitempty"`
	Pattern       string        `json:"pattern,omitempty"`
	AllowedValues []interface{} `json:"allowed_values,omitempty"`
}

type ValidationTest struct {
	ID         string                 `json:"id"`
	Name       string                 `json:"name"`
	Type       string                 `json:"type"`
	Parameters map[string]interface{} `json:"parameters"`
	Expected   interface{}            `json:"expected"`
	Timeout    time.Duration          `json:"timeout"`
	Required   bool                   `json:"required"`
}

type HealthCheck struct {
	ID         string                 `json:"id"`
	Name       string                 `json:"name"`
	Type       string                 `json:"type"`
	Parameters map[string]interface{} `json:"parameters"`
	Interval   time.Duration          `json:"interval"`
	Timeout    time.Duration          `json:"timeout"`
	Critical   bool                   `json:"critical"`
}

type QualityCheck struct {
	ID       string                 `json:"id"`
	Name     string                 `json:"name"`
	Type     string                 `json:"type"`
	Criteria map[string]interface{} `json:"criteria"`
	Weight   float64                `json:"weight"`
	Required bool                   `json:"required"`
}

type IntegrationPoint struct {
	Type        string                 `json:"type"`
	Protocol    string                 `json:"protocol"`
	Endpoint    string                 `json:"endpoint"`
	Method      string                 `json:"method"`
	Parameters  map[string]interface{} `json:"parameters"`
	Credentials string                 `json:"credentials"`
	Timeout     time.Duration          `json:"timeout"`
}

type APIEndpoint struct {
	Path           string                 `json:"path"`
	Method         string                 `json:"method"`
	Description    string                 `json:"description"`
	Parameters     map[string]interface{} `json:"parameters"`
	Response       map[string]interface{} `json:"response"`
	Authentication string                 `json:"authentication"`
}

// Placeholder component types
type ControlLibrary struct{}
type ControlDeploymentEngine struct{}
type ControlValidationEngine struct{}
type ControlMonitoringEngine struct{}
type EffectivenessEngine struct{}

func NewControlLibrary(config CompensatingControlsConfig) *ControlLibrary {
	return &ControlLibrary{}
}

func NewControlDeploymentEngine(config CompensatingControlsConfig) *ControlDeploymentEngine {
	return &ControlDeploymentEngine{}
}

func NewControlValidationEngine(config CompensatingControlsConfig) *ControlValidationEngine {
	return &ControlValidationEngine{}
}

func NewControlMonitoringEngine(config CompensatingControlsConfig) *ControlMonitoringEngine {
	return &ControlMonitoringEngine{}
}

func NewEffectivenessEngine(config CompensatingControlsConfig) *EffectivenessEngine {
	return &EffectivenessEngine{}
}

func (cl *ControlLibrary) FindApplicableControls(ctx context.Context, vulnerability *Vulnerability, asset *Asset) ([]*CompensatingControlDefinition, error) {
	return []*CompensatingControlDefinition{}, nil
}

func (cl *ControlLibrary) GetControlDefinition(controlID string) (*CompensatingControlDefinition, error) {
	return &CompensatingControlDefinition{ID: controlID}, nil
}

func (cde *ControlDeploymentEngine) Deploy(ctx context.Context, controlDef *CompensatingControlDefinition, deployedControl *DeployedControl) error {
	return nil
}

func (cde *ControlDeploymentEngine) Cleanup(ctx context.Context, deployedControl *DeployedControl) error {
	return nil
}

func (cve *ControlValidationEngine) ValidateControl(ctx context.Context, controlDef *CompensatingControlDefinition, deployedControl *DeployedControl) (*ControlValidationResult, error) {
	return &ControlValidationResult{
		ID:                 "validation_" + fmt.Sprintf("%d", time.Now().UnixNano()),
		ControlID:          deployedControl.ID,
		ValidationType:     "automated",
		OverallStatus:      "passed",
		EffectivenessScore: 0.85,
		ValidatedAt:        time.Now(),
		ValidatedBy:        "system",
		NextValidation:     time.Now().Add(24 * time.Hour),
	}, nil
}

func (cme *ControlMonitoringEngine) CheckHealth(ctx context.Context, deployedControl *DeployedControl) (*HealthResult, error) {
	return &HealthResult{
		Status:        "healthy",
		Score:         0.9,
		Metrics:       map[string]float64{"availability": 0.99, "performance": 0.85},
		Timestamp:     time.Now(),
		CheckDuration: time.Second,
	}, nil
}

func (ee *EffectivenessEngine) CalculateEffectiveness(ctx context.Context, control *CompensatingControlDefinition, vulnerability *Vulnerability, asset *Asset) (*EffectivenessResult, error) {
	return &EffectivenessResult{
		OverallEffectiveness: 0.8,
		RiskReduction:        0.75,
		CoveragePercentage:   0.85,
		CalculationMethod:    "iSECTECH_v1.0",
		CalculatedAt:         time.Now(),
		Confidence:           0.9,
	}, nil
}

func (ee *EffectivenessEngine) CalculateCurrentEffectiveness(ctx context.Context, deployedControl *DeployedControl, healthResult *HealthResult) (float64, error) {
	return 0.8, nil
}

// Simplified Asset and Vulnerability types for this context
type Asset struct {
	ID   string `json:"id"`
	Type string `json:"type"`
	Name string `json:"name"`
}

type Vulnerability struct {
	ID   string  `json:"id"`
	Type string  `json:"type"`
	CVSS float64 `json:"cvss"`
}
