// repository.go - Production-grade central vulnerability repository for iSECTECH
// Provides unified vulnerability data storage with advanced querying and correlation

package data

import (
	"context"
	"crypto/sha256"
	"database/sql"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"log/slog"
	"strings"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

// VulnerabilityRepository provides centralized vulnerability data management for iSECTECH
type VulnerabilityRepository struct {
	db                 *sql.DB
	config             RepositoryConfig
	logger             *slog.Logger
	cache              Cache
	indexManager       *IndexManager
	metadataCache      map[string]interface{}
	metadataCacheMutex sync.RWMutex
}

// RepositoryConfig contains configuration for the vulnerability repository
type RepositoryConfig struct {
	DatabaseURL       string        `json:"database_url"`
	MaxConnections    int           `json:"max_connections"`
	ConnectionTimeout time.Duration `json:"connection_timeout"`
	QueryTimeout      time.Duration `json:"query_timeout"`

	// Indexing configuration
	EnableFullTextSearch bool          `json:"enable_full_text_search"`
	EnableVectorSearch   bool          `json:"enable_vector_search"`
	IndexUpdateInterval  time.Duration `json:"index_update_interval"`

	// Cache configuration
	EnableCaching   bool          `json:"enable_caching"`
	CacheExpiration time.Duration `json:"cache_expiration"`
	CacheMaxSize    int           `json:"cache_max_size"`

	// Performance tuning
	BatchSize          int  `json:"batch_size"`
	EnablePartitioning bool `json:"enable_partitioning"`
	RetentionDays      int  `json:"retention_days"`

	// Security settings
	EncryptData     bool `json:"encrypt_data"`
	AuditChanges    bool `json:"audit_changes"`
	TenantIsolation bool `json:"tenant_isolation"`
	AccessLogging   bool `json:"access_logging"`
}

// UnifiedVulnerability represents the canonical vulnerability data model for iSECTECH
type UnifiedVulnerability struct {
	// Core identification
	ID                string `json:"id" db:"id"`
	VulnerabilityHash string `json:"vulnerability_hash" db:"vulnerability_hash"`
	CanonicalID       string `json:"canonical_id" db:"canonical_id"`

	// Source information
	ScannerType string `json:"scanner_type" db:"scanner_type"`
	ScannerID   string `json:"scanner_id" db:"scanner_id"`
	ScanID      string `json:"scan_id" db:"scan_id"`
	OriginalID  string `json:"original_id" db:"original_id"`

	// Basic vulnerability information
	Title        string   `json:"title" db:"title"`
	Description  string   `json:"description" db:"description"`
	Severity     string   `json:"severity" db:"severity"`
	CVSS2Score   *float64 `json:"cvss2_score,omitempty" db:"cvss2_score"`
	CVSS3Score   *float64 `json:"cvss3_score,omitempty" db:"cvss3_score"`
	CVSS31Score  *float64 `json:"cvss31_score,omitempty" db:"cvss31_score"`
	CVSS2Vector  string   `json:"cvss2_vector,omitempty" db:"cvss2_vector"`
	CVSS3Vector  string   `json:"cvss3_vector,omitempty" db:"cvss3_vector"`
	CVSS31Vector string   `json:"cvss31_vector,omitempty" db:"cvss31_vector"`

	// Vulnerability classification
	CVE               pq.StringArray `json:"cve" db:"cve"`
	CWE               pq.StringArray `json:"cwe" db:"cwe"`
	OWASP             pq.StringArray `json:"owasp" db:"owasp"`
	VulnerabilityType string         `json:"vulnerability_type" db:"vulnerability_type"`
	Category          string         `json:"category" db:"category"`
	Family            string         `json:"family" db:"family"`

	// Asset correlation
	AssetID         string `json:"asset_id" db:"asset_id"`
	AssetType       string `json:"asset_type" db:"asset_type"`
	AssetIdentifier string `json:"asset_identifier" db:"asset_identifier"`
	AssetCPE        string `json:"asset_cpe,omitempty" db:"asset_cpe"`

	// Location and context
	Location         VulnerabilityLocation `json:"location" db:"location"`
	NetworkContext   *NetworkContext       `json:"network_context,omitempty" db:"network_context"`
	WebContext       *WebContext           `json:"web_context,omitempty" db:"web_context"`
	ContainerContext *ContainerContext     `json:"container_context,omitempty" db:"container_context"`
	CloudContext     *CloudContext         `json:"cloud_context,omitempty" db:"cloud_context"`
	CodeContext      *CodeContext          `json:"code_context,omitempty" db:"code_context"`

	// Risk assessment
	RiskScore           float64 `json:"risk_score" db:"risk_score"`
	BusinessImpact      string  `json:"business_impact" db:"business_impact"`
	Exploitable         bool    `json:"exploitable" db:"exploitable"`
	ExploitAvailable    bool    `json:"exploit_available" db:"exploit_available"`
	PatchAvailable      bool    `json:"patch_available" db:"patch_available"`
	WorkaroundAvailable bool    `json:"workaround_available" db:"workaround_available"`

	// Remediation information
	Solution       string         `json:"solution,omitempty" db:"solution"`
	Workaround     string         `json:"workaround,omitempty" db:"workaround"`
	References     pq.StringArray `json:"references" db:"references"`
	VendorAdvisory string         `json:"vendor_advisory,omitempty" db:"vendor_advisory"`

	// Detection and validation
	DetectionTime    time.Time `json:"detection_time" db:"detection_time"`
	FirstSeen        time.Time `json:"first_seen" db:"first_seen"`
	LastSeen         time.Time `json:"last_seen" db:"last_seen"`
	ValidationStatus string    `json:"validation_status" db:"validation_status"`
	FalsePositive    bool      `json:"false_positive" db:"false_positive"`
	Confidence       float64   `json:"confidence" db:"confidence"`

	// Data quality and source
	DataQuality        DataQualityMetrics     `json:"data_quality" db:"data_quality"`
	SourceMetadata     map[string]interface{} `json:"source_metadata" db:"source_metadata"`
	ProcessingMetadata ProcessingMetadata     `json:"processing_metadata" db:"processing_metadata"`

	// Enrichment data
	ThreatIntelligence *ThreatIntelligence `json:"threat_intelligence,omitempty" db:"threat_intelligence"`
	ComplianceMapping  []ComplianceMapping `json:"compliance_mapping" db:"compliance_mapping"`
	BusinessContext    BusinessContext     `json:"business_context" db:"business_context"`

	// Correlation and relationships
	RelatedFindings pq.StringArray `json:"related_findings" db:"related_findings"`
	ParentFinding   string         `json:"parent_finding,omitempty" db:"parent_finding"`
	ChildFindings   pq.StringArray `json:"child_findings" db:"child_findings"`
	DuplicateOf     string         `json:"duplicate_of,omitempty" db:"duplicate_of"`
	Duplicates      pq.StringArray `json:"duplicates" db:"duplicates"`

	// Lifecycle management
	Status          string     `json:"status" db:"status"`
	AssignedTo      string     `json:"assigned_to,omitempty" db:"assigned_to"`
	Priority        string     `json:"priority" db:"priority"`
	TargetDate      *time.Time `json:"target_date,omitempty" db:"target_date"`
	ResolutionDate  *time.Time `json:"resolution_date,omitempty" db:"resolution_date"`
	ResolutionNotes string     `json:"resolution_notes,omitempty" db:"resolution_notes"`

	// Audit and compliance
	TenantID  string    `json:"tenant_id" db:"tenant_id"`
	CreatedAt time.Time `json:"created_at" db:"created_at"`
	UpdatedAt time.Time `json:"updated_at" db:"updated_at"`
	CreatedBy string    `json:"created_by" db:"created_by"`
	UpdatedBy string    `json:"updated_by" db:"updated_by"`
	Version   int       `json:"version" db:"version"`

	// Custom fields for iSECTECH specific requirements
	Tags         map[string]string      `json:"tags" db:"tags"`
	CustomFields map[string]interface{} `json:"custom_fields" db:"custom_fields"`
}

// VulnerabilityLocation contains location-specific information
type VulnerabilityLocation struct {
	Type      string                 `json:"type"` // network, web, container, cloud, code
	Primary   string                 `json:"primary"`
	Secondary string                 `json:"secondary,omitempty"`
	Details   map[string]interface{} `json:"details"`
}

// Context structures for different scanner types

type NetworkContext struct {
	HostIP         string `json:"host_ip"`
	HostFQDN       string `json:"host_fqdn,omitempty"`
	Port           int    `json:"port,omitempty"`
	Protocol       string `json:"protocol,omitempty"`
	Service        string `json:"service,omitempty"`
	ServiceVersion string `json:"service_version,omitempty"`
	OSInfo         string `json:"os_info,omitempty"`
	NetworkSegment string `json:"network_segment,omitempty"`
}

type WebContext struct {
	URL          string `json:"url"`
	Method       string `json:"method,omitempty"`
	Parameter    string `json:"parameter,omitempty"`
	Evidence     string `json:"evidence,omitempty"`
	RequestData  string `json:"request_data,omitempty"`
	ResponseData string `json:"response_data,omitempty"`
	Technology   string `json:"technology,omitempty"`
	Framework    string `json:"framework,omitempty"`
}

type ContainerContext struct {
	ImageName      string `json:"image_name"`
	ImageTag       string `json:"image_tag,omitempty"`
	ImageDigest    string `json:"image_digest,omitempty"`
	Registry       string `json:"registry,omitempty"`
	PackageName    string `json:"package_name,omitempty"`
	PackageVersion string `json:"package_version,omitempty"`
	LayerInfo      string `json:"layer_info,omitempty"`
	Dockerfile     string `json:"dockerfile,omitempty"`
}

type CloudContext struct {
	Provider       string `json:"provider"`
	Region         string `json:"region"`
	AccountID      string `json:"account_id,omitempty"`
	ResourceType   string `json:"resource_type"`
	ResourceID     string `json:"resource_id"`
	ResourceName   string `json:"resource_name,omitempty"`
	ResourceArn    string `json:"resource_arn,omitempty"`
	ServiceName    string `json:"service_name"`
	PolicyDocument string `json:"policy_document,omitempty"`
}

type CodeContext struct {
	Repository  string `json:"repository"`
	Branch      string `json:"branch,omitempty"`
	Commit      string `json:"commit,omitempty"`
	FilePath    string `json:"file_path"`
	StartLine   int    `json:"start_line"`
	EndLine     int    `json:"end_line"`
	Function    string `json:"function,omitempty"`
	Class       string `json:"class,omitempty"`
	Language    string `json:"language"`
	CodeSnippet string `json:"code_snippet,omitempty"`
}

// Data quality and processing metadata

type DataQualityMetrics struct {
	CompletenessScore float64  `json:"completeness_score"`
	AccuracyScore     float64  `json:"accuracy_score"`
	ConsistencyScore  float64  `json:"consistency_score"`
	ValidityScore     float64  `json:"validity_score"`
	OverallScore      float64  `json:"overall_score"`
	QualityIssues     []string `json:"quality_issues"`
}

type ProcessingMetadata struct {
	ProcessedAt          time.Time     `json:"processed_at"`
	ProcessorVersion     string        `json:"processor_version"`
	NormalizationVersion string        `json:"normalization_version"`
	EnrichmentVersion    string        `json:"enrichment_version"`
	DeduplicationMethod  string        `json:"deduplication_method"`
	CorrelationMethod    string        `json:"correlation_method"`
	ProcessingLatency    time.Duration `json:"processing_latency"`
}

// Enrichment data structures

type ThreatIntelligence struct {
	IOCMatches          []IOCMatch `json:"ioc_matches"`
	ThreatActors        []string   `json:"threat_actors"`
	Campaigns           []string   `json:"campaigns"`
	TTP                 []string   `json:"ttp"` // Tactics, Techniques, Procedures
	ThreatScore         float64    `json:"threat_score"`
	IntelligenceSources []string   `json:"intelligence_sources"`
	LastUpdated         time.Time  `json:"last_updated"`
}

type IOCMatch struct {
	Type       string    `json:"type"` // ip, domain, hash, etc.
	Value      string    `json:"value"`
	Source     string    `json:"source"`
	Confidence float64   `json:"confidence"`
	FirstSeen  time.Time `json:"first_seen"`
	LastSeen   time.Time `json:"last_seen"`
}

type ComplianceMapping struct {
	Framework        string `json:"framework"`
	ControlID        string `json:"control_id"`
	ControlTitle     string `json:"control_title"`
	Requirement      string `json:"requirement"`
	ComplianceStatus string `json:"compliance_status"`
	Evidence         string `json:"evidence,omitempty"`
}

type BusinessContext struct {
	Environment        string `json:"environment"` // prod, dev, test, staging
	Application        string `json:"application,omitempty"`
	Owner              string `json:"owner,omitempty"`
	BusinessUnit       string `json:"business_unit,omitempty"`
	CostCenter         string `json:"cost_center,omitempty"`
	Criticality        string `json:"criticality"` // critical, high, medium, low
	DataClassification string `json:"data_classification"`
	Confidentiality    string `json:"confidentiality"`
	Integrity          string `json:"integrity"`
	Availability       string `json:"availability"`
}

// Query and search structures

type VulnerabilityQuery struct {
	// Basic filters
	IDs          []string `json:"ids,omitempty"`
	ScannerTypes []string `json:"scanner_types,omitempty"`
	Severities   []string `json:"severities,omitempty"`
	Statuses     []string `json:"statuses,omitempty"`
	CVEs         []string `json:"cves,omitempty"`
	CWEs         []string `json:"cwes,omitempty"`

	// Asset filters
	AssetIDs   []string `json:"asset_ids,omitempty"`
	AssetTypes []string `json:"asset_types,omitempty"`

	// Risk filters
	MinRiskScore    *float64 `json:"min_risk_score,omitempty"`
	MaxRiskScore    *float64 `json:"max_risk_score,omitempty"`
	BusinessImpacts []string `json:"business_impacts,omitempty"`

	// Time filters
	DetectedAfter  *time.Time `json:"detected_after,omitempty"`
	DetectedBefore *time.Time `json:"detected_before,omitempty"`

	// Text search
	SearchText   string   `json:"search_text,omitempty"`
	SearchFields []string `json:"search_fields,omitempty"`

	// Advanced filters
	ExploitableOnly bool `json:"exploitable_only,omitempty"`
	PatchableOnly   bool `json:"patchable_only,omitempty"`
	FalsePositives  bool `json:"false_positives,omitempty"`

	// Tenant isolation
	TenantID string `json:"tenant_id,omitempty"`

	// Custom filters
	Tags         map[string]string      `json:"tags,omitempty"`
	CustomFields map[string]interface{} `json:"custom_fields,omitempty"`

	// Pagination and sorting
	Limit     int    `json:"limit"`
	Offset    int    `json:"offset"`
	SortBy    string `json:"sort_by"`
	SortOrder string `json:"sort_order"` // asc, desc
}

type VulnerabilitySearchResult struct {
	Vulnerabilities []UnifiedVulnerability `json:"vulnerabilities"`
	TotalCount      int                    `json:"total_count"`
	FilteredCount   int                    `json:"filtered_count"`
	Aggregations    map[string]interface{} `json:"aggregations"`
	SearchMetadata  SearchMetadata         `json:"search_metadata"`
}

type SearchMetadata struct {
	QueryTime       time.Duration `json:"query_time"`
	IndexesUsed     []string      `json:"indexes_used"`
	CacheHit        bool          `json:"cache_hit"`
	ProcessingNotes []string      `json:"processing_notes"`
}

// Batch operations

type BatchOperation struct {
	Type            string                 `json:"type"` // insert, update, delete
	Vulnerabilities []UnifiedVulnerability `json:"vulnerabilities"`
	Conditions      map[string]interface{} `json:"conditions"`
	Options         BatchOptions           `json:"options"`
}

type BatchOptions struct {
	IgnoreConflicts  bool `json:"ignore_conflicts"`
	UpdateOnConflict bool `json:"update_on_conflict"`
	ValidateData     bool `json:"validate_data"`
	EnableAuditing   bool `json:"enable_auditing"`
	ReturnUpdated    bool `json:"return_updated"`
}

type BatchResult struct {
	TotalProcessed int           `json:"total_processed"`
	SuccessCount   int           `json:"success_count"`
	FailureCount   int           `json:"failure_count"`
	UpdatedIDs     []string      `json:"updated_ids"`
	Errors         []BatchError  `json:"errors"`
	ProcessingTime time.Duration `json:"processing_time"`
}

type BatchError struct {
	Index           int    `json:"index"`
	VulnerabilityID string `json:"vulnerability_id"`
	Error           string `json:"error"`
	ErrorCode       string `json:"error_code"`
}

// Statistics and analytics

type VulnerabilityStatistics struct {
	TotalVulnerabilities int                        `json:"total_vulnerabilities"`
	SeverityBreakdown    map[string]int             `json:"severity_breakdown"`
	StatusBreakdown      map[string]int             `json:"status_breakdown"`
	ScannerBreakdown     map[string]int             `json:"scanner_breakdown"`
	AssetTypeBreakdown   map[string]int             `json:"asset_type_breakdown"`
	TopCVEs              []CVEStatistic             `json:"top_cves"`
	TopCWEs              []CWEStatistic             `json:"top_cwes"`
	TrendData            []TrendPoint               `json:"trend_data"`
	RiskDistribution     RiskDistribution           `json:"risk_distribution"`
	ComplianceStatus     map[string]ComplianceStats `json:"compliance_status"`
}

type CVEStatistic struct {
	CVE            string `json:"cve"`
	Count          int    `json:"count"`
	Severity       string `json:"severity"`
	AffectedAssets int    `json:"affected_assets"`
}

type CWEStatistic struct {
	CWE         string `json:"cwe"`
	Count       int    `json:"count"`
	Description string `json:"description"`
	Category    string `json:"category"`
}

type TrendPoint struct {
	Date             time.Time `json:"date"`
	Count            int       `json:"count"`
	NewCount         int       `json:"new_count"`
	ResolvedCount    int       `json:"resolved_count"`
	AverageRiskScore float64   `json:"average_risk_score"`
}

type RiskDistribution struct {
	Critical     int     `json:"critical"`
	High         int     `json:"high"`
	Medium       int     `json:"medium"`
	Low          int     `json:"low"`
	Info         int     `json:"info"`
	AverageScore float64 `json:"average_score"`
	MedianScore  float64 `json:"median_score"`
}

type ComplianceStats struct {
	Framework      string  `json:"framework"`
	Compliant      int     `json:"compliant"`
	NonCompliant   int     `json:"non_compliant"`
	ComplianceRate float64 `json:"compliance_rate"`
}

// Cache interface for performance optimization
type Cache interface {
	Get(key string) (interface{}, bool)
	Set(key string, value interface{}, expiration time.Duration) error
	Delete(key string) error
	Clear() error
	Stats() CacheStats
}

type CacheStats struct {
	HitCount    int64   `json:"hit_count"`
	MissCount   int64   `json:"miss_count"`
	HitRate     float64 `json:"hit_rate"`
	Size        int     `json:"size"`
	MemoryUsage int64   `json:"memory_usage"`
}

// IndexManager handles database indexing for optimal query performance
type IndexManager struct {
	db     *sql.DB
	logger *slog.Logger
	config RepositoryConfig
}

// RepositoryInterface defines the contract for vulnerability repository operations
type RepositoryInterface interface {
	// Basic CRUD operations
	Create(ctx context.Context, vuln *UnifiedVulnerability) error
	GetByID(ctx context.Context, id string) (*UnifiedVulnerability, error)
	Update(ctx context.Context, vuln *UnifiedVulnerability) error
	Delete(ctx context.Context, id string) error

	// Batch operations
	CreateBatch(ctx context.Context, vulns []UnifiedVulnerability) (*BatchResult, error)
	UpdateBatch(ctx context.Context, vulns []UnifiedVulnerability) (*BatchResult, error)
	DeleteBatch(ctx context.Context, ids []string) (*BatchResult, error)

	// Query and search
	Search(ctx context.Context, query VulnerabilityQuery) (*VulnerabilitySearchResult, error)
	SearchFullText(ctx context.Context, searchText string, options map[string]interface{}) (*VulnerabilitySearchResult, error)

	// Asset correlation
	FindByAsset(ctx context.Context, assetID string) ([]UnifiedVulnerability, error)
	FindByCPE(ctx context.Context, cpe string) ([]UnifiedVulnerability, error)

	// Deduplication support
	FindSimilar(ctx context.Context, vuln *UnifiedVulnerability, threshold float64) ([]UnifiedVulnerability, error)
	MarkDuplicate(ctx context.Context, vulnID, duplicateOfID string) error

	// Statistics and analytics
	GetStatistics(ctx context.Context, filters map[string]interface{}) (*VulnerabilityStatistics, error)
	GetTrends(ctx context.Context, timeRange string, granularity string) ([]TrendPoint, error)

	// Lifecycle management
	UpdateStatus(ctx context.Context, id string, status string, notes string) error
	AssignVulnerability(ctx context.Context, id string, assignedTo string) error
	ResolveVulnerability(ctx context.Context, id string, resolution string) error

	// Data maintenance
	Archive(ctx context.Context, olderThan time.Time) (int, error)
	Vacuum(ctx context.Context) error
	ReindexAll(ctx context.Context) error

	// Health and monitoring
	HealthCheck(ctx context.Context) error
	GetMetrics(ctx context.Context) (map[string]interface{}, error)
}

// NewVulnerabilityRepository creates a new production-grade vulnerability repository
func NewVulnerabilityRepository(config RepositoryConfig, db *sql.DB, cache Cache, logger *slog.Logger) *VulnerabilityRepository {
	indexManager := &IndexManager{
		db:     db,
		logger: logger.With("component", "index_manager"),
		config: config,
	}

	repo := &VulnerabilityRepository{
		db:            db,
		config:        config,
		logger:        logger.With("component", "vulnerability_repository"),
		cache:         cache,
		indexManager:  indexManager,
		metadataCache: make(map[string]interface{}),
	}

	return repo
}

// Initialize sets up the repository with required database schema and indexes
func (vr *VulnerabilityRepository) Initialize(ctx context.Context) error {
	vr.logger.Info("Initializing vulnerability repository")

	// Create database schema
	if err := vr.createSchema(ctx); err != nil {
		return fmt.Errorf("failed to create schema: %w", err)
	}

	// Create indexes for optimal performance
	if err := vr.indexManager.createIndexes(ctx); err != nil {
		return fmt.Errorf("failed to create indexes: %w", err)
	}

	// Setup partitioning if enabled
	if vr.config.EnablePartitioning {
		if err := vr.setupPartitioning(ctx); err != nil {
			return fmt.Errorf("failed to setup partitioning: %w", err)
		}
	}

	vr.logger.Info("Vulnerability repository initialized successfully")
	return nil
}

// Create stores a new vulnerability in the repository
func (vr *VulnerabilityRepository) Create(ctx context.Context, vuln *UnifiedVulnerability) error {
	// Generate ID if not provided
	if vuln.ID == "" {
		vuln.ID = uuid.New().String()
	}

	// Generate vulnerability hash for deduplication
	vuln.VulnerabilityHash = vr.generateVulnerabilityHash(vuln)

	// Set timestamps
	now := time.Now()
	vuln.CreatedAt = now
	vuln.UpdatedAt = now
	vuln.Version = 1

	// Validate vulnerability data
	if err := vr.validateVulnerability(vuln); err != nil {
		return fmt.Errorf("validation failed: %w", err)
	}

	// Insert into database
	query := `
		INSERT INTO vulnerabilities (
			id, vulnerability_hash, canonical_id, scanner_type, scanner_id, scan_id, 
			original_id, title, description, severity, cvss2_score, cvss3_score, cvss31_score,
			cvss2_vector, cvss3_vector, cvss31_vector, cve, cwe, owasp, vulnerability_type,
			category, family, asset_id, asset_type, asset_identifier, asset_cpe,
			location, network_context, web_context, container_context, cloud_context, code_context,
			risk_score, business_impact, exploitable, exploit_available, patch_available, workaround_available,
			solution, workaround, references, vendor_advisory, detection_time, first_seen, last_seen,
			validation_status, false_positive, confidence, data_quality, source_metadata, processing_metadata,
			threat_intelligence, compliance_mapping, business_context, related_findings, parent_finding,
			child_findings, duplicate_of, duplicates, status, assigned_to, priority, target_date,
			resolution_date, resolution_notes, tenant_id, created_at, updated_at, created_by, updated_by,
			version, tags, custom_fields
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20,
			$21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35, $36, $37, $38, $39, $40,
			$41, $42, $43, $44, $45, $46, $47, $48, $49, $50, $51, $52, $53, $54, $55, $56, $57, $58, $59, $60,
			$61, $62, $63, $64, $65, $66, $67, $68, $69, $70, $71, $72, $73, $74, $75)`

	_, err := vr.db.ExecContext(ctx, query,
		vuln.ID, vuln.VulnerabilityHash, vuln.CanonicalID, vuln.ScannerType, vuln.ScannerID, vuln.ScanID,
		vuln.OriginalID, vuln.Title, vuln.Description, vuln.Severity, vuln.CVSS2Score, vuln.CVSS3Score, vuln.CVSS31Score,
		vuln.CVSS2Vector, vuln.CVSS3Vector, vuln.CVSS31Vector, vuln.CVE, vuln.CWE, vuln.OWASP, vuln.VulnerabilityType,
		vuln.Category, vuln.Family, vuln.AssetID, vuln.AssetType, vuln.AssetIdentifier, vuln.AssetCPE,
		vr.marshalJSON(vuln.Location), vr.marshalJSON(vuln.NetworkContext), vr.marshalJSON(vuln.WebContext),
		vr.marshalJSON(vuln.ContainerContext), vr.marshalJSON(vuln.CloudContext), vr.marshalJSON(vuln.CodeContext),
		vuln.RiskScore, vuln.BusinessImpact, vuln.Exploitable, vuln.ExploitAvailable, vuln.PatchAvailable, vuln.WorkaroundAvailable,
		vuln.Solution, vuln.Workaround, vuln.References, vuln.VendorAdvisory, vuln.DetectionTime, vuln.FirstSeen, vuln.LastSeen,
		vuln.ValidationStatus, vuln.FalsePositive, vuln.Confidence, vr.marshalJSON(vuln.DataQuality),
		vr.marshalJSON(vuln.SourceMetadata), vr.marshalJSON(vuln.ProcessingMetadata),
		vr.marshalJSON(vuln.ThreatIntelligence), vr.marshalJSON(vuln.ComplianceMapping), vr.marshalJSON(vuln.BusinessContext),
		vuln.RelatedFindings, vuln.ParentFinding, vuln.ChildFindings, vuln.DuplicateOf, vuln.Duplicates,
		vuln.Status, vuln.AssignedTo, vuln.Priority, vuln.TargetDate, vuln.ResolutionDate, vuln.ResolutionNotes,
		vuln.TenantID, vuln.CreatedAt, vuln.UpdatedAt, vuln.CreatedBy, vuln.UpdatedBy, vuln.Version,
		vr.marshalJSON(vuln.Tags), vr.marshalJSON(vuln.CustomFields))

	if err != nil {
		return fmt.Errorf("failed to insert vulnerability: %w", err)
	}

	// Invalidate cache
	vr.invalidateCache(vuln.ID)

	vr.logger.Info("Vulnerability created successfully", "id", vuln.ID, "hash", vuln.VulnerabilityHash)
	return nil
}

// GetByID retrieves a vulnerability by its ID
func (vr *VulnerabilityRepository) GetByID(ctx context.Context, id string) (*UnifiedVulnerability, error) {
	// Check cache first
	if vr.config.EnableCaching {
		if cached, found := vr.cache.Get(fmt.Sprintf("vuln:%s", id)); found {
			if vuln, ok := cached.(*UnifiedVulnerability); ok {
				return vuln, nil
			}
		}
	}

	// Query database
	query := `
		SELECT id, vulnerability_hash, canonical_id, scanner_type, scanner_id, scan_id, 
			original_id, title, description, severity, cvss2_score, cvss3_score, cvss31_score,
			cvss2_vector, cvss3_vector, cvss31_vector, cve, cwe, owasp, vulnerability_type,
			category, family, asset_id, asset_type, asset_identifier, asset_cpe,
			location, network_context, web_context, container_context, cloud_context, code_context,
			risk_score, business_impact, exploitable, exploit_available, patch_available, workaround_available,
			solution, workaround, references, vendor_advisory, detection_time, first_seen, last_seen,
			validation_status, false_positive, confidence, data_quality, source_metadata, processing_metadata,
			threat_intelligence, compliance_mapping, business_context, related_findings, parent_finding,
			child_findings, duplicate_of, duplicates, status, assigned_to, priority, target_date,
			resolution_date, resolution_notes, tenant_id, created_at, updated_at, created_by, updated_by,
			version, tags, custom_fields
		FROM vulnerabilities WHERE id = $1`

	row := vr.db.QueryRowContext(ctx, query, id)

	vuln := &UnifiedVulnerability{}
	var locationJSON, networkContextJSON, webContextJSON, containerContextJSON, cloudContextJSON, codeContextJSON sql.NullString
	var dataQualityJSON, sourceMetadataJSON, processingMetadataJSON, threatIntelligenceJSON sql.NullString
	var complianceMappingJSON, businessContextJSON, tagsJSON, customFieldsJSON sql.NullString

	err := row.Scan(
		&vuln.ID, &vuln.VulnerabilityHash, &vuln.CanonicalID, &vuln.ScannerType, &vuln.ScannerID, &vuln.ScanID,
		&vuln.OriginalID, &vuln.Title, &vuln.Description, &vuln.Severity, &vuln.CVSS2Score, &vuln.CVSS3Score, &vuln.CVSS31Score,
		&vuln.CVSS2Vector, &vuln.CVSS3Vector, &vuln.CVSS31Vector, &vuln.CVE, &vuln.CWE, &vuln.OWASP, &vuln.VulnerabilityType,
		&vuln.Category, &vuln.Family, &vuln.AssetID, &vuln.AssetType, &vuln.AssetIdentifier, &vuln.AssetCPE,
		&locationJSON, &networkContextJSON, &webContextJSON, &containerContextJSON, &cloudContextJSON, &codeContextJSON,
		&vuln.RiskScore, &vuln.BusinessImpact, &vuln.Exploitable, &vuln.ExploitAvailable, &vuln.PatchAvailable, &vuln.WorkaroundAvailable,
		&vuln.Solution, &vuln.Workaround, &vuln.References, &vuln.VendorAdvisory, &vuln.DetectionTime, &vuln.FirstSeen, &vuln.LastSeen,
		&vuln.ValidationStatus, &vuln.FalsePositive, &vuln.Confidence, &dataQualityJSON, &sourceMetadataJSON, &processingMetadataJSON,
		&threatIntelligenceJSON, &complianceMappingJSON, &businessContextJSON, &vuln.RelatedFindings, &vuln.ParentFinding,
		&vuln.ChildFindings, &vuln.DuplicateOf, &vuln.Duplicates, &vuln.Status, &vuln.AssignedTo, &vuln.Priority, &vuln.TargetDate,
		&vuln.ResolutionDate, &vuln.ResolutionNotes, &vuln.TenantID, &vuln.CreatedAt, &vuln.UpdatedAt, &vuln.CreatedBy, &vuln.UpdatedBy,
		&vuln.Version, &tagsJSON, &customFieldsJSON)

	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("vulnerability not found: %s", id)
	}
	if err != nil {
		return nil, fmt.Errorf("failed to query vulnerability: %w", err)
	}

	// Unmarshal JSON fields
	vr.unmarshalJSON(locationJSON.String, &vuln.Location)
	vr.unmarshalJSON(networkContextJSON.String, &vuln.NetworkContext)
	vr.unmarshalJSON(webContextJSON.String, &vuln.WebContext)
	vr.unmarshalJSON(containerContextJSON.String, &vuln.ContainerContext)
	vr.unmarshalJSON(cloudContextJSON.String, &vuln.CloudContext)
	vr.unmarshalJSON(codeContextJSON.String, &vuln.CodeContext)
	vr.unmarshalJSON(dataQualityJSON.String, &vuln.DataQuality)
	vr.unmarshalJSON(sourceMetadataJSON.String, &vuln.SourceMetadata)
	vr.unmarshalJSON(processingMetadataJSON.String, &vuln.ProcessingMetadata)
	vr.unmarshalJSON(threatIntelligenceJSON.String, &vuln.ThreatIntelligence)
	vr.unmarshalJSON(complianceMappingJSON.String, &vuln.ComplianceMapping)
	vr.unmarshalJSON(businessContextJSON.String, &vuln.BusinessContext)
	vr.unmarshalJSON(tagsJSON.String, &vuln.Tags)
	vr.unmarshalJSON(customFieldsJSON.String, &vuln.CustomFields)

	// Cache the result
	if vr.config.EnableCaching {
		vr.cache.Set(fmt.Sprintf("vuln:%s", id), vuln, vr.config.CacheExpiration)
	}

	return vuln, nil
}

// Private helper methods

func (vr *VulnerabilityRepository) generateVulnerabilityHash(vuln *UnifiedVulnerability) string {
	// Create a deterministic hash based on key vulnerability attributes
	hashData := fmt.Sprintf("%s|%s|%s|%s|%s|%s|%s",
		vuln.ScannerType,
		vuln.AssetID,
		vuln.Title,
		vuln.Description,
		vuln.Severity,
		strings.Join(vuln.CVE, ","),
		strings.Join(vuln.CWE, ","))

	hash := sha256.Sum256([]byte(hashData))
	return hex.EncodeToString(hash[:])
}

func (vr *VulnerabilityRepository) validateVulnerability(vuln *UnifiedVulnerability) error {
	if vuln.Title == "" {
		return fmt.Errorf("title is required")
	}

	if vuln.ScannerType == "" {
		return fmt.Errorf("scanner type is required")
	}

	if vuln.Severity == "" {
		return fmt.Errorf("severity is required")
	}

	if vuln.AssetID == "" {
		return fmt.Errorf("asset ID is required")
	}

	if vuln.TenantID == "" {
		return fmt.Errorf("tenant ID is required")
	}

	return nil
}

func (vr *VulnerabilityRepository) marshalJSON(data interface{}) string {
	if data == nil {
		return ""
	}

	jsonData, err := json.Marshal(data)
	if err != nil {
		vr.logger.Warn("Failed to marshal JSON data", "error", err)
		return ""
	}

	return string(jsonData)
}

func (vr *VulnerabilityRepository) unmarshalJSON(jsonStr string, target interface{}) {
	if jsonStr == "" {
		return
	}

	if err := json.Unmarshal([]byte(jsonStr), target); err != nil {
		vr.logger.Warn("Failed to unmarshal JSON data", "error", err)
	}
}

func (vr *VulnerabilityRepository) invalidateCache(vulnID string) {
	if vr.config.EnableCaching {
		vr.cache.Delete(fmt.Sprintf("vuln:%s", vulnID))
	}
}

func (vr *VulnerabilityRepository) createSchema(ctx context.Context) error {
	// TODO: Implement database schema creation
	vr.logger.Info("Creating database schema for vulnerabilities")
	return nil
}

func (vr *VulnerabilityRepository) setupPartitioning(ctx context.Context) error {
	// TODO: Implement table partitioning setup
	vr.logger.Info("Setting up table partitioning")
	return nil
}

func (im *IndexManager) createIndexes(ctx context.Context) error {
	// TODO: Implement index creation for optimal query performance
	im.logger.Info("Creating database indexes")
	return nil
}
