// correlation.go - Production-grade asset correlation engine for iSECTECH
// Maps vulnerabilities to assets using standardized identifiers (CPE, OVAL)

package data

import (
	"context"
	"fmt"
	"log/slog"
	"math"
	"sort"
	"strings"
	"sync"
	"time"
)

// AssetCorrelationEngine maps vulnerabilities to assets using standardized identifiers
type AssetCorrelationEngine struct {
	config          CorrelationEngineConfig
	logger          *slog.Logger
	cpeRepository   CPERepository
	ovalRepository  OVALRepository
	assetRepository AssetRepositoryInterface
	cache           CorrelationCache
	mappingRules    []MappingRule
	statistics      CorrelationStatistics
	mutex           sync.RWMutex
}

// CorrelationEngineConfig contains configuration for asset correlation
type CorrelationEngineConfig struct {
	// Data source settings
	CPEDictionaryURL  string `json:"cpe_dictionary_url"`
	OVALRepositoryURL string `json:"oval_repository_url"`
	NVDFeedURL        string `json:"nvd_feed_url"`

	// Update intervals
	CPEUpdateInterval  time.Duration `json:"cpe_update_interval"`
	OVALUpdateInterval time.Duration `json:"oval_update_interval"`
	NVDUpdateInterval  time.Duration `json:"nvd_update_interval"`

	// Processing settings
	MaxConcurrentJobs     int           `json:"max_concurrent_jobs"`
	CorrelationTimeout    time.Duration `json:"correlation_timeout"`
	EnableAsyncProcessing bool          `json:"enable_async_processing"`
	BatchSize             int           `json:"batch_size"`

	// Matching settings
	ExactMatchWeight      float64 `json:"exact_match_weight"`
	PartialMatchWeight    float64 `json:"partial_match_weight"`
	FuzzyMatchWeight      float64 `json:"fuzzy_match_weight"`
	VersionMatchTolerance int     `json:"version_match_tolerance"`

	// Quality settings
	MinConfidenceThreshold float64 `json:"min_confidence_threshold"`
	RequireVendorMatch     bool    `json:"require_vendor_match"`
	RequireProductMatch    bool    `json:"require_product_match"`
	AllowVersionWildcards  bool    `json:"allow_version_wildcards"`

	// Performance settings
	EnableCaching   bool          `json:"enable_caching"`
	CacheExpiration time.Duration `json:"cache_expiration"`
	CacheMaxSize    int           `json:"cache_max_size"`

	// iSECTECH specific settings
	TenantIsolation    bool     `json:"tenant_isolation"`
	CustomMappingRules []string `json:"custom_mapping_rules"`
	EnableMLMatching   bool     `json:"enable_ml_matching"`
	AssetEnrichment    bool     `json:"asset_enrichment"`
}

// CorrelationStatistics tracks correlation performance and quality
type CorrelationStatistics struct {
	TotalCorrelations     int64                     `json:"total_correlations"`
	SuccessfulMatches     int64                     `json:"successful_matches"`
	ExactMatches          int64                     `json:"exact_matches"`
	PartialMatches        int64                     `json:"partial_matches"`
	FuzzyMatches          int64                     `json:"fuzzy_matches"`
	NoMatches             int64                     `json:"no_matches"`
	AverageProcessingTime time.Duration             `json:"average_processing_time"`
	AverageConfidence     float64                   `json:"average_confidence"`
	MatchTypeDistribution map[string]int64          `json:"match_type_distribution"`
	VendorDistribution    map[string]int64          `json:"vendor_distribution"`
	ProductDistribution   map[string]int64          `json:"product_distribution"`
	QualityMetrics        CorrelationQualityMetrics `json:"quality_metrics"`
	LastProcessed         time.Time                 `json:"last_processed"`
}

type CorrelationQualityMetrics struct {
	Precision              float64          `json:"precision"`
	Recall                 float64          `json:"recall"`
	F1Score                float64          `json:"f1_score"`
	FalsePositiveRate      float64          `json:"false_positive_rate"`
	FalseNegativeRate      float64          `json:"false_negative_rate"`
	ConfidenceDistribution map[string]int64 `json:"confidence_distribution"`
}

// CorrelationJob represents a single asset correlation task
type CorrelationJob struct {
	ID             string               `json:"id"`
	Vulnerability  UnifiedVulnerability `json:"vulnerability"`
	Context        CorrelationContext   `json:"context"`
	Options        CorrelationOptions   `json:"options"`
	CreatedAt      time.Time            `json:"created_at"`
	ProcessedAt    *time.Time           `json:"processed_at,omitempty"`
	Result         *CorrelationResult   `json:"result,omitempty"`
	Status         string               `json:"status"`
	ProcessingTime time.Duration        `json:"processing_time"`
	Errors         []string             `json:"errors"`
}

type CorrelationContext struct {
	TenantID           string                 `json:"tenant_id"`
	ScanContext        map[string]interface{} `json:"scan_context"`
	AssetContext       map[string]interface{} `json:"asset_context"`
	EnvironmentContext map[string]interface{} `json:"environment_context"`
	CustomContext      map[string]interface{} `json:"custom_context"`
}

type CorrelationOptions struct {
	RequireExactMatch   bool    `json:"require_exact_match"`
	AllowPartialMatches bool    `json:"allow_partial_matches"`
	EnableFuzzyMatching bool    `json:"enable_fuzzy_matching"`
	ConfidenceThreshold float64 `json:"confidence_threshold"`
	MaxCandidates       int     `json:"max_candidates"`
	IncludeMetadata     bool    `json:"include_metadata"`
	ValidateMatches     bool    `json:"validate_matches"`
}

type CorrelationResult struct {
	VulnerabilityID    string                        `json:"vulnerability_id"`
	AssetMatches       []AssetMatch                  `json:"asset_matches"`
	CPEMatches         []CPEMatch                    `json:"cpe_matches"`
	OVALMatches        []OVALMatch                   `json:"oval_matches"`
	OverallConfidence  float64                       `json:"overall_confidence"`
	MatchQuality       MatchQualityAssessment        `json:"match_quality"`
	ProcessingMetadata CorrelationProcessingMetadata `json:"processing_metadata"`
	Recommendations    []string                      `json:"recommendations"`
	ValidationResults  []ValidationResult            `json:"validation_results"`
}

type AssetMatch struct {
	AssetID       string           `json:"asset_id"`
	AssetType     string           `json:"asset_type"`
	MatchType     string           `json:"match_type"` // exact, partial, fuzzy
	Confidence    float64          `json:"confidence"`
	MatchCriteria []MatchCriterion `json:"match_criteria"`
	AssetMetadata AssetMetadata    `json:"asset_metadata"`
	Evidence      []MatchEvidence  `json:"evidence"`
	Validated     bool             `json:"validated"`
}

type CPEMatch struct {
	CPE                   string                 `json:"cpe"`
	CPEVersion            string                 `json:"cpe_version"` // 2.2, 2.3
	ParsedCPE             ParsedCPE              `json:"parsed_cpe"`
	MatchType             string                 `json:"match_type"`
	Confidence            float64                `json:"confidence"`
	MatchComponents       []CPEComponent         `json:"match_components"`
	VulnerabilityMappings []VulnerabilityMapping `json:"vulnerability_mappings"`
	ValidationStatus      string                 `json:"validation_status"`
}

type OVALMatch struct {
	DefinitionID       string           `json:"definition_id"`
	OVALClass          string           `json:"oval_class"`
	Title              string           `json:"title"`
	Description        string           `json:"description"`
	Platforms          []string         `json:"platforms"`
	CriteriaResults    []CriteriaResult `json:"criteria_results"`
	ApplicabilityScore float64          `json:"applicability_score"`
	TestResults        []TestResult     `json:"test_results"`
	Metadata           OVALMetadata     `json:"metadata"`
}

type AssetMetadata struct {
	Name        string            `json:"name"`
	Type        string            `json:"type"`
	Vendor      string            `json:"vendor"`
	Product     string            `json:"product"`
	Version     string            `json:"version"`
	Platform    string            `json:"platform"`
	Environment string            `json:"environment"`
	Tags        map[string]string `json:"tags"`
	LastUpdated time.Time         `json:"last_updated"`
}

type MatchEvidence struct {
	Type       string    `json:"type"`
	Source     string    `json:"source"`
	Value      string    `json:"value"`
	Confidence float64   `json:"confidence"`
	Timestamp  time.Time `json:"timestamp"`
}

type ParsedCPE struct {
	Part            string `json:"part"`
	Vendor          string `json:"vendor"`
	Product         string `json:"product"`
	Version         string `json:"version"`
	Update          string `json:"update"`
	Edition         string `json:"edition"`
	Language        string `json:"language"`
	SoftwareEdition string `json:"software_edition"`
	TargetSoftware  string `json:"target_software"`
	TargetHardware  string `json:"target_hardware"`
	Other           string `json:"other"`
}

type CPEComponent struct {
	Name       string  `json:"name"`
	Original   string  `json:"original"`
	Matched    string  `json:"matched"`
	MatchType  string  `json:"match_type"`
	Confidence float64 `json:"confidence"`
}

type VulnerabilityMapping struct {
	CVE          string    `json:"cve"`
	CVSS         string    `json:"cvss"`
	Severity     string    `json:"severity"`
	Description  string    `json:"description"`
	References   []string  `json:"references"`
	LastModified time.Time `json:"last_modified"`
}

type CriteriaResult struct {
	CriterionID string           `json:"criterion_id"`
	Result      bool             `json:"result"`
	Comment     string           `json:"comment"`
	SubCriteria []CriteriaResult `json:"sub_criteria,omitempty"`
}

type TestResult struct {
	TestID   string   `json:"test_id"`
	TestType string   `json:"test_type"`
	Result   bool     `json:"result"`
	Details  string   `json:"details"`
	Evidence []string `json:"evidence"`
}

type OVALMetadata struct {
	Affected     []AffectedProduct `json:"affected"`
	References   []Reference       `json:"references"`
	Severity     string            `json:"severity"`
	CVSSScore    float64           `json:"cvss_score"`
	LastModified time.Time         `json:"last_modified"`
}

type AffectedProduct struct {
	Platform string `json:"platform"`
	Product  string `json:"product"`
	Version  string `json:"version"`
}

type Reference struct {
	Type        string `json:"type"`
	URL         string `json:"url"`
	Description string `json:"description"`
}

type MatchQualityAssessment struct {
	OverallScore           float64        `json:"overall_score"`
	CompletenessScore      float64        `json:"completeness_score"`
	AccuracyScore          float64        `json:"accuracy_score"`
	ReliabilityScore       float64        `json:"reliability_score"`
	QualityIssues          []QualityIssue `json:"quality_issues"`
	ImprovementSuggestions []string       `json:"improvement_suggestions"`
}

type CorrelationProcessingMetadata struct {
	ProcessingVersion   string        `json:"processing_version"`
	AlgorithmsUsed      []string      `json:"algorithms_used"`
	DataSources         []string      `json:"data_sources"`
	ProcessingLatency   time.Duration `json:"processing_latency"`
	CacheHit            bool          `json:"cache_hit"`
	ValidationPerformed bool          `json:"validation_performed"`
}

// MappingRule defines custom correlation rules
type MappingRule struct {
	ID          string          `json:"id"`
	Name        string          `json:"name"`
	Description string          `json:"description"`
	Conditions  []RuleCondition `json:"conditions"`
	Actions     []RuleAction    `json:"actions"`
	Priority    int             `json:"priority"`
	Enabled     bool            `json:"enabled"`
	CreatedAt   time.Time       `json:"created_at"`
	UpdatedAt   time.Time       `json:"updated_at"`
}

type RuleAction struct {
	Type               string                 `json:"type"` // map, enrich, validate, reject
	Parameters         map[string]interface{} `json:"parameters"`
	ConfidenceModifier float64                `json:"confidence_modifier"`
}

// Repository interfaces

type CPERepository interface {
	GetCPEByID(ctx context.Context, cpeID string) (*CPEItem, error)
	SearchCPE(ctx context.Context, criteria CPESearchCriteria) ([]CPEItem, error)
	GetCPEVulnerabilities(ctx context.Context, cpe string) ([]VulnerabilityMapping, error)
	UpdateCPEDictionary(ctx context.Context) error
	GetStatistics() CPERepositoryStats
}

type OVALRepository interface {
	GetDefinition(ctx context.Context, definitionID string) (*OVALDefinition, error)
	SearchDefinitions(ctx context.Context, criteria OVALSearchCriteria) ([]OVALDefinition, error)
	EvaluateDefinition(ctx context.Context, definitionID string, asset *AssetInfo) (*OVALMatch, error)
	UpdateRepository(ctx context.Context) error
	GetStatistics() OVALRepositoryStats
}

type AssetRepositoryInterface interface {
	GetAssetByID(ctx context.Context, assetID string) (*AssetInfo, error)
	SearchAssets(ctx context.Context, criteria AssetSearchCriteria) ([]AssetInfo, error)
	GetAssetCPE(ctx context.Context, assetID string) ([]string, error)
	UpdateAssetCPE(ctx context.Context, assetID string, cpe []string) error
	GetAssetVulnerabilities(ctx context.Context, assetID string) ([]string, error)
}

type CorrelationCache interface {
	Get(ctx context.Context, key string) (interface{}, bool)
	Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error
	Delete(ctx context.Context, key string) error
	Clear(ctx context.Context) error
	GetStats() CacheStats
}

// Data structures

type CPEItem struct {
	CPEID        string      `json:"cpe_id"`
	CPE22        string      `json:"cpe22"`
	CPE23        string      `json:"cpe23"`
	Title        string      `json:"title"`
	References   []Reference `json:"references"`
	ParsedCPE    ParsedCPE   `json:"parsed_cpe"`
	LastModified time.Time   `json:"last_modified"`
	Deprecated   bool        `json:"deprecated"`
	ReplacedBy   []string    `json:"replaced_by"`
}

type CPESearchCriteria struct {
	Vendor     string `json:"vendor,omitempty"`
	Product    string `json:"product,omitempty"`
	Version    string `json:"version,omitempty"`
	Platform   string `json:"platform,omitempty"`
	SearchText string `json:"search_text,omitempty"`
	Limit      int    `json:"limit"`
	Offset     int    `json:"offset"`
}

type OVALDefinition struct {
	ID           string       `json:"id"`
	Class        string       `json:"class"`
	Title        string       `json:"title"`
	Description  string       `json:"description"`
	Platforms    []string     `json:"platforms"`
	References   []Reference  `json:"references"`
	Criteria     Criteria     `json:"criteria"`
	Tests        []Test       `json:"tests"`
	Objects      []Object     `json:"objects"`
	States       []State      `json:"states"`
	Variables    []Variable   `json:"variables"`
	Metadata     OVALMetadata `json:"metadata"`
	LastModified time.Time    `json:"last_modified"`
}

type Criteria struct {
	Operator  string      `json:"operator"` // AND, OR
	Comment   string      `json:"comment"`
	Criteria  []Criteria  `json:"criteria,omitempty"`
	Criterion []Criterion `json:"criterion,omitempty"`
}

type Criterion struct {
	TestRef string `json:"test_ref"`
	Comment string `json:"comment"`
	Negate  bool   `json:"negate"`
}

type Test struct {
	ID             string `json:"id"`
	Type           string `json:"type"`
	Comment        string `json:"comment"`
	ObjectRef      string `json:"object_ref"`
	StateRef       string `json:"state_ref"`
	CheckExistence string `json:"check_existence"`
	Check          string `json:"check"`
}

type Object struct {
	ID         string                 `json:"id"`
	Type       string                 `json:"type"`
	Comment    string                 `json:"comment"`
	Properties map[string]interface{} `json:"properties"`
}

type State struct {
	ID         string                 `json:"id"`
	Type       string                 `json:"type"`
	Comment    string                 `json:"comment"`
	Properties map[string]interface{} `json:"properties"`
}

type Variable struct {
	ID      string      `json:"id"`
	Type    string      `json:"type"`
	Comment string      `json:"comment"`
	Value   interface{} `json:"value"`
}

type OVALSearchCriteria struct {
	Platform   string `json:"platform,omitempty"`
	Class      string `json:"class,omitempty"`
	SearchText string `json:"search_text,omitempty"`
	CVE        string `json:"cve,omitempty"`
	Limit      int    `json:"limit"`
	Offset     int    `json:"offset"`
}

type AssetSearchCriteria struct {
	Type        string            `json:"type,omitempty"`
	Vendor      string            `json:"vendor,omitempty"`
	Product     string            `json:"product,omitempty"`
	Version     string            `json:"version,omitempty"`
	Environment string            `json:"environment,omitempty"`
	Tags        map[string]string `json:"tags,omitempty"`
	Limit       int               `json:"limit"`
	Offset      int               `json:"offset"`
}

type CPERepositoryStats struct {
	TotalCPEs       int64         `json:"total_cpes"`
	LastUpdate      time.Time     `json:"last_update"`
	UpdateFrequency time.Duration `json:"update_frequency"`
	VendorCount     int           `json:"vendor_count"`
	ProductCount    int           `json:"product_count"`
}

type OVALRepositoryStats struct {
	TotalDefinitions  int64          `json:"total_definitions"`
	LastUpdate        time.Time      `json:"last_update"`
	UpdateFrequency   time.Duration  `json:"update_frequency"`
	PlatformCount     int            `json:"platform_count"`
	ClassDistribution map[string]int `json:"class_distribution"`
}

// NewAssetCorrelationEngine creates a new production-grade asset correlation engine
func NewAssetCorrelationEngine(
	config CorrelationEngineConfig,
	cpeRepo CPERepository,
	ovalRepo OVALRepository,
	assetRepo AssetRepositoryInterface,
	cache CorrelationCache,
	logger *slog.Logger,
) *AssetCorrelationEngine {

	engine := &AssetCorrelationEngine{
		config:          config,
		logger:          logger.With("component", "asset_correlation_engine"),
		cpeRepository:   cpeRepo,
		ovalRepository:  ovalRepo,
		assetRepository: assetRepo,
		cache:           cache,
		mappingRules:    make([]MappingRule, 0),
		statistics: CorrelationStatistics{
			MatchTypeDistribution: make(map[string]int64),
			VendorDistribution:    make(map[string]int64),
			ProductDistribution:   make(map[string]int64),
			QualityMetrics: CorrelationQualityMetrics{
				ConfidenceDistribution: make(map[string]int64),
			},
		},
	}

	// Load custom mapping rules
	engine.loadMappingRules()

	return engine
}

// CorrelateVulnerability correlates a vulnerability with assets using CPE/OVAL
func (ace *AssetCorrelationEngine) CorrelateVulnerability(ctx context.Context, vuln *UnifiedVulnerability, options CorrelationOptions) (*CorrelationResult, error) {
	startTime := time.Now()

	ace.logger.Info("Starting vulnerability correlation",
		"vuln_id", vuln.ID,
		"scanner_type", vuln.ScannerType)

	// Check cache first
	cacheKey := ace.generateCacheKey(vuln, options)
	if ace.config.EnableCaching {
		if cached, found := ace.cache.Get(ctx, cacheKey); found {
			if result, ok := cached.(*CorrelationResult); ok {
				ace.logger.Debug("Returning cached correlation result")
				return result, nil
			}
		}
	}

	// Create result structure
	result := &CorrelationResult{
		VulnerabilityID:   vuln.ID,
		AssetMatches:      make([]AssetMatch, 0),
		CPEMatches:        make([]CPEMatch, 0),
		OVALMatches:       make([]OVALMatch, 0),
		Recommendations:   make([]string, 0),
		ValidationResults: make([]ValidationResult, 0),
	}

	// Step 1: Asset-based correlation
	assetMatches, err := ace.correlateWithAssets(ctx, vuln, options)
	if err != nil {
		ace.logger.Warn("Asset correlation failed", "error", err)
	} else {
		result.AssetMatches = assetMatches
	}

	// Step 2: CPE-based correlation
	cpeMatches, err := ace.correlateWithCPE(ctx, vuln, options)
	if err != nil {
		ace.logger.Warn("CPE correlation failed", "error", err)
	} else {
		result.CPEMatches = cpeMatches
	}

	// Step 3: OVAL-based correlation
	ovalMatches, err := ace.correlateWithOVAL(ctx, vuln, options)
	if err != nil {
		ace.logger.Warn("OVAL correlation failed", "error", err)
	} else {
		result.OVALMatches = ovalMatches
	}

	// Step 4: Calculate overall confidence
	result.OverallConfidence = ace.calculateOverallConfidence(result)

	// Step 5: Assess match quality
	result.MatchQuality = ace.assessMatchQuality(result)

	// Step 6: Generate recommendations
	result.Recommendations = ace.generateRecommendations(result)

	// Step 7: Validate results if requested
	if options.ValidateMatches {
		result.ValidationResults = ace.validateResults(ctx, result)
	}

	// Update processing metadata
	processingTime := time.Since(startTime)
	result.ProcessingMetadata = CorrelationProcessingMetadata{
		ProcessingVersion:   "1.0",
		AlgorithmsUsed:      []string{"cpe_matching", "oval_evaluation", "asset_correlation"},
		DataSources:         []string{"cpe_dictionary", "oval_repository", "asset_inventory"},
		ProcessingLatency:   processingTime,
		CacheHit:            false,
		ValidationPerformed: options.ValidateMatches,
	}

	// Update statistics
	ace.updateStatistics(result, processingTime)

	// Cache result
	if ace.config.EnableCaching {
		ace.cache.Set(ctx, cacheKey, result, ace.config.CacheExpiration)
	}

	ace.logger.Info("Vulnerability correlation completed",
		"vuln_id", vuln.ID,
		"asset_matches", len(result.AssetMatches),
		"cpe_matches", len(result.CPEMatches),
		"oval_matches", len(result.OVALMatches),
		"confidence", result.OverallConfidence,
		"processing_time", processingTime)

	return result, nil
}

// BatchCorrelateVulnerabilities correlates multiple vulnerabilities in batch
func (ace *AssetCorrelationEngine) BatchCorrelateVulnerabilities(ctx context.Context, vulns []UnifiedVulnerability, options CorrelationOptions) ([]CorrelationResult, error) {
	results := make([]CorrelationResult, len(vulns))

	if ace.config.EnableAsyncProcessing {
		return ace.processVulnerabilitiesAsync(ctx, vulns, options)
	}

	// Process sequentially
	for i, vuln := range vulns {
		result, err := ace.CorrelateVulnerability(ctx, &vuln, options)
		if err != nil {
			ace.logger.Error("Failed to correlate vulnerability", "vuln_id", vuln.ID, "error", err)
			continue
		}
		results[i] = *result
	}

	return results, nil
}

// Private helper methods

func (ace *AssetCorrelationEngine) correlateWithAssets(ctx context.Context, vuln *UnifiedVulnerability, options CorrelationOptions) ([]AssetMatch, error) {
	matches := make([]AssetMatch, 0)

	// If asset ID is already present, validate and enrich
	if vuln.AssetID != "" {
		asset, err := ace.assetRepository.GetAssetByID(ctx, vuln.AssetID)
		if err != nil {
			return nil, fmt.Errorf("failed to get asset: %w", err)
		}

		match := AssetMatch{
			AssetID:    asset.ID,
			AssetType:  asset.Type,
			MatchType:  "exact",
			Confidence: 1.0,
			Validated:  true,
			AssetMetadata: AssetMetadata{
				Name:        asset.Name,
				Type:        asset.Type,
				Vendor:      extractVendor(asset.Tags),
				Product:     extractProduct(asset.Tags),
				Version:     extractVersion(asset.Tags),
				Environment: asset.Environment,
				Tags:        asset.Tags,
				LastUpdated: time.Now(),
			},
		}

		matches = append(matches, match)
	}

	// Search for additional assets based on vulnerability context
	additionalMatches, err := ace.searchAssetsByContext(ctx, vuln, options)
	if err != nil {
		ace.logger.Warn("Additional asset search failed", "error", err)
	} else {
		matches = append(matches, additionalMatches...)
	}

	return matches, nil
}

func (ace *AssetCorrelationEngine) correlateWithCPE(ctx context.Context, vuln *UnifiedVulnerability, options CorrelationOptions) ([]CPEMatch, error) {
	matches := make([]CPEMatch, 0)

	// Search CPE repository based on vulnerability information
	searchCriteria := ace.buildCPESearchCriteria(vuln)

	cpeItems, err := ace.cpeRepository.SearchCPE(ctx, searchCriteria)
	if err != nil {
		return nil, fmt.Errorf("CPE search failed: %w", err)
	}

	for _, cpeItem := range cpeItems {
		// Calculate match confidence
		confidence := ace.calculateCPEMatchConfidence(vuln, &cpeItem)

		if confidence < options.ConfidenceThreshold {
			continue
		}

		// Classify match type
		matchType := ace.classifyCPEMatchType(confidence)

		// Get vulnerability mappings for this CPE
		vulnMappings, err := ace.cpeRepository.GetCPEVulnerabilities(ctx, cpeItem.CPE23)
		if err != nil {
			ace.logger.Warn("Failed to get CPE vulnerabilities", "cpe", cpeItem.CPE23, "error", err)
			vulnMappings = make([]VulnerabilityMapping, 0)
		}

		match := CPEMatch{
			CPE:                   cpeItem.CPE23,
			CPEVersion:            "2.3",
			ParsedCPE:             cpeItem.ParsedCPE,
			MatchType:             matchType,
			Confidence:            confidence,
			MatchComponents:       ace.analyzeCPEComponents(vuln, &cpeItem),
			VulnerabilityMappings: vulnMappings,
			ValidationStatus:      "pending",
		}

		matches = append(matches, match)
	}

	// Sort by confidence
	sort.Slice(matches, func(i, j int) bool {
		return matches[i].Confidence > matches[j].Confidence
	})

	// Limit results
	if len(matches) > options.MaxCandidates {
		matches = matches[:options.MaxCandidates]
	}

	return matches, nil
}

func (ace *AssetCorrelationEngine) correlateWithOVAL(ctx context.Context, vuln *UnifiedVulnerability, options CorrelationOptions) ([]OVALMatch, error) {
	matches := make([]OVALMatch, 0)

	// Search OVAL repository for relevant definitions
	searchCriteria := ace.buildOVALSearchCriteria(vuln)

	definitions, err := ace.ovalRepository.SearchDefinitions(ctx, searchCriteria)
	if err != nil {
		return nil, fmt.Errorf("OVAL search failed: %w", err)
	}

	// Get asset information for evaluation
	var asset *AssetInfo
	if vuln.AssetID != "" {
		asset, err = ace.assetRepository.GetAssetByID(ctx, vuln.AssetID)
		if err != nil {
			ace.logger.Warn("Failed to get asset for OVAL evaluation", "asset_id", vuln.AssetID, "error", err)
		}
	}

	for _, definition := range definitions {
		// Evaluate OVAL definition against asset
		match, err := ace.ovalRepository.EvaluateDefinition(ctx, definition.ID, asset)
		if err != nil {
			ace.logger.Warn("OVAL evaluation failed", "definition_id", definition.ID, "error", err)
			continue
		}

		if match.ApplicabilityScore >= options.ConfidenceThreshold {
			matches = append(matches, *match)
		}
	}

	// Sort by applicability score
	sort.Slice(matches, func(i, j int) bool {
		return matches[i].ApplicabilityScore > matches[j].ApplicabilityScore
	})

	return matches, nil
}

func (ace *AssetCorrelationEngine) buildCPESearchCriteria(vuln *UnifiedVulnerability) CPESearchCriteria {
	criteria := CPESearchCriteria{
		Limit: ace.config.BatchSize,
	}

	// Extract vendor/product from vulnerability context
	switch vuln.ScannerType {
	case "network":
		if vuln.NetworkContext != nil {
			criteria.Product = extractProductFromService(vuln.NetworkContext.Service)
		}
	case "web":
		if vuln.WebContext != nil {
			criteria.Product = extractProductFromTechnology(vuln.WebContext.Technology)
		}
	case "container":
		if vuln.ContainerContext != nil {
			parts := strings.Split(vuln.ContainerContext.ImageName, "/")
			if len(parts) > 0 {
				criteria.Product = parts[len(parts)-1]
			}
		}
	case "cloud":
		if vuln.CloudContext != nil {
			criteria.Vendor = vuln.CloudContext.Provider
			criteria.Product = vuln.CloudContext.ServiceName
		}
	case "code":
		if vuln.CodeContext != nil {
			criteria.Product = extractProductFromLanguage(vuln.CodeContext.Language)
		}
	}

	return criteria
}

func (ace *AssetCorrelationEngine) buildOVALSearchCriteria(vuln *UnifiedVulnerability) OVALSearchCriteria {
	criteria := OVALSearchCriteria{
		Limit: ace.config.BatchSize,
	}

	// Use CVE if available
	if len(vuln.CVE) > 0 {
		criteria.CVE = vuln.CVE[0]
	}

	// Determine platform from vulnerability context
	criteria.Platform = ace.determinePlatform(vuln)

	return criteria
}

func (ace *AssetCorrelationEngine) calculateCPEMatchConfidence(vuln *UnifiedVulnerability, cpeItem *CPEItem) float64 {
	confidence := 0.0

	// Exact vendor match
	vulnVendor := ace.extractVendorFromVulnerability(vuln)
	if vulnVendor != "" && strings.EqualFold(vulnVendor, cpeItem.ParsedCPE.Vendor) {
		confidence += ace.config.ExactMatchWeight
	}

	// Exact product match
	vulnProduct := ace.extractProductFromVulnerability(vuln)
	if vulnProduct != "" && strings.EqualFold(vulnProduct, cpeItem.ParsedCPE.Product) {
		confidence += ace.config.ExactMatchWeight
	}

	// Version matching
	vulnVersion := ace.extractVersionFromVulnerability(vuln)
	if vulnVersion != "" {
		versionScore := ace.calculateVersionSimilarity(vulnVersion, cpeItem.ParsedCPE.Version)
		confidence += versionScore * ace.config.PartialMatchWeight
	}

	return math.Min(1.0, confidence)
}

func (ace *AssetCorrelationEngine) classifyCPEMatchType(confidence float64) string {
	if confidence >= 0.9 {
		return "exact"
	} else if confidence >= 0.7 {
		return "partial"
	} else if confidence >= 0.5 {
		return "fuzzy"
	}
	return "weak"
}

func (ace *AssetCorrelationEngine) analyzeCPEComponents(vuln *UnifiedVulnerability, cpeItem *CPEItem) []CPEComponent {
	components := make([]CPEComponent, 0)

	// Analyze vendor component
	vulnVendor := ace.extractVendorFromVulnerability(vuln)
	if vulnVendor != "" {
		component := CPEComponent{
			Name:       "vendor",
			Original:   vulnVendor,
			Matched:    cpeItem.ParsedCPE.Vendor,
			MatchType:  ace.getComponentMatchType(vulnVendor, cpeItem.ParsedCPE.Vendor),
			Confidence: ace.calculateTextSimilarity(vulnVendor, cpeItem.ParsedCPE.Vendor),
		}
		components = append(components, component)
	}

	// Analyze product component
	vulnProduct := ace.extractProductFromVulnerability(vuln)
	if vulnProduct != "" {
		component := CPEComponent{
			Name:       "product",
			Original:   vulnProduct,
			Matched:    cpeItem.ParsedCPE.Product,
			MatchType:  ace.getComponentMatchType(vulnProduct, cpeItem.ParsedCPE.Product),
			Confidence: ace.calculateTextSimilarity(vulnProduct, cpeItem.ParsedCPE.Product),
		}
		components = append(components, component)
	}

	// Analyze version component
	vulnVersion := ace.extractVersionFromVulnerability(vuln)
	if vulnVersion != "" {
		component := CPEComponent{
			Name:       "version",
			Original:   vulnVersion,
			Matched:    cpeItem.ParsedCPE.Version,
			MatchType:  ace.getVersionMatchType(vulnVersion, cpeItem.ParsedCPE.Version),
			Confidence: ace.calculateVersionSimilarity(vulnVersion, cpeItem.ParsedCPE.Version),
		}
		components = append(components, component)
	}

	return components
}

func (ace *AssetCorrelationEngine) calculateOverallConfidence(result *CorrelationResult) float64 {
	totalWeight := 0.0
	weightedSum := 0.0

	// Asset matches weight
	if len(result.AssetMatches) > 0 {
		assetWeight := 0.5
		maxAssetConfidence := 0.0
		for _, match := range result.AssetMatches {
			if match.Confidence > maxAssetConfidence {
				maxAssetConfidence = match.Confidence
			}
		}
		weightedSum += maxAssetConfidence * assetWeight
		totalWeight += assetWeight
	}

	// CPE matches weight
	if len(result.CPEMatches) > 0 {
		cpeWeight := 0.3
		maxCPEConfidence := 0.0
		for _, match := range result.CPEMatches {
			if match.Confidence > maxCPEConfidence {
				maxCPEConfidence = match.Confidence
			}
		}
		weightedSum += maxCPEConfidence * cpeWeight
		totalWeight += cpeWeight
	}

	// OVAL matches weight
	if len(result.OVALMatches) > 0 {
		ovalWeight := 0.2
		maxOVALScore := 0.0
		for _, match := range result.OVALMatches {
			if match.ApplicabilityScore > maxOVALScore {
				maxOVALScore = match.ApplicabilityScore
			}
		}
		weightedSum += maxOVALScore * ovalWeight
		totalWeight += ovalWeight
	}

	if totalWeight == 0 {
		return 0.0
	}

	return weightedSum / totalWeight
}

func (ace *AssetCorrelationEngine) assessMatchQuality(result *CorrelationResult) MatchQualityAssessment {
	assessment := MatchQualityAssessment{
		QualityIssues:          make([]QualityIssue, 0),
		ImprovementSuggestions: make([]string, 0),
	}

	// Calculate completeness score
	assessment.CompletenessScore = ace.calculateCompletenessScore(result)

	// Calculate accuracy score
	assessment.AccuracyScore = ace.calculateAccuracyScore(result)

	// Calculate reliability score
	assessment.ReliabilityScore = ace.calculateReliabilityScore(result)

	// Calculate overall score
	assessment.OverallScore = (assessment.CompletenessScore + assessment.AccuracyScore + assessment.ReliabilityScore) / 3.0

	// Identify quality issues
	if assessment.CompletenessScore < 0.7 {
		assessment.QualityIssues = append(assessment.QualityIssues, QualityIssue{
			Type:     "completeness",
			Severity: "medium",
			Message:  "Incomplete correlation information",
		})
		assessment.ImprovementSuggestions = append(assessment.ImprovementSuggestions, "Consider enriching asset metadata")
	}

	if assessment.AccuracyScore < 0.8 {
		assessment.QualityIssues = append(assessment.QualityIssues, QualityIssue{
			Type:     "accuracy",
			Severity: "high",
			Message:  "Low confidence in correlation accuracy",
		})
		assessment.ImprovementSuggestions = append(assessment.ImprovementSuggestions, "Manual validation recommended")
	}

	return assessment
}

func (ace *AssetCorrelationEngine) generateRecommendations(result *CorrelationResult) []string {
	recommendations := make([]string, 0)

	// Recommend manual validation for low confidence results
	if result.OverallConfidence < 0.7 {
		recommendations = append(recommendations, "Manual validation recommended due to low confidence")
	}

	// Recommend asset enrichment if no asset matches
	if len(result.AssetMatches) == 0 {
		recommendations = append(recommendations, "Consider enriching asset inventory for better correlation")
	}

	// Recommend CPE assignment if no CPE matches
	if len(result.CPEMatches) == 0 {
		recommendations = append(recommendations, "Consider assigning CPE identifiers to assets")
	}

	return recommendations
}

func (ace *AssetCorrelationEngine) validateResults(ctx context.Context, result *CorrelationResult) []ValidationResult {
	validationResults := make([]ValidationResult, 0)

	// Validate asset matches
	for _, assetMatch := range result.AssetMatches {
		validation := ace.validateAssetMatch(ctx, &assetMatch)
		validationResults = append(validationResults, validation)
	}

	// Validate CPE matches
	for _, cpeMatch := range result.CPEMatches {
		validation := ace.validateCPEMatch(ctx, &cpeMatch)
		validationResults = append(validationResults, validation)
	}

	return validationResults
}

func (ace *AssetCorrelationEngine) validateAssetMatch(ctx context.Context, match *AssetMatch) ValidationResult {
	// TODO: Implement asset match validation
	return ValidationResult{
		IsValid: true,
		Score:   0.9,
	}
}

func (ace *AssetCorrelationEngine) validateCPEMatch(ctx context.Context, match *CPEMatch) ValidationResult {
	// TODO: Implement CPE match validation
	return ValidationResult{
		IsValid: true,
		Score:   0.85,
	}
}

// Helper methods for text processing and similarity calculation

func (ace *AssetCorrelationEngine) calculateTextSimilarity(text1, text2 string) float64 {
	// Simple implementation - could be enhanced with more sophisticated algorithms
	if strings.EqualFold(text1, text2) {
		return 1.0
	}

	if strings.Contains(strings.ToLower(text1), strings.ToLower(text2)) ||
		strings.Contains(strings.ToLower(text2), strings.ToLower(text1)) {
		return 0.7
	}

	return 0.0
}

func (ace *AssetCorrelationEngine) calculateVersionSimilarity(version1, version2 string) float64 {
	// Parse and compare semantic versions
	v1Parts := strings.Split(version1, ".")
	v2Parts := strings.Split(version2, ".")

	if len(v1Parts) == 0 || len(v2Parts) == 0 {
		return 0.0
	}

	// Exact match
	if version1 == version2 {
		return 1.0
	}

	// Major version match
	if len(v1Parts) > 0 && len(v2Parts) > 0 && v1Parts[0] == v2Parts[0] {
		return 0.6
	}

	return 0.0
}

func (ace *AssetCorrelationEngine) getComponentMatchType(original, matched string) string {
	if strings.EqualFold(original, matched) {
		return "exact"
	}

	if strings.Contains(strings.ToLower(original), strings.ToLower(matched)) ||
		strings.Contains(strings.ToLower(matched), strings.ToLower(original)) {
		return "partial"
	}

	return "fuzzy"
}

func (ace *AssetCorrelationEngine) getVersionMatchType(version1, version2 string) string {
	if version1 == version2 {
		return "exact"
	}

	v1Parts := strings.Split(version1, ".")
	v2Parts := strings.Split(version2, ".")

	if len(v1Parts) > 0 && len(v2Parts) > 0 && v1Parts[0] == v2Parts[0] {
		return "major_match"
	}

	return "different"
}

// Utility functions for extracting information from vulnerabilities

func (ace *AssetCorrelationEngine) extractVendorFromVulnerability(vuln *UnifiedVulnerability) string {
	// Extract vendor information based on scanner type and context
	switch vuln.ScannerType {
	case "container":
		if vuln.ContainerContext != nil && vuln.ContainerContext.Registry != "" {
			return extractVendorFromRegistry(vuln.ContainerContext.Registry)
		}
	case "cloud":
		if vuln.CloudContext != nil {
			return vuln.CloudContext.Provider
		}
	}

	return ""
}

func (ace *AssetCorrelationEngine) extractProductFromVulnerability(vuln *UnifiedVulnerability) string {
	// Extract product information based on scanner type and context
	switch vuln.ScannerType {
	case "network":
		if vuln.NetworkContext != nil {
			return vuln.NetworkContext.Service
		}
	case "web":
		if vuln.WebContext != nil {
			return vuln.WebContext.Technology
		}
	case "container":
		if vuln.ContainerContext != nil {
			return extractProductFromImageName(vuln.ContainerContext.ImageName)
		}
	case "cloud":
		if vuln.CloudContext != nil {
			return vuln.CloudContext.ServiceName
		}
	case "code":
		if vuln.CodeContext != nil {
			return vuln.CodeContext.Language
		}
	}

	return ""
}

func (ace *AssetCorrelationEngine) extractVersionFromVulnerability(vuln *UnifiedVulnerability) string {
	// Extract version information based on scanner type and context
	switch vuln.ScannerType {
	case "network":
		if vuln.NetworkContext != nil {
			return vuln.NetworkContext.ServiceVersion
		}
	case "container":
		if vuln.ContainerContext != nil {
			return vuln.ContainerContext.PackageVersion
		}
	}

	return ""
}

func (ace *AssetCorrelationEngine) determinePlatform(vuln *UnifiedVulnerability) string {
	// Determine platform based on vulnerability context
	switch vuln.ScannerType {
	case "network":
		if vuln.NetworkContext != nil && vuln.NetworkContext.OSInfo != "" {
			return extractPlatformFromOS(vuln.NetworkContext.OSInfo)
		}
	case "container":
		return "linux" // Most containers run on Linux
	case "cloud":
		if vuln.CloudContext != nil {
			return vuln.CloudContext.Provider
		}
	}

	return "unknown"
}

// Simple extraction utility functions (stubs)

func extractVendor(tags map[string]string) string {
	if vendor, exists := tags["vendor"]; exists {
		return vendor
	}
	return ""
}

func extractProduct(tags map[string]string) string {
	if product, exists := tags["product"]; exists {
		return product
	}
	return ""
}

func extractVersion(tags map[string]string) string {
	if version, exists := tags["version"]; exists {
		return version
	}
	return ""
}

func extractProductFromService(service string) string {
	// Extract product name from service string
	return strings.ToLower(service)
}

func extractProductFromTechnology(technology string) string {
	// Extract product name from technology string
	return strings.ToLower(technology)
}

func extractProductFromLanguage(language string) string {
	// Map language to common implementations
	langMap := map[string]string{
		"java":       "openjdk",
		"python":     "python",
		"javascript": "nodejs",
		"go":         "golang",
		"ruby":       "ruby",
		"php":        "php",
	}

	if product, exists := langMap[strings.ToLower(language)]; exists {
		return product
	}

	return strings.ToLower(language)
}

func extractVendorFromRegistry(registry string) string {
	// Extract vendor from container registry
	parts := strings.Split(registry, "/")
	if len(parts) > 0 {
		return parts[0]
	}
	return ""
}

func extractProductFromImageName(imageName string) string {
	// Extract product from container image name
	parts := strings.Split(imageName, "/")
	if len(parts) > 0 {
		imagePart := parts[len(parts)-1]
		// Remove tag if present
		if colonIndex := strings.Index(imagePart, ":"); colonIndex > 0 {
			return imagePart[:colonIndex]
		}
		return imagePart
	}
	return ""
}

func extractPlatformFromOS(osInfo string) string {
	osLower := strings.ToLower(osInfo)
	if strings.Contains(osLower, "windows") {
		return "windows"
	} else if strings.Contains(osLower, "linux") {
		return "linux"
	} else if strings.Contains(osLower, "macos") || strings.Contains(osLower, "darwin") {
		return "macos"
	}
	return "unknown"
}

func (ace *AssetCorrelationEngine) searchAssetsByContext(ctx context.Context, vuln *UnifiedVulnerability, options CorrelationOptions) ([]AssetMatch, error) {
	// TODO: Implement context-based asset search
	return []AssetMatch{}, nil
}

func (ace *AssetCorrelationEngine) processVulnerabilitiesAsync(ctx context.Context, vulns []UnifiedVulnerability, options CorrelationOptions) ([]CorrelationResult, error) {
	// TODO: Implement async processing with worker pools
	results := make([]CorrelationResult, len(vulns))
	return results, nil
}

func (ace *AssetCorrelationEngine) loadMappingRules() {
	// TODO: Load custom mapping rules from configuration
	ace.logger.Info("Loading custom mapping rules")
}

func (ace *AssetCorrelationEngine) generateCacheKey(vuln *UnifiedVulnerability, options CorrelationOptions) string {
	// Generate a deterministic cache key
	return fmt.Sprintf("corr_%s_%s_%.2f", vuln.ID, vuln.VulnerabilityHash, options.ConfidenceThreshold)
}

func (ace *AssetCorrelationEngine) calculateCompletenessScore(result *CorrelationResult) float64 {
	// TODO: Implement completeness scoring
	return 0.8
}

func (ace *AssetCorrelationEngine) calculateAccuracyScore(result *CorrelationResult) float64 {
	// TODO: Implement accuracy scoring
	return 0.85
}

func (ace *AssetCorrelationEngine) calculateReliabilityScore(result *CorrelationResult) float64 {
	// TODO: Implement reliability scoring
	return 0.9
}

func (ace *AssetCorrelationEngine) updateStatistics(result *CorrelationResult, processingTime time.Duration) {
	ace.mutex.Lock()
	defer ace.mutex.Unlock()

	ace.statistics.TotalCorrelations++

	if len(result.AssetMatches) > 0 || len(result.CPEMatches) > 0 || len(result.OVALMatches) > 0 {
		ace.statistics.SuccessfulMatches++
	} else {
		ace.statistics.NoMatches++
	}

	// Update average processing time
	if ace.statistics.TotalCorrelations == 1 {
		ace.statistics.AverageProcessingTime = processingTime
	} else {
		total := ace.statistics.AverageProcessingTime * time.Duration(ace.statistics.TotalCorrelations-1)
		ace.statistics.AverageProcessingTime = (total + processingTime) / time.Duration(ace.statistics.TotalCorrelations)
	}

	// Update average confidence
	if ace.statistics.TotalCorrelations == 1 {
		ace.statistics.AverageConfidence = result.OverallConfidence
	} else {
		total := ace.statistics.AverageConfidence * float64(ace.statistics.TotalCorrelations-1)
		ace.statistics.AverageConfidence = (total + result.OverallConfidence) / float64(ace.statistics.TotalCorrelations)
	}

	ace.statistics.LastProcessed = time.Now()
}
