// enrichment.go - Production-grade vulnerability enrichment services for iSECTECH
// Adds threat intelligence, business context, and additional metadata to vulnerabilities

package data

import (
	"context"
	"fmt"
	"log/slog"
	"net"
	"net/url"
	"regexp"
	"sort"
	"sync"
	"time"
)

// EnrichmentEngine provides comprehensive vulnerability enrichment capabilities
type EnrichmentEngine struct {
	config                 EnrichmentConfig
	logger                 *slog.Logger
	threatIntelSources     map[string]ThreatIntelSource
	geoLocationService     GeoLocationService
	businessContextService BusinessContextService
	complianceService      ComplianceService
	exploitDBService       ExploitDBService
	vendorAdvisoryService  VendorAdvisoryService
	cache                  EnrichmentCache
	statistics             EnrichmentStatistics
	rateLimiters           map[string]*RateLimiter
	mutex                  sync.RWMutex
}

// EnrichmentConfig contains configuration for the enrichment engine
type EnrichmentConfig struct {
	// Service endpoints
	ThreatIntelEndpoints    map[string]string `json:"threat_intel_endpoints"`
	GeoLocationEndpoint     string            `json:"geo_location_endpoint"`
	ExploitDBEndpoint       string            `json:"exploitdb_endpoint"`
	VendorAdvisoryEndpoints map[string]string `json:"vendor_advisory_endpoints"`

	// API credentials
	APIKeys    map[string]string `json:"api_keys"`
	AuthTokens map[string]string `json:"auth_tokens"`

	// Processing settings
	MaxConcurrentRequests int           `json:"max_concurrent_requests"`
	RequestTimeout        time.Duration `json:"request_timeout"`
	RetryAttempts         int           `json:"retry_attempts"`
	RetryDelay            time.Duration `json:"retry_delay"`

	// Rate limiting
	RateLimits      map[string]RateLimit `json:"rate_limits"`
	GlobalRateLimit RateLimit            `json:"global_rate_limit"`

	// Quality control
	MinConfidenceThreshold float64 `json:"min_confidence_threshold"`
	MaxAgeHours            int     `json:"max_age_hours"`
	RequireValidation      bool    `json:"require_validation"`

	// Caching
	EnableCaching   bool          `json:"enable_caching"`
	CacheExpiration time.Duration `json:"cache_expiration"`
	CacheMaxSize    int           `json:"cache_max_size"`

	// Feature flags
	EnableThreatIntel      bool `json:"enable_threat_intel"`
	EnableGeoLocation      bool `json:"enable_geo_location"`
	EnableBusinessContext  bool `json:"enable_business_context"`
	EnableCompliance       bool `json:"enable_compliance"`
	EnableExploitData      bool `json:"enable_exploit_data"`
	EnableVendorAdvisories bool `json:"enable_vendor_advisories"`

	// iSECTECH specific
	TenantIsolation       bool             `json:"tenant_isolation"`
	CustomEnrichmentRules []EnrichmentRule `json:"custom_enrichment_rules"`
	PrivacyMode           bool             `json:"privacy_mode"`
	DataRetentionDays     int              `json:"data_retention_days"`
}

type RateLimit struct {
	RequestsPerSecond int `json:"requests_per_second"`
	BurstSize         int `json:"burst_size"`
}

type EnrichmentRule struct {
	ID         string             `json:"id"`
	Name       string             `json:"name"`
	Conditions []RuleCondition    `json:"conditions"`
	Actions    []EnrichmentAction `json:"actions"`
	Priority   int                `json:"priority"`
	Enabled    bool               `json:"enabled"`
}

type EnrichmentAction struct {
	Type               string                 `json:"type"`
	Parameters         map[string]interface{} `json:"parameters"`
	ConfidenceModifier float64                `json:"confidence_modifier"`
}

// EnrichmentStatistics tracks enrichment performance and quality
type EnrichmentStatistics struct {
	TotalEnrichments      int64                    `json:"total_enrichments"`
	SuccessfulEnrichments int64                    `json:"successful_enrichments"`
	FailedEnrichments     int64                    `json:"failed_enrichments"`
	CacheHits             int64                    `json:"cache_hits"`
	CacheMisses           int64                    `json:"cache_misses"`
	AverageProcessingTime time.Duration            `json:"average_processing_time"`
	SourceStatistics      map[string]SourceStats   `json:"source_statistics"`
	QualityMetrics        EnrichmentQualityMetrics `json:"quality_metrics"`
	LastProcessed         time.Time                `json:"last_processed"`
}

type SourceStats struct {
	TotalRequests       int64         `json:"total_requests"`
	SuccessfulRequests  int64         `json:"successful_requests"`
	FailedRequests      int64         `json:"failed_requests"`
	AverageResponseTime time.Duration `json:"average_response_time"`
	LastRequest         time.Time     `json:"last_request"`
	ErrorRate           float64       `json:"error_rate"`
}

type EnrichmentQualityMetrics struct {
	DataFreshness          float64          `json:"data_freshness"`
	SourceReliability      float64          `json:"source_reliability"`
	ConfidenceDistribution map[string]int64 `json:"confidence_distribution"`
	AccuracyScore          float64          `json:"accuracy_score"`
}

// EnrichmentJob represents a single enrichment task
type EnrichmentJob struct {
	ID              string                `json:"id"`
	VulnerabilityID string                `json:"vulnerability_id"`
	Vulnerability   *UnifiedVulnerability `json:"vulnerability"`
	EnrichmentTypes []string              `json:"enrichment_types"`
	Context         EnrichmentContext     `json:"context"`
	Options         EnrichmentOptions     `json:"options"`
	CreatedAt       time.Time             `json:"created_at"`
	ProcessedAt     *time.Time            `json:"processed_at,omitempty"`
	Result          *EnrichmentResult     `json:"result,omitempty"`
	Status          string                `json:"status"`
	ProcessingTime  time.Duration         `json:"processing_time"`
	Errors          []string              `json:"errors"`
}

type EnrichmentContext struct {
	TenantID          string                 `json:"tenant_id"`
	UserContext       map[string]interface{} `json:"user_context"`
	BusinessContext   map[string]interface{} `json:"business_context"`
	TechnicalContext  map[string]interface{} `json:"technical_context"`
	ComplianceContext map[string]interface{} `json:"compliance_context"`
	CustomContext     map[string]interface{} `json:"custom_context"`
}

type EnrichmentOptions struct {
	Force              bool          `json:"force"`
	IncludeExpiredData bool          `json:"include_expired_data"`
	MinConfidence      float64       `json:"min_confidence"`
	MaxSources         int           `json:"max_sources"`
	Timeout            time.Duration `json:"timeout"`
	ValidateResults    bool          `json:"validate_results"`
}

type EnrichmentResult struct {
	VulnerabilityID     string                       `json:"vulnerability_id"`
	EnrichmentData      map[string]interface{}       `json:"enrichment_data"`
	ThreatIntelligence  *ThreatIntelligence          `json:"threat_intelligence,omitempty"`
	GeoLocationData     *GeoLocationData             `json:"geo_location_data,omitempty"`
	BusinessContextData *BusinessContextData         `json:"business_context_data,omitempty"`
	ComplianceData      *ComplianceData              `json:"compliance_data,omitempty"`
	ExploitData         *ExploitData                 `json:"exploit_data,omitempty"`
	VendorAdvisoryData  *VendorAdvisoryData          `json:"vendor_advisory_data,omitempty"`
	QualityAssessment   EnrichmentQualityAssessment  `json:"quality_assessment"`
	ProcessingMetadata  EnrichmentProcessingMetadata `json:"processing_metadata"`
	ValidationResults   []EnrichmentValidationResult `json:"validation_results"`
	Recommendations     []string                     `json:"recommendations"`
}

type GeoLocationData struct {
	IPAddresses    []GeoLocationInfo `json:"ip_addresses"`
	Domains        []GeoLocationInfo `json:"domains"`
	ThreatRisk     float64           `json:"threat_risk"`
	CountryRisk    float64           `json:"country_risk"`
	ISPInformation []ISPInfo         `json:"isp_information"`
	TorExitNodes   []string          `json:"tor_exit_nodes"`
	VPNEndpoints   []string          `json:"vpn_endpoints"`
	LastUpdated    time.Time         `json:"last_updated"`
}

type GeoLocationInfo struct {
	IPAddress    string   `json:"ip_address,omitempty"`
	Domain       string   `json:"domain,omitempty"`
	Country      string   `json:"country"`
	CountryCode  string   `json:"country_code"`
	Region       string   `json:"region"`
	City         string   `json:"city"`
	Latitude     float64  `json:"latitude"`
	Longitude    float64  `json:"longitude"`
	ASN          string   `json:"asn"`
	ISP          string   `json:"isp"`
	Organization string   `json:"organization"`
	ThreatLevel  string   `json:"threat_level"`
	IsMalicious  bool     `json:"is_malicious"`
	Sources      []string `json:"sources"`
	Confidence   float64  `json:"confidence"`
}

type ISPInfo struct {
	Name            string   `json:"name"`
	ASN             string   `json:"asn"`
	Country         string   `json:"country"`
	IPRanges        []string `json:"ip_ranges"`
	ThreatLevel     string   `json:"threat_level"`
	ReputationScore float64  `json:"reputation_score"`
}

type BusinessContextData struct {
	AssetCriticality       string                 `json:"asset_criticality"`
	BusinessOwner          string                 `json:"business_owner"`
	ApplicationTier        string                 `json:"application_tier"`
	DataClassification     string                 `json:"data_classification"`
	MaintenanceWindow      []MaintenanceWindow    `json:"maintenance_window"`
	BusinessImpactAnalysis BusinessImpactAnalysis `json:"business_impact_analysis"`
	SLARequirements        SLARequirements        `json:"sla_requirements"`
	CostCenter             string                 `json:"cost_center"`
	ProjectCode            string                 `json:"project_code"`
	EnvironmentType        string                 `json:"environment_type"`
	LastUpdated            time.Time              `json:"last_updated"`
}

type MaintenanceWindow struct {
	Name      string `json:"name"`
	DayOfWeek int    `json:"day_of_week"`
	StartTime string `json:"start_time"`
	EndTime   string `json:"end_time"`
	Timezone  string `json:"timezone"`
	Frequency string `json:"frequency"`
}

type BusinessImpactAnalysis struct {
	FinancialImpact        float64       `json:"financial_impact"`
	OperationalImpact      string        `json:"operational_impact"`
	ReputationalImpact     string        `json:"reputational_impact"`
	ComplianceImpact       string        `json:"compliance_impact"`
	RecoveryTimeObjective  time.Duration `json:"recovery_time_objective"`
	RecoveryPointObjective time.Duration `json:"recovery_point_objective"`
}

type SLARequirements struct {
	AvailabilityTarget  float64           `json:"availability_target"`
	ResponseTime        time.Duration     `json:"response_time"`
	ResolutionTime      time.Duration     `json:"resolution_time"`
	EscalationProcedure []EscalationLevel `json:"escalation_procedure"`
}

type EscalationLevel struct {
	Level         int           `json:"level"`
	TimeThreshold time.Duration `json:"time_threshold"`
	Contacts      []Contact     `json:"contacts"`
	Actions       []string      `json:"actions"`
}

type Contact struct {
	Name            string `json:"name"`
	Role            string `json:"role"`
	Email           string `json:"email"`
	Phone           string `json:"phone"`
	PreferredMethod string `json:"preferred_method"`
}

type ComplianceData struct {
	ApplicableFrameworks    []ComplianceFramework    `json:"applicable_frameworks"`
	ControlMappings         []ControlMapping         `json:"control_mappings"`
	ComplianceStatus        string                   `json:"compliance_status"`
	LastAssessment          time.Time                `json:"last_assessment"`
	NextAssessment          time.Time                `json:"next_assessment"`
	AuditFindings           []AuditFinding           `json:"audit_findings"`
	RemediationRequirements []RemediationRequirement `json:"remediation_requirements"`
	RegulatoryImpact        RegulatoryImpact         `json:"regulatory_impact"`
}

type ComplianceFramework struct {
	Name             string   `json:"name"`
	Version          string   `json:"version"`
	Applicability    string   `json:"applicability"`
	RequiredControls []string `json:"required_controls"`
	ComplianceLevel  string   `json:"compliance_level"`
}

type ControlMapping struct {
	FrameworkControl     string   `json:"framework_control"`
	ControlTitle         string   `json:"control_title"`
	ControlDescription   string   `json:"control_description"`
	ImplementationStatus string   `json:"implementation_status"`
	Evidence             []string `json:"evidence"`
	Gaps                 []string `json:"gaps"`
}

type AuditFinding struct {
	FindingID        string    `json:"finding_id"`
	Severity         string    `json:"severity"`
	Description      string    `json:"description"`
	Recommendation   string    `json:"recommendation"`
	Status           string    `json:"status"`
	DueDate          time.Time `json:"due_date"`
	ResponsibleParty string    `json:"responsible_party"`
}

type RemediationRequirement struct {
	RequirementID      string        `json:"requirement_id"`
	Description        string        `json:"description"`
	Priority           string        `json:"priority"`
	Timeline           time.Duration `json:"timeline"`
	Resources          []string      `json:"resources"`
	Dependencies       []string      `json:"dependencies"`
	ValidationCriteria []string      `json:"validation_criteria"`
}

type RegulatoryImpact struct {
	Regulations              []Regulation              `json:"regulations"`
	PotentialFines           []PotentialFine           `json:"potential_fines"`
	NotificationRequirements []NotificationRequirement `json:"notification_requirements"`
	BreachImpact             string                    `json:"breach_impact"`
}

type Regulation struct {
	Name               string   `json:"name"`
	Jurisdiction       string   `json:"jurisdiction"`
	ApplicableArticles []string `json:"applicable_articles"`
	Penalties          []string `json:"penalties"`
}

type PotentialFine struct {
	Amount     float64 `json:"amount"`
	Currency   string  `json:"currency"`
	Basis      string  `json:"basis"`
	Likelihood string  `json:"likelihood"`
}

type NotificationRequirement struct {
	Authority               string        `json:"authority"`
	Timeline                time.Duration `json:"timeline"`
	RequiredInformation     []string      `json:"required_information"`
	PenaltyForNonCompliance string        `json:"penalty_for_non_compliance"`
}

type ExploitData struct {
	PublicExploits        []PublicExploit        `json:"public_exploits"`
	ExploitKits           []ExploitKit           `json:"exploit_kits"`
	WeaponizationStatus   string                 `json:"weaponization_status"`
	ExploitComplexity     string                 `json:"exploit_complexity"`
	ExploitReliability    string                 `json:"exploit_reliability"`
	AttackVectors         []AttackVector         `json:"attack_vectors"`
	MitreAttackTechniques []MitreAttackTechnique `json:"mitre_attack_techniques"`
	LastUpdated           time.Time              `json:"last_updated"`
}

type PublicExploit struct {
	ExploitID     string    `json:"exploit_id"`
	Title         string    `json:"title"`
	Description   string    `json:"description"`
	Author        string    `json:"author"`
	DatePublished time.Time `json:"date_published"`
	Platform      string    `json:"platform"`
	Type          string    `json:"type"`
	Source        string    `json:"source"`
	URL           string    `json:"url"`
	Verified      bool      `json:"verified"`
	Maturity      string    `json:"maturity"`
}

type ExploitKit struct {
	Name                    string    `json:"name"`
	Family                  string    `json:"family"`
	FirstSeen               time.Time `json:"first_seen"`
	LastSeen                time.Time `json:"last_seen"`
	ThreatActors            []string  `json:"threat_actors"`
	TargetedVulnerabilities []string  `json:"targeted_vulnerabilities"`
	Distribution            []string  `json:"distribution"`
}

type AttackVector struct {
	Vector                string `json:"vector"`
	Complexity            string `json:"complexity"`
	PrivilegesRequired    string `json:"privileges_required"`
	UserInteraction       string `json:"user_interaction"`
	Scope                 string `json:"scope"`
	ImpactConfidentiality string `json:"impact_confidentiality"`
	ImpactIntegrity       string `json:"impact_integrity"`
	ImpactAvailability    string `json:"impact_availability"`
}

type MitreAttackTechnique struct {
	TechniqueID   string   `json:"technique_id"`
	TechniqueName string   `json:"technique_name"`
	Tactic        string   `json:"tactic"`
	SubTechniques []string `json:"sub_techniques"`
	DataSources   []string `json:"data_sources"`
	Mitigations   []string `json:"mitigations"`
	Detections    []string `json:"detections"`
}

type VendorAdvisoryData struct {
	VendorAdvisories      []VendorAdvisory       `json:"vendor_advisories"`
	SecurityBulletins     []SecurityBulletin     `json:"security_bulletins"`
	PatchInformation      []PatchInformation     `json:"patch_information"`
	WorkaroundSuggestions []WorkaroundSuggestion `json:"workaround_suggestions"`
	VendorResponse        VendorResponse         `json:"vendor_response"`
	LastUpdated           time.Time              `json:"last_updated"`
}

type VendorAdvisory struct {
	AdvisoryID       string            `json:"advisory_id"`
	Vendor           string            `json:"vendor"`
	Title            string            `json:"title"`
	Description      string            `json:"description"`
	Severity         string            `json:"severity"`
	CVSSScore        float64           `json:"cvss_score"`
	AffectedProducts []AffectedProduct `json:"affected_products"`
	PublishedDate    time.Time         `json:"published_date"`
	LastUpdated      time.Time         `json:"last_updated"`
	URL              string            `json:"url"`
	References       []string          `json:"references"`
}

type SecurityBulletin struct {
	BulletinID           string    `json:"bulletin_id"`
	Title                string    `json:"title"`
	Summary              string    `json:"summary"`
	ImpactRating         string    `json:"impact_rating"`
	PublishedDate        time.Time `json:"published_date"`
	VulnerabilitiesFixed []string  `json:"vulnerabilities_fixed"`
	URL                  string    `json:"url"`
}

type PatchInformation struct {
	PatchID            string    `json:"patch_id"`
	PatchName          string    `json:"patch_name"`
	Description        string    `json:"description"`
	ReleaseDate        time.Time `json:"release_date"`
	PatchType          string    `json:"patch_type"`
	InstallationMethod string    `json:"installation_method"`
	Prerequisites      []string  `json:"prerequisites"`
	RestartRequired    bool      `json:"restart_required"`
	DownloadURL        string    `json:"download_url"`
	FileHash           string    `json:"file_hash"`
	FileSize           int64     `json:"file_size"`
}

type WorkaroundSuggestion struct {
	Title         string   `json:"title"`
	Description   string   `json:"description"`
	Effectiveness string   `json:"effectiveness"`
	Complexity    string   `json:"complexity"`
	Impact        string   `json:"impact"`
	Steps         []string `json:"steps"`
	Limitations   []string `json:"limitations"`
}

type VendorResponse struct {
	ResponseTime          time.Duration `json:"response_time"`
	ResponseQuality       string        `json:"response_quality"`
	CommunicationChannels []string      `json:"communication_channels"`
	SupportLevel          string        `json:"support_level"`
	PatchCommitment       string        `json:"patch_commitment"`
	EstimatedPatchDate    *time.Time    `json:"estimated_patch_date,omitempty"`
}

// Quality assessment structures

type EnrichmentQualityAssessment struct {
	OverallScore      float64            `json:"overall_score"`
	FreshnessScore    float64            `json:"freshness_score"`
	ReliabilityScore  float64            `json:"reliability_score"`
	CompletenessScore float64            `json:"completeness_score"`
	AccuracyScore     float64            `json:"accuracy_score"`
	QualityIssues     []QualityIssue     `json:"quality_issues"`
	SourceCredibility map[string]float64 `json:"source_credibility"`
	DataConfidence    float64            `json:"data_confidence"`
}

type EnrichmentProcessingMetadata struct {
	ProcessingVersion string        `json:"processing_version"`
	SourcesUsed       []string      `json:"sources_used"`
	ProcessingLatency time.Duration `json:"processing_latency"`
	CacheUtilization  float64       `json:"cache_utilization"`
	ErrorsEncountered []string      `json:"errors_encountered"`
	WarningsGenerated []string      `json:"warnings_generated"`
	RetryAttempts     int           `json:"retry_attempts"`
}

type EnrichmentValidationResult struct {
	ValidationType  string            `json:"validation_type"`
	IsValid         bool              `json:"is_valid"`
	Confidence      float64           `json:"confidence"`
	Issues          []ValidationIssue `json:"issues"`
	Recommendations []string          `json:"recommendations"`
}

// Service interfaces

type ThreatIntelSource interface {
	GetSourceName() string
	QueryThreatData(ctx context.Context, indicators []string) (*ThreatIntelligence, error)
	GetConfidenceLevel() float64
	GetDataFreshness() time.Duration
	ValidateCredentials(ctx context.Context) error
	GetRateLimit() RateLimit
}

type GeoLocationService interface {
	GetLocationInfo(ctx context.Context, ipAddress string) (*GeoLocationInfo, error)
	BulkGetLocationInfo(ctx context.Context, ipAddresses []string) ([]GeoLocationInfo, error)
	GetDomainInfo(ctx context.Context, domain string) (*GeoLocationInfo, error)
	IsHealthy() bool
}

type BusinessContextService interface {
	GetBusinessContext(ctx context.Context, assetID string) (*BusinessContextData, error)
	UpdateBusinessContext(ctx context.Context, assetID string, context *BusinessContextData) error
	GetAssetCriticality(ctx context.Context, assetID string) (string, error)
	GetMaintenanceWindows(ctx context.Context, assetID string) ([]MaintenanceWindow, error)
}

type ComplianceService interface {
	GetComplianceRequirements(ctx context.Context, assetID string) (*ComplianceData, error)
	MapVulnerabilityToControls(ctx context.Context, vuln *UnifiedVulnerability) ([]ControlMapping, error)
	GetRegulatoryImpact(ctx context.Context, vuln *UnifiedVulnerability) (*RegulatoryImpact, error)
	GetRemediationRequirements(ctx context.Context, vuln *UnifiedVulnerability) ([]RemediationRequirement, error)
}

type ExploitDBService interface {
	SearchExploits(ctx context.Context, cve string) ([]PublicExploit, error)
	GetExploitDetails(ctx context.Context, exploitID string) (*PublicExploit, error)
	GetExploitKits(ctx context.Context, cve string) ([]ExploitKit, error)
	GetMitreAttackMapping(ctx context.Context, cve string) ([]MitreAttackTechnique, error)
}

type VendorAdvisoryService interface {
	GetVendorAdvisories(ctx context.Context, cve string) ([]VendorAdvisory, error)
	GetPatchInformation(ctx context.Context, cve string) ([]PatchInformation, error)
	GetWorkarounds(ctx context.Context, cve string) ([]WorkaroundSuggestion, error)
	GetVendorResponse(ctx context.Context, vendor string, cve string) (*VendorResponse, error)
}

type EnrichmentCache interface {
	Get(ctx context.Context, key string) (interface{}, bool)
	Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error
	Delete(ctx context.Context, key string) error
	Clear(ctx context.Context) error
	GetStats() CacheStats
}

type RateLimiter interface {
	Allow() bool
	Wait(ctx context.Context) error
	Limit() int
	Burst() int
}

// NewEnrichmentEngine creates a new production-grade enrichment engine
func NewEnrichmentEngine(config EnrichmentConfig, logger *slog.Logger) *EnrichmentEngine {
	engine := &EnrichmentEngine{
		config:             config,
		logger:             logger.With("component", "enrichment_engine"),
		threatIntelSources: make(map[string]ThreatIntelSource),
		cache:              NewInMemoryEnrichmentCache(config.CacheMaxSize),
		statistics: EnrichmentStatistics{
			SourceStatistics: make(map[string]SourceStats),
			QualityMetrics: EnrichmentQualityMetrics{
				ConfidenceDistribution: make(map[string]int64),
			},
		},
		rateLimiters: make(map[string]*RateLimiter),
	}

	// Initialize services
	engine.initializeServices()

	// Initialize rate limiters
	engine.initializeRateLimiters()

	return engine
}

// EnrichVulnerability enriches a vulnerability with additional context and intelligence
func (ee *EnrichmentEngine) EnrichVulnerability(ctx context.Context, vuln *UnifiedVulnerability, options EnrichmentOptions) (*EnrichmentResult, error) {
	startTime := time.Now()

	ee.logger.Info("Starting vulnerability enrichment",
		"vuln_id", vuln.ID,
		"enrichment_types", len(ee.getEnabledEnrichmentTypes()))

	// Check cache first
	cacheKey := ee.generateCacheKey(vuln, options)
	if ee.config.EnableCaching && !options.Force {
		if cached, found := ee.cache.Get(ctx, cacheKey); found {
			if result, ok := cached.(*EnrichmentResult); ok {
				ee.logger.Debug("Returning cached enrichment result")
				ee.statistics.CacheHits++
				return result, nil
			}
		}
		ee.statistics.CacheMisses++
	}

	// Create result structure
	result := &EnrichmentResult{
		VulnerabilityID:   vuln.ID,
		EnrichmentData:    make(map[string]interface{}),
		ValidationResults: make([]EnrichmentValidationResult, 0),
		Recommendations:   make([]string, 0),
	}

	// Perform enrichment based on enabled features
	enrichmentTasks := ee.buildEnrichmentTasks(vuln, options)

	// Execute enrichment tasks
	for _, task := range enrichmentTasks {
		if err := ee.executeEnrichmentTask(ctx, task, result); err != nil {
			ee.logger.Warn("Enrichment task failed", "task", task.Type, "error", err)
			continue
		}
	}

	// Assess enrichment quality
	result.QualityAssessment = ee.assessEnrichmentQuality(result)

	// Generate recommendations
	result.Recommendations = ee.generateEnrichmentRecommendations(result)

	// Validate results if requested
	if options.ValidateResults {
		result.ValidationResults = ee.validateEnrichmentResults(ctx, result)
	}

	// Update processing metadata
	processingTime := time.Since(startTime)
	result.ProcessingMetadata = EnrichmentProcessingMetadata{
		ProcessingVersion: "1.0",
		SourcesUsed:       ee.getUsedSources(result),
		ProcessingLatency: processingTime,
		CacheUtilization:  ee.calculateCacheUtilization(),
	}

	// Update statistics
	ee.updateStatistics(result, processingTime)

	// Cache result
	if ee.config.EnableCaching {
		ee.cache.Set(ctx, cacheKey, result, ee.config.CacheExpiration)
	}

	ee.logger.Info("Vulnerability enrichment completed",
		"vuln_id", vuln.ID,
		"enrichment_score", result.QualityAssessment.OverallScore,
		"processing_time", processingTime)

	return result, nil
}

// BatchEnrichVulnerabilities enriches multiple vulnerabilities in batch
func (ee *EnrichmentEngine) BatchEnrichVulnerabilities(ctx context.Context, vulns []UnifiedVulnerability, options EnrichmentOptions) ([]EnrichmentResult, error) {
	results := make([]EnrichmentResult, len(vulns))

	// Process vulnerabilities with concurrency control
	semaphore := make(chan struct{}, ee.config.MaxConcurrentRequests)
	var wg sync.WaitGroup
	var mu sync.Mutex

	for i, vuln := range vulns {
		wg.Add(1)
		go func(index int, v UnifiedVulnerability) {
			defer wg.Done()

			// Acquire semaphore
			semaphore <- struct{}{}
			defer func() { <-semaphore }()

			result, err := ee.EnrichVulnerability(ctx, &v, options)
			if err != nil {
				ee.logger.Error("Failed to enrich vulnerability", "vuln_id", v.ID, "error", err)
				return
			}

			mu.Lock()
			results[index] = *result
			mu.Unlock()
		}(i, vuln)
	}

	wg.Wait()
	return results, nil
}

// Private helper methods

func (ee *EnrichmentEngine) initializeServices() {
	// Initialize threat intelligence sources
	if ee.config.EnableThreatIntel {
		for name, endpoint := range ee.config.ThreatIntelEndpoints {
			source := NewThreatIntelSource(name, endpoint, ee.config.APIKeys[name], ee.logger)
			ee.threatIntelSources[name] = source
		}
	}

	// Initialize other services
	if ee.config.EnableGeoLocation {
		ee.geoLocationService = NewGeoLocationService(ee.config.GeoLocationEndpoint, ee.config.APIKeys["geolocation"], ee.logger)
	}

	if ee.config.EnableBusinessContext {
		ee.businessContextService = NewBusinessContextService(ee.logger)
	}

	if ee.config.EnableCompliance {
		ee.complianceService = NewComplianceService(ee.logger)
	}

	if ee.config.EnableExploitData {
		ee.exploitDBService = NewExploitDBService(ee.config.ExploitDBEndpoint, ee.config.APIKeys["exploitdb"], ee.logger)
	}

	if ee.config.EnableVendorAdvisories {
		ee.vendorAdvisoryService = NewVendorAdvisoryService(ee.config.VendorAdvisoryEndpoints, ee.config.APIKeys, ee.logger)
	}
}

func (ee *EnrichmentEngine) initializeRateLimiters() {
	// Initialize rate limiters for each source
	for source, limit := range ee.config.RateLimits {
		rateLimiter := NewTokenBucketRateLimiter(limit.RequestsPerSecond, limit.BurstSize)
		ee.rateLimiters[source] = &rateLimiter
	}

	// Global rate limiter
	globalRateLimiter := NewTokenBucketRateLimiter(
		ee.config.GlobalRateLimit.RequestsPerSecond,
		ee.config.GlobalRateLimit.BurstSize,
	)
	ee.rateLimiters["global"] = &globalRateLimiter
}

func (ee *EnrichmentEngine) getEnabledEnrichmentTypes() []string {
	types := make([]string, 0)

	if ee.config.EnableThreatIntel {
		types = append(types, "threat_intelligence")
	}
	if ee.config.EnableGeoLocation {
		types = append(types, "geo_location")
	}
	if ee.config.EnableBusinessContext {
		types = append(types, "business_context")
	}
	if ee.config.EnableCompliance {
		types = append(types, "compliance")
	}
	if ee.config.EnableExploitData {
		types = append(types, "exploit_data")
	}
	if ee.config.EnableVendorAdvisories {
		types = append(types, "vendor_advisories")
	}

	return types
}

func (ee *EnrichmentEngine) buildEnrichmentTasks(vuln *UnifiedVulnerability, options EnrichmentOptions) []EnrichmentTask {
	tasks := make([]EnrichmentTask, 0)

	// Threat intelligence enrichment
	if ee.config.EnableThreatIntel {
		task := EnrichmentTask{
			Type:          "threat_intelligence",
			Priority:      1,
			Timeout:       options.Timeout,
			Vulnerability: vuln,
		}
		tasks = append(tasks, task)
	}

	// Geo-location enrichment
	if ee.config.EnableGeoLocation && ee.hasIPAddresses(vuln) {
		task := EnrichmentTask{
			Type:          "geo_location",
			Priority:      2,
			Timeout:       options.Timeout,
			Vulnerability: vuln,
		}
		tasks = append(tasks, task)
	}

	// Business context enrichment
	if ee.config.EnableBusinessContext && vuln.AssetID != "" {
		task := EnrichmentTask{
			Type:          "business_context",
			Priority:      3,
			Timeout:       options.Timeout,
			Vulnerability: vuln,
		}
		tasks = append(tasks, task)
	}

	// Compliance enrichment
	if ee.config.EnableCompliance {
		task := EnrichmentTask{
			Type:          "compliance",
			Priority:      4,
			Timeout:       options.Timeout,
			Vulnerability: vuln,
		}
		tasks = append(tasks, task)
	}

	// Exploit data enrichment
	if ee.config.EnableExploitData && len(vuln.CVE) > 0 {
		task := EnrichmentTask{
			Type:          "exploit_data",
			Priority:      5,
			Timeout:       options.Timeout,
			Vulnerability: vuln,
		}
		tasks = append(tasks, task)
	}

	// Vendor advisory enrichment
	if ee.config.EnableVendorAdvisories && len(vuln.CVE) > 0 {
		task := EnrichmentTask{
			Type:          "vendor_advisories",
			Priority:      6,
			Timeout:       options.Timeout,
			Vulnerability: vuln,
		}
		tasks = append(tasks, task)
	}

	// Sort tasks by priority
	sort.Slice(tasks, func(i, j int) bool {
		return tasks[i].Priority < tasks[j].Priority
	})

	return tasks
}

type EnrichmentTask struct {
	Type          string
	Priority      int
	Timeout       time.Duration
	Vulnerability *UnifiedVulnerability
}

func (ee *EnrichmentEngine) executeEnrichmentTask(ctx context.Context, task EnrichmentTask, result *EnrichmentResult) error {
	taskCtx, cancel := context.WithTimeout(ctx, task.Timeout)
	defer cancel()

	switch task.Type {
	case "threat_intelligence":
		return ee.enrichWithThreatIntelligence(taskCtx, task.Vulnerability, result)
	case "geo_location":
		return ee.enrichWithGeoLocation(taskCtx, task.Vulnerability, result)
	case "business_context":
		return ee.enrichWithBusinessContext(taskCtx, task.Vulnerability, result)
	case "compliance":
		return ee.enrichWithCompliance(taskCtx, task.Vulnerability, result)
	case "exploit_data":
		return ee.enrichWithExploitData(taskCtx, task.Vulnerability, result)
	case "vendor_advisories":
		return ee.enrichWithVendorAdvisories(taskCtx, task.Vulnerability, result)
	default:
		return fmt.Errorf("unknown enrichment task type: %s", task.Type)
	}
}

func (ee *EnrichmentEngine) enrichWithThreatIntelligence(ctx context.Context, vuln *UnifiedVulnerability, result *EnrichmentResult) error {
	// Extract indicators from vulnerability
	indicators := ee.extractIndicators(vuln)

	if len(indicators) == 0 {
		return nil
	}

	// Query threat intelligence sources
	threatIntel := &ThreatIntelligence{
		IOCMatches:          make([]IOCMatch, 0),
		ThreatActors:        make([]string, 0),
		Campaigns:           make([]string, 0),
		TTP:                 make([]string, 0),
		IntelligenceSources: make([]string, 0),
		LastUpdated:         time.Now(),
	}

	for sourceName, source := range ee.threatIntelSources {
		// Check rate limit
		if rateLimiter, exists := ee.rateLimiters[sourceName]; exists {
			if !(*rateLimiter).Allow() {
				ee.logger.Warn("Rate limit exceeded", "source", sourceName)
				continue
			}
		}

		sourceIntel, err := source.QueryThreatData(ctx, indicators)
		if err != nil {
			ee.logger.Warn("Threat intelligence query failed", "source", sourceName, "error", err)
			continue
		}

		// Merge results
		ee.mergeThreatIntelligence(threatIntel, sourceIntel, sourceName)
	}

	result.ThreatIntelligence = threatIntel
	return nil
}

func (ee *EnrichmentEngine) enrichWithGeoLocation(ctx context.Context, vuln *UnifiedVulnerability, result *EnrichmentResult) error {
	ipAddresses := ee.extractIPAddresses(vuln)
	domains := ee.extractDomains(vuln)

	if len(ipAddresses) == 0 && len(domains) == 0 {
		return nil
	}

	geoData := &GeoLocationData{
		IPAddresses:  make([]GeoLocationInfo, 0),
		Domains:      make([]GeoLocationInfo, 0),
		TorExitNodes: make([]string, 0),
		VPNEndpoints: make([]string, 0),
		LastUpdated:  time.Now(),
	}

	// Process IP addresses
	if len(ipAddresses) > 0 {
		ipGeoInfo, err := ee.geoLocationService.BulkGetLocationInfo(ctx, ipAddresses)
		if err != nil {
			ee.logger.Warn("Geo-location lookup failed for IPs", "error", err)
		} else {
			geoData.IPAddresses = ipGeoInfo
		}
	}

	// Process domains
	for _, domain := range domains {
		domainGeoInfo, err := ee.geoLocationService.GetDomainInfo(ctx, domain)
		if err != nil {
			ee.logger.Warn("Geo-location lookup failed for domain", "domain", domain, "error", err)
			continue
		}
		geoData.Domains = append(geoData.Domains, *domainGeoInfo)
	}

	// Calculate risk scores
	geoData.ThreatRisk = ee.calculateThreatRisk(geoData)
	geoData.CountryRisk = ee.calculateCountryRisk(geoData)

	result.GeoLocationData = geoData
	return nil
}

func (ee *EnrichmentEngine) enrichWithBusinessContext(ctx context.Context, vuln *UnifiedVulnerability, result *EnrichmentResult) error {
	if vuln.AssetID == "" {
		return nil
	}

	businessContext, err := ee.businessContextService.GetBusinessContext(ctx, vuln.AssetID)
	if err != nil {
		return fmt.Errorf("failed to get business context: %w", err)
	}

	result.BusinessContextData = businessContext
	return nil
}

func (ee *EnrichmentEngine) enrichWithCompliance(ctx context.Context, vuln *UnifiedVulnerability, result *EnrichmentResult) error {
	complianceData, err := ee.complianceService.GetComplianceRequirements(ctx, vuln.AssetID)
	if err != nil {
		return fmt.Errorf("failed to get compliance requirements: %w", err)
	}

	// Map vulnerability to controls
	controlMappings, err := ee.complianceService.MapVulnerabilityToControls(ctx, vuln)
	if err != nil {
		ee.logger.Warn("Failed to map vulnerability to controls", "error", err)
	} else {
		complianceData.ControlMappings = controlMappings
	}

	// Get regulatory impact
	regulatoryImpact, err := ee.complianceService.GetRegulatoryImpact(ctx, vuln)
	if err != nil {
		ee.logger.Warn("Failed to get regulatory impact", "error", err)
	} else {
		complianceData.RegulatoryImpact = *regulatoryImpact
	}

	result.ComplianceData = complianceData
	return nil
}

func (ee *EnrichmentEngine) enrichWithExploitData(ctx context.Context, vuln *UnifiedVulnerability, result *EnrichmentResult) error {
	if len(vuln.CVE) == 0 {
		return nil
	}

	exploitData := &ExploitData{
		PublicExploits:        make([]PublicExploit, 0),
		ExploitKits:           make([]ExploitKit, 0),
		AttackVectors:         make([]AttackVector, 0),
		MitreAttackTechniques: make([]MitreAttackTechnique, 0),
		LastUpdated:           time.Now(),
	}

	// Search for public exploits
	for _, cve := range vuln.CVE {
		exploits, err := ee.exploitDBService.SearchExploits(ctx, cve)
		if err != nil {
			ee.logger.Warn("Exploit search failed", "cve", cve, "error", err)
			continue
		}
		exploitData.PublicExploits = append(exploitData.PublicExploits, exploits...)

		// Get exploit kits
		kits, err := ee.exploitDBService.GetExploitKits(ctx, cve)
		if err != nil {
			ee.logger.Warn("Exploit kit search failed", "cve", cve, "error", err)
		} else {
			exploitData.ExploitKits = append(exploitData.ExploitKits, kits...)
		}

		// Get MITRE ATT&CK mapping
		techniques, err := ee.exploitDBService.GetMitreAttackMapping(ctx, cve)
		if err != nil {
			ee.logger.Warn("MITRE ATT&CK mapping failed", "cve", cve, "error", err)
		} else {
			exploitData.MitreAttackTechniques = append(exploitData.MitreAttackTechniques, techniques...)
		}
	}

	// Determine weaponization status
	exploitData.WeaponizationStatus = ee.determineWeaponizationStatus(exploitData)

	result.ExploitData = exploitData
	return nil
}

func (ee *EnrichmentEngine) enrichWithVendorAdvisories(ctx context.Context, vuln *UnifiedVulnerability, result *EnrichmentResult) error {
	if len(vuln.CVE) == 0 {
		return nil
	}

	vendorData := &VendorAdvisoryData{
		VendorAdvisories:      make([]VendorAdvisory, 0),
		SecurityBulletins:     make([]SecurityBulletin, 0),
		PatchInformation:      make([]PatchInformation, 0),
		WorkaroundSuggestions: make([]WorkaroundSuggestion, 0),
		LastUpdated:           time.Now(),
	}

	// Get vendor advisories
	for _, cve := range vuln.CVE {
		advisories, err := ee.vendorAdvisoryService.GetVendorAdvisories(ctx, cve)
		if err != nil {
			ee.logger.Warn("Vendor advisory lookup failed", "cve", cve, "error", err)
		} else {
			vendorData.VendorAdvisories = append(vendorData.VendorAdvisories, advisories...)
		}

		// Get patch information
		patches, err := ee.vendorAdvisoryService.GetPatchInformation(ctx, cve)
		if err != nil {
			ee.logger.Warn("Patch information lookup failed", "cve", cve, "error", err)
		} else {
			vendorData.PatchInformation = append(vendorData.PatchInformation, patches...)
		}

		// Get workarounds
		workarounds, err := ee.vendorAdvisoryService.GetWorkarounds(ctx, cve)
		if err != nil {
			ee.logger.Warn("Workaround lookup failed", "cve", cve, "error", err)
		} else {
			vendorData.WorkaroundSuggestions = append(vendorData.WorkaroundSuggestions, workarounds...)
		}
	}

	result.VendorAdvisoryData = vendorData
	return nil
}

// Helper methods for data extraction and processing

func (ee *EnrichmentEngine) extractIndicators(vuln *UnifiedVulnerability) []string {
	indicators := make([]string, 0)

	// Extract IP addresses
	indicators = append(indicators, ee.extractIPAddresses(vuln)...)

	// Extract domains
	indicators = append(indicators, ee.extractDomains(vuln)...)

	// Extract hashes
	indicators = append(indicators, ee.extractHashes(vuln)...)

	// Extract URLs
	indicators = append(indicators, ee.extractURLs(vuln)...)

	return indicators
}

func (ee *EnrichmentEngine) extractIPAddresses(vuln *UnifiedVulnerability) []string {
	ips := make([]string, 0)

	// Network context
	if vuln.NetworkContext != nil && vuln.NetworkContext.HostIP != "" {
		ips = append(ips, vuln.NetworkContext.HostIP)
	}

	// Web context
	if vuln.WebContext != nil && vuln.WebContext.URL != "" {
		if ip := ee.extractIPFromURL(vuln.WebContext.URL); ip != "" {
			ips = append(ips, ip)
		}
	}

	// Additional extraction from description and evidence
	ipRegex := regexp.MustCompile(`\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b`)

	// Extract from description
	matches := ipRegex.FindAllString(vuln.Description, -1)
	ips = append(ips, matches...)

	// Extract from evidence fields based on scanner type
	switch vuln.ScannerType {
	case "web":
		if vuln.WebContext != nil && vuln.WebContext.Evidence != "" {
			matches := ipRegex.FindAllString(vuln.WebContext.Evidence, -1)
			ips = append(ips, matches...)
		}
	}

	// Deduplicate and validate IPs
	return ee.deduplicateAndValidateIPs(ips)
}

func (ee *EnrichmentEngine) extractDomains(vuln *UnifiedVulnerability) []string {
	domains := make([]string, 0)

	// Web context
	if vuln.WebContext != nil && vuln.WebContext.URL != "" {
		if domain := ee.extractDomainFromURL(vuln.WebContext.URL); domain != "" {
			domains = append(domains, domain)
		}
	}

	// Extract from description and evidence
	domainRegex := regexp.MustCompile(`\b[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*\b`)

	matches := domainRegex.FindAllString(vuln.Description, -1)
	domains = append(domains, matches...)

	// Deduplicate and validate domains
	return ee.deduplicateAndValidateDomains(domains)
}

func (ee *EnrichmentEngine) extractHashes(vuln *UnifiedVulnerability) []string {
	hashes := make([]string, 0)

	// Extract from container context
	if vuln.ContainerContext != nil && vuln.ContainerContext.ImageDigest != "" {
		hashes = append(hashes, vuln.ContainerContext.ImageDigest)
	}

	// Extract from description using various hash patterns
	md5Regex := regexp.MustCompile(`\b[a-fA-F0-9]{32}\b`)
	sha1Regex := regexp.MustCompile(`\b[a-fA-F0-9]{40}\b`)
	sha256Regex := regexp.MustCompile(`\b[a-fA-F0-9]{64}\b`)

	md5Matches := md5Regex.FindAllString(vuln.Description, -1)
	sha1Matches := sha1Regex.FindAllString(vuln.Description, -1)
	sha256Matches := sha256Regex.FindAllString(vuln.Description, -1)

	hashes = append(hashes, md5Matches...)
	hashes = append(hashes, sha1Matches...)
	hashes = append(hashes, sha256Matches...)

	return hashes
}

func (ee *EnrichmentEngine) extractURLs(vuln *UnifiedVulnerability) []string {
	urls := make([]string, 0)

	// Web context
	if vuln.WebContext != nil && vuln.WebContext.URL != "" {
		urls = append(urls, vuln.WebContext.URL)
	}

	// References
	urls = append(urls, vuln.References...)

	// Extract from description
	urlRegex := regexp.MustCompile(`https?://[^\s<>"{}|\\^` + "`" + `\[\]]+`)
	matches := urlRegex.FindAllString(vuln.Description, -1)
	urls = append(urls, matches...)

	return urls
}

func (ee *EnrichmentEngine) hasIPAddresses(vuln *UnifiedVulnerability) bool {
	return len(ee.extractIPAddresses(vuln)) > 0
}

func (ee *EnrichmentEngine) extractIPFromURL(urlStr string) string {
	u, err := url.Parse(urlStr)
	if err != nil {
		return ""
	}

	// Check if host is an IP address
	if ip := net.ParseIP(u.Hostname()); ip != nil {
		return ip.String()
	}

	return ""
}

func (ee *EnrichmentEngine) extractDomainFromURL(urlStr string) string {
	u, err := url.Parse(urlStr)
	if err != nil {
		return ""
	}

	// Check if host is a domain (not an IP)
	if ip := net.ParseIP(u.Hostname()); ip == nil {
		return u.Hostname()
	}

	return ""
}

func (ee *EnrichmentEngine) deduplicateAndValidateIPs(ips []string) []string {
	seen := make(map[string]bool)
	result := make([]string, 0)

	for _, ip := range ips {
		if !seen[ip] && net.ParseIP(ip) != nil {
			seen[ip] = true
			result = append(result, ip)
		}
	}

	return result
}

func (ee *EnrichmentEngine) deduplicateAndValidateDomains(domains []string) []string {
	seen := make(map[string]bool)
	result := make([]string, 0)

	for _, domain := range domains {
		if !seen[domain] && ee.isValidDomain(domain) {
			seen[domain] = true
			result = append(result, domain)
		}
	}

	return result
}

func (ee *EnrichmentEngine) isValidDomain(domain string) bool {
	// Basic domain validation
	if len(domain) == 0 || len(domain) > 253 {
		return false
	}

	// Check for valid domain format
	domainRegex := regexp.MustCompile(`^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$`)
	return domainRegex.MatchString(domain)
}

func (ee *EnrichmentEngine) mergeThreatIntelligence(target, source *ThreatIntelligence, sourceName string) {
	// Merge IOC matches
	target.IOCMatches = append(target.IOCMatches, source.IOCMatches...)

	// Merge threat actors
	target.ThreatActors = ee.mergeStringSlices(target.ThreatActors, source.ThreatActors)

	// Merge campaigns
	target.Campaigns = ee.mergeStringSlices(target.Campaigns, source.Campaigns)

	// Merge TTPs
	target.TTP = ee.mergeStringSlices(target.TTP, source.TTP)

	// Add source
	target.IntelligenceSources = append(target.IntelligenceSources, sourceName)

	// Update threat score (take maximum)
	if source.ThreatScore > target.ThreatScore {
		target.ThreatScore = source.ThreatScore
	}
}

func (ee *EnrichmentEngine) mergeStringSlices(slice1, slice2 []string) []string {
	seen := make(map[string]bool)
	result := make([]string, 0)

	// Add items from first slice
	for _, item := range slice1 {
		if !seen[item] {
			seen[item] = true
			result = append(result, item)
		}
	}

	// Add items from second slice
	for _, item := range slice2 {
		if !seen[item] {
			seen[item] = true
			result = append(result, item)
		}
	}

	return result
}

func (ee *EnrichmentEngine) calculateThreatRisk(geoData *GeoLocationData) float64 {
	// Calculate overall threat risk based on geo-location data
	riskScore := 0.0
	totalEntries := 0

	// Process IP addresses
	for _, ipInfo := range geoData.IPAddresses {
		if ipInfo.IsMalicious {
			riskScore += 1.0
		} else {
			riskScore += ee.getCountryRiskScore(ipInfo.CountryCode)
		}
		totalEntries++
	}

	// Process domains
	for _, domainInfo := range geoData.Domains {
		if domainInfo.IsMalicious {
			riskScore += 1.0
		} else {
			riskScore += ee.getCountryRiskScore(domainInfo.CountryCode)
		}
		totalEntries++
	}

	if totalEntries == 0 {
		return 0.0
	}

	return riskScore / float64(totalEntries)
}

func (ee *EnrichmentEngine) calculateCountryRisk(geoData *GeoLocationData) float64 {
	// Calculate country-specific risk
	countries := make(map[string]int)

	// Count countries from IP addresses
	for _, ipInfo := range geoData.IPAddresses {
		countries[ipInfo.CountryCode]++
	}

	// Count countries from domains
	for _, domainInfo := range geoData.Domains {
		countries[domainInfo.CountryCode]++
	}

	// Calculate weighted average risk
	totalRisk := 0.0
	totalCount := 0

	for countryCode, count := range countries {
		countryRisk := ee.getCountryRiskScore(countryCode)
		totalRisk += countryRisk * float64(count)
		totalCount += count
	}

	if totalCount == 0 {
		return 0.0
	}

	return totalRisk / float64(totalCount)
}

func (ee *EnrichmentEngine) getCountryRiskScore(countryCode string) float64 {
	// High-risk countries (simplified mapping)
	highRiskCountries := map[string]float64{
		"CN": 0.8, // China
		"RU": 0.9, // Russia
		"KP": 1.0, // North Korea
		"IR": 0.8, // Iran
	}

	if risk, exists := highRiskCountries[countryCode]; exists {
		return risk
	}

	return 0.1 // Default low risk for other countries
}

func (ee *EnrichmentEngine) determineWeaponizationStatus(exploitData *ExploitData) string {
	// Determine weaponization status based on available exploits
	if len(exploitData.PublicExploits) == 0 {
		return "not_weaponized"
	}

	// Check for verified exploits
	for _, exploit := range exploitData.PublicExploits {
		if exploit.Verified && exploit.Maturity == "functional" {
			return "weaponized"
		}
	}

	// Check for exploit kits
	if len(exploitData.ExploitKits) > 0 {
		return "weaponized"
	}

	return "potentially_weaponized"
}

func (ee *EnrichmentEngine) assessEnrichmentQuality(result *EnrichmentResult) EnrichmentQualityAssessment {
	assessment := EnrichmentQualityAssessment{
		QualityIssues:     make([]QualityIssue, 0),
		SourceCredibility: make(map[string]float64),
	}

	// Calculate freshness score
	assessment.FreshnessScore = ee.calculateFreshnessScore(result)

	// Calculate reliability score
	assessment.ReliabilityScore = ee.calculateReliabilityScore(result)

	// Calculate completeness score
	assessment.CompletenessScore = ee.calculateCompletenessScore(result)

	// Calculate accuracy score
	assessment.AccuracyScore = ee.calculateAccuracyScore(result)

	// Calculate overall score
	assessment.OverallScore = (assessment.FreshnessScore + assessment.ReliabilityScore +
		assessment.CompletenessScore + assessment.AccuracyScore) / 4.0

	// Calculate data confidence
	assessment.DataConfidence = ee.calculateDataConfidence(result)

	return assessment
}

func (ee *EnrichmentEngine) generateEnrichmentRecommendations(result *EnrichmentResult) []string {
	recommendations := make([]string, 0)

	// Low confidence recommendations
	if result.QualityAssessment.DataConfidence < 0.7 {
		recommendations = append(recommendations, "Consider manual validation due to low data confidence")
	}

	// Missing enrichment types
	if result.ThreatIntelligence == nil && ee.config.EnableThreatIntel {
		recommendations = append(recommendations, "Threat intelligence enrichment failed - consider alternative sources")
	}

	if result.BusinessContextData == nil && ee.config.EnableBusinessContext {
		recommendations = append(recommendations, "Business context missing - update asset metadata")
	}

	return recommendations
}

func (ee *EnrichmentEngine) validateEnrichmentResults(ctx context.Context, result *EnrichmentResult) []EnrichmentValidationResult {
	validationResults := make([]EnrichmentValidationResult, 0)

	// Validate threat intelligence
	if result.ThreatIntelligence != nil {
		validation := ee.validateThreatIntelligence(result.ThreatIntelligence)
		validationResults = append(validationResults, validation)
	}

	// Validate geo-location data
	if result.GeoLocationData != nil {
		validation := ee.validateGeoLocationData(result.GeoLocationData)
		validationResults = append(validationResults, validation)
	}

	return validationResults
}

func (ee *EnrichmentEngine) validateThreatIntelligence(threatIntel *ThreatIntelligence) EnrichmentValidationResult {
	// TODO: Implement threat intelligence validation
	return EnrichmentValidationResult{
		ValidationType:  "threat_intelligence",
		IsValid:         true,
		Confidence:      0.9,
		Issues:          make([]ValidationIssue, 0),
		Recommendations: make([]string, 0),
	}
}

func (ee *EnrichmentEngine) validateGeoLocationData(geoData *GeoLocationData) EnrichmentValidationResult {
	// TODO: Implement geo-location data validation
	return EnrichmentValidationResult{
		ValidationType:  "geo_location",
		IsValid:         true,
		Confidence:      0.85,
		Issues:          make([]ValidationIssue, 0),
		Recommendations: make([]string, 0),
	}
}

// Quality calculation methods (stubs)

func (ee *EnrichmentEngine) calculateFreshnessScore(result *EnrichmentResult) float64 {
	// TODO: Implement freshness score calculation
	return 0.8
}

func (ee *EnrichmentEngine) calculateReliabilityScore(result *EnrichmentResult) float64 {
	// TODO: Implement reliability score calculation
	return 0.85
}

func (ee *EnrichmentEngine) calculateCompletenessScore(result *EnrichmentResult) float64 {
	// TODO: Implement completeness score calculation
	return 0.9
}

func (ee *EnrichmentEngine) calculateAccuracyScore(result *EnrichmentResult) float64 {
	// TODO: Implement accuracy score calculation
	return 0.87
}

func (ee *EnrichmentEngine) calculateDataConfidence(result *EnrichmentResult) float64 {
	// TODO: Implement data confidence calculation
	return 0.85
}

func (ee *EnrichmentEngine) getUsedSources(result *EnrichmentResult) []string {
	sources := make([]string, 0)

	if result.ThreatIntelligence != nil {
		sources = append(sources, result.ThreatIntelligence.IntelligenceSources...)
	}

	return sources
}

func (ee *EnrichmentEngine) calculateCacheUtilization() float64 {
	totalRequests := ee.statistics.CacheHits + ee.statistics.CacheMisses
	if totalRequests == 0 {
		return 0.0
	}

	return float64(ee.statistics.CacheHits) / float64(totalRequests)
}

func (ee *EnrichmentEngine) generateCacheKey(vuln *UnifiedVulnerability, options EnrichmentOptions) string {
	// Generate a deterministic cache key
	return fmt.Sprintf("enrich_%s_%s_%.2f", vuln.ID, vuln.VulnerabilityHash, options.MinConfidence)
}

func (ee *EnrichmentEngine) updateStatistics(result *EnrichmentResult, processingTime time.Duration) {
	ee.mutex.Lock()
	defer ee.mutex.Unlock()

	ee.statistics.TotalEnrichments++

	if result.QualityAssessment.OverallScore > 0.5 {
		ee.statistics.SuccessfulEnrichments++
	} else {
		ee.statistics.FailedEnrichments++
	}

	// Update average processing time
	if ee.statistics.TotalEnrichments == 1 {
		ee.statistics.AverageProcessingTime = processingTime
	} else {
		total := ee.statistics.AverageProcessingTime * time.Duration(ee.statistics.TotalEnrichments-1)
		ee.statistics.AverageProcessingTime = (total + processingTime) / time.Duration(ee.statistics.TotalEnrichments)
	}

	ee.statistics.LastProcessed = time.Now()
}

// Stub implementations for service constructors (to be implemented)

func NewThreatIntelSource(name, endpoint, apiKey string, logger *slog.Logger) ThreatIntelSource {
	// TODO: Implement threat intel source
	return nil
}

func NewGeoLocationService(endpoint, apiKey string, logger *slog.Logger) GeoLocationService {
	// TODO: Implement geo-location service
	return nil
}

func NewBusinessContextService(logger *slog.Logger) BusinessContextService {
	// TODO: Implement business context service
	return nil
}

func NewComplianceService(logger *slog.Logger) ComplianceService {
	// TODO: Implement compliance service
	return nil
}

func NewExploitDBService(endpoint, apiKey string, logger *slog.Logger) ExploitDBService {
	// TODO: Implement exploit DB service
	return nil
}

func NewVendorAdvisoryService(endpoints map[string]string, apiKeys map[string]string, logger *slog.Logger) VendorAdvisoryService {
	// TODO: Implement vendor advisory service
	return nil
}

func NewInMemoryEnrichmentCache(maxSize int) EnrichmentCache {
	// TODO: Implement in-memory cache
	return nil
}

func NewTokenBucketRateLimiter(requestsPerSecond, burstSize int) RateLimiter {
	// TODO: Implement token bucket rate limiter
	return nil
}
