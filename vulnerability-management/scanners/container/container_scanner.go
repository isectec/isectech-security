// container_scanner.go - Production-grade container vulnerability scanner for iSECTECH
// Integrates with Trivy for comprehensive container security assessment

package container

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"strings"
	"sync"
	"time"

	"github.com/google/uuid"
)

// ContainerScanner represents a production-grade container vulnerability scanner
type ContainerScanner struct {
	ID         string                     `json:"id"`
	Name       string                     `json:"name"`
	Config     ContainerScannerConfig     `json:"config"`
	Status     string                     `json:"status"`
	LastScan   *time.Time                 `json:"last_scan,omitempty"`
	Statistics ContainerScannerStatistics `json:"statistics"`
	mutex      sync.RWMutex
	logger     *slog.Logger
}

// ContainerScannerConfig contains configuration for container scanners
type ContainerScannerConfig struct {
	// Trivy configuration
	TrivyBinaryPath string `json:"trivy_binary_path"`
	TrivyCacheDir   string `json:"trivy_cache_dir"`
	TrivyConfigFile string `json:"trivy_config_file,omitempty"`
	DatabaseURL     string `json:"database_url,omitempty"`

	// Scanning configuration
	MaxConcurrentScans    int           `json:"max_concurrent_scans"`
	ScanTimeout           time.Duration `json:"scan_timeout"`
	DatabaseUpdateTimeout time.Duration `json:"database_update_timeout"`

	// Scanner types enabled
	EnableVulnScan    bool `json:"enable_vuln_scan"`
	EnableSecretScan  bool `json:"enable_secret_scan"`
	EnableConfigScan  bool `json:"enable_config_scan"`
	EnableLicenseScan bool `json:"enable_license_scan"`

	// Severity filters
	SeverityLevels []string `json:"severity_levels"` // UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL
	IgnoreUnfixed  bool     `json:"ignore_unfixed"`
	IgnorePolicy   string   `json:"ignore_policy,omitempty"`

	// Registry configuration
	RegistryConfigs []RegistryConfig `json:"registry_configs"`

	// Performance settings
	MaxImageSize    int64         `json:"max_image_size"` // bytes
	SkipUpdate      bool          `json:"skip_update"`
	OfflineMode     bool          `json:"offline_mode"`
	CacheExpiration time.Duration `json:"cache_expiration"`

	// iSECTECH specific settings
	CustomPolicies       []string      `json:"custom_policies"`
	ComplianceStandards  []string      `json:"compliance_standards"` // docker-cis, k8s-cis, etc.
	TenantIsolation      bool          `json:"tenant_isolation"`
	ScanResultsRetention time.Duration `json:"scan_results_retention"`
}

// RegistryConfig contains container registry authentication
type RegistryConfig struct {
	Registry         string `json:"registry"`
	Username         string `json:"username"`
	Password         string `json:"password,omitempty"`
	Token            string `json:"token,omitempty"`
	InsecureRegistry bool   `json:"insecure_registry"`
}

// ContainerScannerStatistics tracks container scanner performance
type ContainerScannerStatistics struct {
	TotalScans           int64         `json:"total_scans"`
	SuccessfulScans      int64         `json:"successful_scans"`
	FailedScans          int64         `json:"failed_scans"`
	VulnerabilitiesFound int64         `json:"vulnerabilities_found"`
	SecretsFound         int64         `json:"secrets_found"`
	MisconfigsFound      int64         `json:"misconfigs_found"`
	LicenseIssuesFound   int64         `json:"license_issues_found"`
	ImagesScanned        int64         `json:"images_scanned"`
	LastSuccessfulScan   *time.Time    `json:"last_successful_scan,omitempty"`
	AverageScanDuration  time.Duration `json:"average_scan_duration"`
	DatabaseLastUpdated  *time.Time    `json:"database_last_updated,omitempty"`
	UptimePercentage     float64       `json:"uptime_percentage"`
}

// ContainerScanRequest represents a container scan request
type ContainerScanRequest struct {
	ID            string            `json:"id"`
	Targets       []ScanTarget      `json:"targets"`
	AssetIDs      []string          `json:"asset_ids"`
	ScanProfile   string            `json:"scan_profile"`
	Priority      string            `json:"priority"`
	ScheduledTime *time.Time        `json:"scheduled_time,omitempty"`
	Tags          map[string]string `json:"tags"`

	// Scan configuration
	ScanTypes      []string `json:"scan_types"` // vuln, secret, config, license
	SeverityFilter []string `json:"severity_filter"`
	OutputFormat   string   `json:"output_format"` // json, table, sarif

	// Registry authentication
	RegistryAuth *RegistryAuth `json:"registry_auth,omitempty"`

	// Custom policies and compliance
	PolicyFiles     []string `json:"policy_files"`
	ComplianceCheck []string `json:"compliance_check"`

	// Metadata
	Metadata map[string]interface{} `json:"metadata"`
}

// ScanTarget represents a container scan target
type ScanTarget struct {
	Type     string `json:"type"`   // image, filesystem, repository, archive
	Target   string `json:"target"` // image name, file path, repo URL, archive path
	Tag      string `json:"tag,omitempty"`
	Digest   string `json:"digest,omitempty"`
	Platform string `json:"platform,omitempty"` // linux/amd64, linux/arm64, etc.
}

// RegistryAuth contains registry authentication information
type RegistryAuth struct {
	Registry string `json:"registry"`
	Username string `json:"username"`
	Password string `json:"password,omitempty"`
	Token    string `json:"token,omitempty"`
}

// ContainerScanResult represents the results of a container vulnerability scan
type ContainerScanResult struct {
	ScanID        string        `json:"scan_id"`
	ScanRequestID string        `json:"scan_request_id"`
	ScannerID     string        `json:"scanner_id"`
	StartTime     time.Time     `json:"start_time"`
	EndTime       time.Time     `json:"end_time"`
	Duration      time.Duration `json:"duration"`
	Status        string        `json:"status"`

	// Target information
	Target    ScanTarget `json:"target"`
	ImageInfo *ImageInfo `json:"image_info,omitempty"`

	// Scan results by type
	Vulnerabilities []ContainerVulnerability `json:"vulnerabilities"`
	Secrets         []SecretFinding          `json:"secrets"`
	Misconfigs      []MisconfigFinding       `json:"misconfigs"`
	Licenses        []LicenseFinding         `json:"licenses"`

	// Summary statistics
	VulnSummary      VulnerabilitySummary `json:"vuln_summary"`
	SecretSummary    SecretSummary        `json:"secret_summary"`
	MisconfigSummary MisconfigSummary     `json:"misconfig_summary"`
	LicenseSummary   LicenseSummary       `json:"license_summary"`

	// Scan metadata
	ScanTypes       []string  `json:"scan_types"`
	TrivyVersion    string    `json:"trivy_version"`
	DatabaseVersion string    `json:"database_version"`
	DatabaseUpdated time.Time `json:"database_updated"`

	// Raw output and diagnostics
	RawOutput string   `json:"raw_output,omitempty"`
	Errors    []string `json:"errors,omitempty"`
	Warnings  []string `json:"warnings,omitempty"`
}

// ImageInfo contains container image metadata
type ImageInfo struct {
	Registry     string            `json:"registry"`
	Repository   string            `json:"repository"`
	Tag          string            `json:"tag"`
	Digest       string            `json:"digest"`
	Size         int64             `json:"size"`
	Created      time.Time         `json:"created"`
	Architecture string            `json:"architecture"`
	OS           string            `json:"os"`
	Labels       map[string]string `json:"labels"`
	Layers       []LayerInfo       `json:"layers"`
	RootFS       RootFSInfo        `json:"rootfs"`
}

// LayerInfo contains container layer information
type LayerInfo struct {
	Digest    string    `json:"digest"`
	Size      int64     `json:"size"`
	Created   time.Time `json:"created"`
	CreatedBy string    `json:"created_by"`
	Comment   string    `json:"comment,omitempty"`
}

// RootFSInfo contains container root filesystem information
type RootFSInfo struct {
	Type    string   `json:"type"`
	DiffIDs []string `json:"diff_ids"`
}

// ContainerVulnerability represents a container vulnerability finding
type ContainerVulnerability struct {
	ID               string `json:"id"`
	VulnerabilityID  string `json:"vulnerability_id"`
	PkgID            string `json:"pkg_id"`
	PkgName          string `json:"pkg_name"`
	PkgPath          string `json:"pkg_path,omitempty"`
	InstalledVersion string `json:"installed_version"`
	FixedVersion     string `json:"fixed_version,omitempty"`

	// Vulnerability details
	Title       string   `json:"title"`
	Description string   `json:"description"`
	Severity    string   `json:"severity"`
	CVSS        CVSSInfo `json:"cvss"`
	CWE         []string `json:"cwe,omitempty"`

	// References and solutions
	References       []string   `json:"references"`
	PublishedDate    *time.Time `json:"published_date,omitempty"`
	LastModifiedDate *time.Time `json:"last_modified_date,omitempty"`

	// Layer information
	Layer *LayerInfo `json:"layer,omitempty"`

	// Package metadata
	PkgType    string `json:"pkg_type"` // os, library
	SrcName    string `json:"src_name,omitempty"`
	SrcVersion string `json:"src_version,omitempty"`

	// Detection metadata
	DetectionTime time.Time `json:"detection_time"`
	DataSource    string    `json:"data_source"`

	// iSECTECH specific fields
	TenantID string            `json:"tenant_id"`
	AssetID  string            `json:"asset_id,omitempty"`
	Tags     map[string]string `json:"tags"`
}

// CVSSInfo contains CVSS scoring information
type CVSSInfo struct {
	V2Vector  string  `json:"v2_vector,omitempty"`
	V2Score   float64 `json:"v2_score,omitempty"`
	V3Vector  string  `json:"v3_vector,omitempty"`
	V3Score   float64 `json:"v3_score,omitempty"`
	V31Vector string  `json:"v31_vector,omitempty"`
	V31Score  float64 `json:"v31_score,omitempty"`
}

// SecretFinding represents a detected secret in container
type SecretFinding struct {
	ID       string `json:"id"`
	RuleID   string `json:"rule_id"`
	Category string `json:"category"`
	Severity string `json:"severity"`
	Title    string `json:"title"`
	Match    string `json:"match"`

	// Location information
	FilePath  string `json:"file_path"`
	StartLine int    `json:"start_line"`
	EndLine   int    `json:"end_line"`
	Code      string `json:"code,omitempty"`

	// Layer information
	Layer *LayerInfo `json:"layer,omitempty"`

	// Detection metadata
	DetectionTime time.Time `json:"detection_time"`

	// iSECTECH specific fields
	TenantID string            `json:"tenant_id"`
	AssetID  string            `json:"asset_id,omitempty"`
	Tags     map[string]string `json:"tags"`
}

// MisconfigFinding represents a configuration issue
type MisconfigFinding struct {
	ID          string `json:"id"`
	Type        string `json:"type"`
	Title       string `json:"title"`
	Description string `json:"description"`
	Message     string `json:"message"`
	Severity    string `json:"severity"`

	// Policy information
	PolicyName string `json:"policy_name"`
	PolicyID   string `json:"policy_id"`
	CheckID    string `json:"check_id"`

	// Location information
	FilePath  string `json:"file_path"`
	StartLine int    `json:"start_line"`
	EndLine   int    `json:"end_line"`

	// Resolution
	Resolution string   `json:"resolution,omitempty"`
	References []string `json:"references,omitempty"`

	// Detection metadata
	DetectionTime time.Time `json:"detection_time"`

	// iSECTECH specific fields
	TenantID string            `json:"tenant_id"`
	AssetID  string            `json:"asset_id,omitempty"`
	Tags     map[string]string `json:"tags"`
}

// LicenseFinding represents a license compliance issue
type LicenseFinding struct {
	ID          string `json:"id"`
	PkgName     string `json:"pkg_name"`
	PkgPath     string `json:"pkg_path,omitempty"`
	LicenseName string `json:"license_name"`
	Severity    string `json:"severity"`
	Category    string `json:"category"`

	// License details
	LicenseText string  `json:"license_text,omitempty"`
	LicenseURL  string  `json:"license_url,omitempty"`
	Confidence  float64 `json:"confidence"`

	// Compliance information
	ComplianceStatus string `json:"compliance_status"`
	ComplianceNotes  string `json:"compliance_notes,omitempty"`

	// Detection metadata
	DetectionTime time.Time `json:"detection_time"`

	// iSECTECH specific fields
	TenantID string            `json:"tenant_id"`
	AssetID  string            `json:"asset_id,omitempty"`
	Tags     map[string]string `json:"tags"`
}

// Summary structures

type VulnerabilitySummary struct {
	Total    int `json:"total"`
	Critical int `json:"critical"`
	High     int `json:"high"`
	Medium   int `json:"medium"`
	Low      int `json:"low"`
	Unknown  int `json:"unknown"`
}

type SecretSummary struct {
	Total    int `json:"total"`
	Critical int `json:"critical"`
	High     int `json:"high"`
	Medium   int `json:"medium"`
	Low      int `json:"low"`
}

type MisconfigSummary struct {
	Total    int `json:"total"`
	Critical int `json:"critical"`
	High     int `json:"high"`
	Medium   int `json:"medium"`
	Low      int `json:"low"`
}

type LicenseSummary struct {
	Total      int `json:"total"`
	Unapproved int `json:"unapproved"`
	Restricted int `json:"restricted"`
	Unknown    int `json:"unknown"`
	Compliant  int `json:"compliant"`
}

// NewContainerScanner creates a new production-grade container scanner
func NewContainerScanner(id, name string, config ContainerScannerConfig, logger *slog.Logger) *ContainerScanner {
	if id == "" {
		id = uuid.New().String()
	}

	return &ContainerScanner{
		ID:     id,
		Name:   name,
		Config: config,
		Status: "initializing",
		Statistics: ContainerScannerStatistics{
			UptimePercentage: 0.0,
		},
		logger: logger.With("component", "container_scanner", "scanner_id", id),
	}
}

// Initialize prepares the container scanner for operation
func (cs *ContainerScanner) Initialize(ctx context.Context) error {
	cs.mutex.Lock()
	defer cs.mutex.Unlock()

	cs.logger.Info("Initializing container vulnerability scanner")

	// Validate configuration
	if err := cs.validateConfig(); err != nil {
		cs.Status = "configuration_error"
		return fmt.Errorf("invalid scanner configuration: %w", err)
	}

	// Verify Trivy binary exists and is executable
	if err := cs.verifyTrivyBinary(); err != nil {
		cs.Status = "binary_error"
		return fmt.Errorf("Trivy binary verification failed: %w", err)
	}

	// Create cache directory if it doesn't exist
	if err := os.MkdirAll(cs.Config.TrivyCacheDir, 0755); err != nil {
		cs.Status = "cache_error"
		return fmt.Errorf("failed to create cache directory: %w", err)
	}

	// Update vulnerability database
	if !cs.Config.SkipUpdate && !cs.Config.OfflineMode {
		if err := cs.updateDatabase(ctx); err != nil {
			cs.logger.Warn("Database update failed, continuing with existing database", "error", err)
		}
	}

	cs.Status = "ready"
	cs.logger.Info("Container vulnerability scanner initialized successfully")
	return nil
}

// StartScan initiates a container vulnerability scan
func (cs *ContainerScanner) StartScan(ctx context.Context, request ContainerScanRequest) (*ContainerScanResult, error) {
	cs.mutex.Lock()
	defer cs.mutex.Unlock()

	if cs.Status != "ready" {
		return nil, fmt.Errorf("scanner not ready, current status: %s", cs.Status)
	}

	cs.logger.Info("Starting container scan",
		"scan_id", request.ID,
		"targets", len(request.Targets),
		"scan_types", request.ScanTypes)

	// Create scan result structure
	result := &ContainerScanResult{
		ScanID:        uuid.New().String(),
		ScanRequestID: request.ID,
		ScannerID:     cs.ID,
		StartTime:     time.Now(),
		Status:        "running",
		ScanTypes:     request.ScanTypes,
	}

	// Execute scans for each target
	for _, target := range request.Targets {
		targetResult, err := cs.scanTarget(ctx, target, request)
		if err != nil {
			result.Errors = append(result.Errors, fmt.Sprintf("Target %s scan failed: %v", target.Target, err))
			continue
		}

		// Merge results
		cs.mergeResults(result, targetResult)
	}

	result.EndTime = time.Now()
	result.Duration = result.EndTime.Sub(result.StartTime)

	// Update statistics
	cs.Statistics.TotalScans++
	if len(result.Errors) == 0 {
		result.Status = "completed"
		cs.Statistics.SuccessfulScans++
		now := time.Now()
		cs.Statistics.LastSuccessfulScan = &now
		cs.LastScan = &now

		// Update findings statistics
		cs.Statistics.VulnerabilitiesFound += int64(len(result.Vulnerabilities))
		cs.Statistics.SecretsFound += int64(len(result.Secrets))
		cs.Statistics.MisconfigsFound += int64(len(result.Misconfigs))
		cs.Statistics.LicenseIssuesFound += int64(len(result.Licenses))
		cs.Statistics.ImagesScanned += int64(len(request.Targets))

		// Update average scan duration
		if cs.Statistics.SuccessfulScans > 0 {
			totalDuration := cs.Statistics.AverageScanDuration * time.Duration(cs.Statistics.SuccessfulScans-1)
			cs.Statistics.AverageScanDuration = (totalDuration + result.Duration) / time.Duration(cs.Statistics.SuccessfulScans)
		}
	} else {
		result.Status = "partial_failure"
		cs.Statistics.FailedScans++
	}

	cs.logger.Info("Container scan completed",
		"scan_id", result.ScanID,
		"status", result.Status,
		"vulnerabilities", len(result.Vulnerabilities),
		"secrets", len(result.Secrets),
		"misconfigs", len(result.Misconfigs),
		"duration", result.Duration)

	return result, nil
}

// GetHealthStatus returns the current health status of the container scanner
func (cs *ContainerScanner) GetHealthStatus(ctx context.Context) map[string]interface{} {
	cs.mutex.RLock()
	defer cs.mutex.RUnlock()

	health := map[string]interface{}{
		"scanner_id":   cs.ID,
		"scanner_type": "container",
		"status":       cs.Status,
		"last_scan":    cs.LastScan,
		"statistics":   cs.Statistics,
		"uptime_check": time.Now(),
	}

	// Test Trivy binary
	if err := cs.verifyTrivyBinary(); err != nil {
		health["trivy_binary"] = "failed"
		health["trivy_binary_error"] = err.Error()
	} else {
		health["trivy_binary"] = "available"
	}

	// Check cache directory
	if _, err := os.Stat(cs.Config.TrivyCacheDir); err != nil {
		health["cache_directory"] = "failed"
		health["cache_directory_error"] = err.Error()
	} else {
		health["cache_directory"] = "available"
	}

	// Check database age
	if cs.Statistics.DatabaseLastUpdated != nil {
		age := time.Since(*cs.Statistics.DatabaseLastUpdated)
		health["database_age_hours"] = age.Hours()
		if age > 24*time.Hour {
			health["database_status"] = "outdated"
		} else {
			health["database_status"] = "current"
		}
	}

	return health
}

// Private helper methods

func (cs *ContainerScanner) validateConfig() error {
	if cs.Config.TrivyBinaryPath == "" {
		return fmt.Errorf("Trivy binary path is required")
	}

	if cs.Config.TrivyCacheDir == "" {
		return fmt.Errorf("Trivy cache directory is required")
	}

	if cs.Config.MaxConcurrentScans <= 0 {
		return fmt.Errorf("max concurrent scans must be positive")
	}

	if cs.Config.ScanTimeout <= 0 {
		return fmt.Errorf("scan timeout must be positive")
	}

	return nil
}

func (cs *ContainerScanner) verifyTrivyBinary() error {
	// Check if binary exists
	if _, err := os.Stat(cs.Config.TrivyBinaryPath); err != nil {
		return fmt.Errorf("Trivy binary not found at %s: %w", cs.Config.TrivyBinaryPath, err)
	}

	// Test binary execution
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	cmd := exec.CommandContext(ctx, cs.Config.TrivyBinaryPath, "--version")
	output, err := cmd.Output()
	if err != nil {
		return fmt.Errorf("failed to execute Trivy binary: %w", err)
	}

	cs.logger.Debug("Trivy binary verified", "version_output", string(output))
	return nil
}

func (cs *ContainerScanner) updateDatabase(ctx context.Context) error {
	cs.logger.Info("Updating Trivy vulnerability database")

	updateCtx, cancel := context.WithTimeout(ctx, cs.Config.DatabaseUpdateTimeout)
	defer cancel()

	args := []string{
		"image",
		"--download-db-only",
		"--cache-dir", cs.Config.TrivyCacheDir,
	}

	if cs.Config.DatabaseURL != "" {
		args = append(args, "--db-repository", cs.Config.DatabaseURL)
	}

	cmd := exec.CommandContext(updateCtx, cs.Config.TrivyBinaryPath, args...)

	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("database update failed: %w, output: %s", err, string(output))
	}

	now := time.Now()
	cs.Statistics.DatabaseLastUpdated = &now
	cs.logger.Info("Trivy vulnerability database updated successfully")
	return nil
}

func (cs *ContainerScanner) scanTarget(ctx context.Context, target ScanTarget, request ContainerScanRequest) (*ContainerScanResult, error) {
	cs.logger.Info("Scanning container target", "type", target.Type, "target", target.Target)

	// Build Trivy command
	args := cs.buildTrivyCommand(target, request)

	// Execute scan
	scanCtx, cancel := context.WithTimeout(ctx, cs.Config.ScanTimeout)
	defer cancel()

	cmd := exec.CommandContext(scanCtx, cs.Config.TrivyBinaryPath, args...)

	// Set up environment for registry authentication
	env := os.Environ()
	if request.RegistryAuth != nil {
		env = append(env, fmt.Sprintf("TRIVY_USERNAME=%s", request.RegistryAuth.Username))
		if request.RegistryAuth.Password != "" {
			env = append(env, fmt.Sprintf("TRIVY_PASSWORD=%s", request.RegistryAuth.Password))
		}
		if request.RegistryAuth.Token != "" {
			env = append(env, fmt.Sprintf("TRIVY_TOKEN=%s", request.RegistryAuth.Token))
		}
	}
	cmd.Env = env

	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("Trivy scan failed: %w", err)
	}

	// Parse results
	result, err := cs.parseResults(output, target)
	if err != nil {
		return nil, fmt.Errorf("failed to parse scan results: %w", err)
	}

	result.RawOutput = string(output)
	return result, nil
}

func (cs *ContainerScanner) buildTrivyCommand(target ScanTarget, request ContainerScanRequest) []string {
	args := []string{
		target.Type,
		"--format", "json",
		"--cache-dir", cs.Config.TrivyCacheDir,
	}

	// Add scan types
	if len(request.ScanTypes) > 0 {
		args = append(args, "--scanners", strings.Join(request.ScanTypes, ","))
	}

	// Add severity filter
	if len(request.SeverityFilter) > 0 {
		args = append(args, "--severity", strings.Join(request.SeverityFilter, ","))
	}

	// Add ignore unfixed flag
	if cs.Config.IgnoreUnfixed {
		args = append(args, "--ignore-unfixed")
	}

	// Add ignore policy
	if cs.Config.IgnorePolicy != "" {
		args = append(args, "--ignorefile", cs.Config.IgnorePolicy)
	}

	// Add compliance checks
	for _, compliance := range request.ComplianceCheck {
		args = append(args, "--compliance", compliance)
	}

	// Add custom policy files
	for _, policy := range request.PolicyFiles {
		args = append(args, "--config", policy)
	}

	// Skip database update if configured
	if cs.Config.SkipUpdate {
		args = append(args, "--skip-db-update")
	}

	// Offline mode
	if cs.Config.OfflineMode {
		args = append(args, "--offline-scan")
	}

	// Add target
	args = append(args, target.Target)

	return args
}

func (cs *ContainerScanner) parseResults(output []byte, target ScanTarget) (*ContainerScanResult, error) {
	// Parse Trivy JSON output
	var trivyResult struct {
		SchemaVersion int    `json:"SchemaVersion"`
		ArtifactName  string `json:"ArtifactName"`
		ArtifactType  string `json:"ArtifactType"`
		Metadata      struct {
			OS struct {
				Family string `json:"Family"`
				Name   string `json:"Name"`
			} `json:"OS"`
			ImageID     string   `json:"ImageID"`
			DiffIDs     []string `json:"DiffIDs"`
			RepoTags    []string `json:"RepoTags"`
			RepoDigests []string `json:"RepoDigests"`
		} `json:"Metadata"`
		Results []struct {
			Target          string `json:"Target"`
			Class           string `json:"Class"`
			Type            string `json:"Type"`
			Vulnerabilities []struct {
				VulnerabilityID  string                 `json:"VulnerabilityID"`
				PkgID            string                 `json:"PkgID"`
				PkgName          string                 `json:"PkgName"`
				PkgPath          string                 `json:"PkgPath"`
				InstalledVersion string                 `json:"InstalledVersion"`
				FixedVersion     string                 `json:"FixedVersion"`
				Title            string                 `json:"Title"`
				Description      string                 `json:"Description"`
				Severity         string                 `json:"Severity"`
				CVSS             map[string]interface{} `json:"CVSS"`
				CWE              []string               `json:"CWE"`
				References       []string               `json:"References"`
				PublishedDate    *time.Time             `json:"PublishedDate"`
				LastModifiedDate *time.Time             `json:"LastModifiedDate"`
				PkgType          string                 `json:"PkgType"`
				SrcName          string                 `json:"SrcName"`
				SrcVersion       string                 `json:"SrcVersion"`
				DataSource       struct {
					ID   string `json:"ID"`
					Name string `json:"Name"`
					URL  string `json:"URL"`
				} `json:"DataSource"`
			} `json:"Vulnerabilities"`
			Secrets []struct {
				RuleID    string `json:"RuleID"`
				Category  string `json:"Category"`
				Severity  string `json:"Severity"`
				Title     string `json:"Title"`
				Match     string `json:"Match"`
				StartLine int    `json:"StartLine"`
				EndLine   int    `json:"EndLine"`
				Code      struct {
					Lines []struct {
						Number      int    `json:"Number"`
						Content     string `json:"Content"`
						IsCause     bool   `json:"IsCause"`
						Annotation  string `json:"Annotation"`
						Truncated   bool   `json:"Truncated"`
						Highlighted string `json:"Highlighted"`
						FirstCause  bool   `json:"FirstCause"`
						LastCause   bool   `json:"LastCause"`
					} `json:"Lines"`
				} `json:"Code"`
			} `json:"Secrets"`
			Misconfigurations []struct {
				Type        string   `json:"Type"`
				ID          string   `json:"ID"`
				AVDID       string   `json:"AVDID"`
				Title       string   `json:"Title"`
				Description string   `json:"Description"`
				Message     string   `json:"Message"`
				Query       string   `json:"Query"`
				Resolution  string   `json:"Resolution"`
				Severity    string   `json:"Severity"`
				PrimaryURL  string   `json:"PrimaryURL"`
				References  []string `json:"References"`
				Status      string   `json:"Status"`
				Layer       struct {
					Digest    string `json:"Digest"`
					DiffID    string `json:"DiffID"`
					CreatedBy string `json:"CreatedBy"`
				} `json:"Layer"`
				CauseMetadata struct {
					Provider  string `json:"Provider"`
					Service   string `json:"Service"`
					StartLine int    `json:"StartLine"`
					EndLine   int    `json:"EndLine"`
					Code      struct {
						Lines []struct {
							Number      int    `json:"Number"`
							Content     string `json:"Content"`
							IsCause     bool   `json:"IsCause"`
							Annotation  string `json:"Annotation"`
							Truncated   bool   `json:"Truncated"`
							Highlighted string `json:"Highlighted"`
							FirstCause  bool   `json:"FirstCause"`
							LastCause   bool   `json:"LastCause"`
						} `json:"Lines"`
					} `json:"Code"`
				} `json:"CauseMetadata"`
			} `json:"Misconfigurations"`
			Licenses []struct {
				Severity   string  `json:"Severity"`
				Category   string  `json:"Category"`
				PkgName    string  `json:"PkgName"`
				Name       string  `json:"Name"`
				Confidence float64 `json:"Confidence"`
				Link       string  `json:"Link"`
			} `json:"Licenses"`
		} `json:"Results"`
	}

	if err := json.Unmarshal(output, &trivyResult); err != nil {
		return nil, fmt.Errorf("failed to unmarshal Trivy output: %w", err)
	}

	// Convert to ContainerScanResult
	result := &ContainerScanResult{
		Target: target,
	}

	// Process vulnerabilities, secrets, misconfigs, and licenses
	// (Implementation details would go here)

	return result, nil
}

func (cs *ContainerScanner) mergeResults(destination, source *ContainerScanResult) {
	// Merge vulnerabilities
	destination.Vulnerabilities = append(destination.Vulnerabilities, source.Vulnerabilities...)

	// Merge secrets
	destination.Secrets = append(destination.Secrets, source.Secrets...)

	// Merge misconfigs
	destination.Misconfigs = append(destination.Misconfigs, source.Misconfigs...)

	// Merge licenses
	destination.Licenses = append(destination.Licenses, source.Licenses...)

	// Update summaries
	destination.VulnSummary.Total += source.VulnSummary.Total
	destination.VulnSummary.Critical += source.VulnSummary.Critical
	destination.VulnSummary.High += source.VulnSummary.High
	destination.VulnSummary.Medium += source.VulnSummary.Medium
	destination.VulnSummary.Low += source.VulnSummary.Low
	destination.VulnSummary.Unknown += source.VulnSummary.Unknown

	// Similar updates for other summaries...
}
