package reporting

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"time"

	"go.uber.org/zap"
)

// ComplianceFramework defines supported frameworks
type ComplianceFramework string

const (
	FrameworkSOC2     ComplianceFramework = "soc2"
	FrameworkISO27001 ComplianceFramework = "iso27001"
	FrameworkNIST     ComplianceFramework = "nist"
	FrameworkPCIDSS   ComplianceFramework = "pci_dss"
	FrameworkHIPAA    ComplianceFramework = "hipaa"
	FrameworkGDPR     ComplianceFramework = "gdpr"
	FrameworkFERPA    ComplianceFramework = "ferpa"
	FrameworkSOX      ComplianceFramework = "sox"
	FrameworkCMMC     ComplianceFramework = "cmmc"
	FrameworkFedRAMP  ComplianceFramework = "fedramp"
)

// ComplianceStatus defines compliance states
type ComplianceStatus string

const (
	StatusCompliant    ComplianceStatus = "compliant"
	StatusNonCompliant ComplianceStatus = "non_compliant"
	StatusPartial      ComplianceStatus = "partial"
	StatusUnknown      ComplianceStatus = "unknown"
	StatusExempt       ComplianceStatus = "exempt"
	StatusInProgress   ComplianceStatus = "in_progress"
)

// ComplianceReport represents a compliance assessment report
type ComplianceReport struct {
	ID              string                     `json:"id" db:"id"`
	TenantID        string                     `json:"tenant_id" db:"tenant_id"`
	Framework       ComplianceFramework        `json:"framework" db:"framework"`
	Version         string                     `json:"version" db:"version"`
	Title           string                     `json:"title" db:"title"`
	Description     string                     `json:"description" db:"description"`
	Period          *DateRange                 `json:"period" db:"period"`
	Status          ComplianceStatus           `json:"status" db:"status"`
	OverallScore    float64                    `json:"overall_score" db:"overall_score"`
	Controls        []ControlAssessment        `json:"controls" db:"controls"`
	Domains         []DomainAssessment         `json:"domains" db:"domains"`
	Findings        []ComplianceFinding        `json:"findings" db:"findings"`
	Gaps            []ComplianceGap            `json:"gaps" db:"gaps"`
	Recommendations []ComplianceRecommendation `json:"recommendations" db:"recommendations"`
	Evidence        []ComplianceEvidence       `json:"evidence" db:"evidence"`
	Attestations    []Attestation              `json:"attestations" db:"attestations"`
	Metadata        map[string]interface{}     `json:"metadata,omitempty" db:"metadata"`
	GeneratedAt     time.Time                  `json:"generated_at" db:"generated_at"`
	GeneratedBy     string                     `json:"generated_by" db:"generated_by"`
	ReviewedAt      *time.Time                 `json:"reviewed_at,omitempty" db:"reviewed_at"`
	ReviewedBy      string                     `json:"reviewed_by,omitempty" db:"reviewed_by"`
	ApprovedAt      *time.Time                 `json:"approved_at,omitempty" db:"approved_at"`
	ApprovedBy      string                     `json:"approved_by,omitempty" db:"approved_by"`
	ExpiresAt       *time.Time                 `json:"expires_at,omitempty" db:"expires_at"`
}

// ControlAssessment represents assessment of a specific control
type ControlAssessment struct {
	ID               string                 `json:"id"`
	ControlID        string                 `json:"control_id"`
	Name             string                 `json:"name"`
	Description      string                 `json:"description"`
	Category         string                 `json:"category"`
	Priority         string                 `json:"priority"`
	Status           ComplianceStatus       `json:"status"`
	Score            float64                `json:"score"`
	Evidence         []string               `json:"evidence"`
	Gaps             []string               `json:"gaps"`
	Implementation   *ImplementationStatus  `json:"implementation"`
	Testing          *TestingResults        `json:"testing"`
	Remediation      *RemediationPlan       `json:"remediation,omitempty"`
	LastAssessed     time.Time              `json:"last_assessed"`
	NextAssessment   time.Time              `json:"next_assessment"`
	ResponsibleParty string                 `json:"responsible_party"`
	Notes            string                 `json:"notes,omitempty"`
	Metadata         map[string]interface{} `json:"metadata,omitempty"`
}

// ImplementationStatus tracks control implementation
type ImplementationStatus struct {
	Level        string     `json:"level"`    // not_implemented, partial, implemented, optimized
	Progress     float64    `json:"progress"` // 0-1
	StartDate    time.Time  `json:"start_date"`
	TargetDate   time.Time  `json:"target_date"`
	CompletedAt  *time.Time `json:"completed_at,omitempty"`
	Milestones   []string   `json:"milestones"`
	Blockers     []string   `json:"blockers,omitempty"`
	Dependencies []string   `json:"dependencies,omitempty"`
}

// TestingResults contains control testing outcomes
type TestingResults struct {
	TestType      string                 `json:"test_type"` // manual, automated, hybrid
	TestDate      time.Time              `json:"test_date"`
	TestBy        string                 `json:"test_by"`
	Result        string                 `json:"result"`        // pass, fail, not_applicable
	Effectiveness string                 `json:"effectiveness"` // effective, ineffective, deficient
	Frequency     string                 `json:"frequency"`     // annual, quarterly, monthly, continuous
	Coverage      float64                `json:"coverage"`      // 0-1
	SampleSize    int                    `json:"sample_size"`
	Exceptions    []TestException        `json:"exceptions,omitempty"`
	Evidence      []string               `json:"evidence"`
	Notes         string                 `json:"notes,omitempty"`
	NextTest      time.Time              `json:"next_test"`
	Metadata      map[string]interface{} `json:"metadata,omitempty"`
}

// TestException represents testing exceptions
type TestException struct {
	ID          string    `json:"id"`
	Type        string    `json:"type"`
	Description string    `json:"description"`
	Impact      string    `json:"impact"`
	Risk        string    `json:"risk"`
	Mitigation  string    `json:"mitigation"`
	Status      string    `json:"status"`
	DueDate     time.Time `json:"due_date"`
	Owner       string    `json:"owner"`
}

// RemediationPlan defines remediation activities
type RemediationPlan struct {
	ID              string          `json:"id"`
	Priority        string          `json:"priority"`
	Activities      []Activity      `json:"activities"`
	Timeline        *Timeline       `json:"timeline"`
	Resources       []Resource      `json:"resources"`
	Dependencies    []string        `json:"dependencies"`
	RiskAssessment  *RiskAssessment `json:"risk_assessment"`
	SuccessCriteria []string        `json:"success_criteria"`
	Owner           string          `json:"owner"`
	Stakeholders    []string        `json:"stakeholders"`
	Status          string          `json:"status"`
	Progress        float64         `json:"progress"`
	CompletedAt     *time.Time      `json:"completed_at,omitempty"`
}

// Activity defines remediation activities
type Activity struct {
	ID           string        `json:"id"`
	Name         string        `json:"name"`
	Description  string        `json:"description"`
	Type         string        `json:"type"`
	Owner        string        `json:"owner"`
	Duration     time.Duration `json:"duration"`
	Dependencies []string      `json:"dependencies"`
	Status       string        `json:"status"`
	StartDate    time.Time     `json:"start_date"`
	EndDate      time.Time     `json:"end_date"`
	CompletedAt  *time.Time    `json:"completed_at,omitempty"`
	Notes        string        `json:"notes,omitempty"`
}

// DomainAssessment represents domain-level assessment
type DomainAssessment struct {
	ID            string                 `json:"id"`
	Name          string                 `json:"name"`
	Description   string                 `json:"description"`
	Controls      []string               `json:"controls"`
	Status        ComplianceStatus       `json:"status"`
	Score         float64                `json:"score"`
	Maturity      string                 `json:"maturity"`      // ad_hoc, defined, managed, optimized
	Coverage      float64                `json:"coverage"`      // 0-1
	Effectiveness float64                `json:"effectiveness"` // 0-1
	RiskLevel     string                 `json:"risk_level"`
	Trends        map[string]interface{} `json:"trends,omitempty"`
	LastUpdated   time.Time              `json:"last_updated"`
}

// ComplianceFinding represents compliance issues
type ComplianceFinding struct {
	ID                 string                 `json:"id"`
	Type               string                 `json:"type"`     // deficiency, observation, recommendation
	Severity           string                 `json:"severity"` // low, medium, high, critical
	ControlID          string                 `json:"control_id"`
	Title              string                 `json:"title"`
	Description        string                 `json:"description"`
	Impact             string                 `json:"impact"`
	Likelihood         string                 `json:"likelihood"`
	RiskScore          float64                `json:"risk_score"`
	Evidence           []string               `json:"evidence"`
	Criteria           string                 `json:"criteria"`
	Recommendation     string                 `json:"recommendation"`
	ManagementResponse string                 `json:"management_response,omitempty"`
	Status             string                 `json:"status"` // open, in_progress, closed
	DueDate            time.Time              `json:"due_date"`
	ResponsibleParty   string                 `json:"responsible_party"`
	CreatedAt          time.Time              `json:"created_at"`
	UpdatedAt          time.Time              `json:"updated_at"`
	ResolvedAt         *time.Time             `json:"resolved_at,omitempty"`
	Metadata           map[string]interface{} `json:"metadata,omitempty"`
}

// ComplianceGap represents compliance gaps
type ComplianceGap struct {
	ID            string                 `json:"id"`
	ControlID     string                 `json:"control_id"`
	Type          string                 `json:"type"` // policy, process, technology, documentation
	Category      string                 `json:"category"`
	Title         string                 `json:"title"`
	Description   string                 `json:"description"`
	CurrentState  string                 `json:"current_state"`
	RequiredState string                 `json:"required_state"`
	Priority      string                 `json:"priority"`
	Effort        string                 `json:"effort"`
	Cost          *float64               `json:"cost,omitempty"`
	Timeline      string                 `json:"timeline"`
	Dependencies  []string               `json:"dependencies"`
	Risks         []string               `json:"risks"`
	Mitigation    string                 `json:"mitigation"`
	Owner         string                 `json:"owner"`
	Status        string                 `json:"status"`
	TargetDate    time.Time              `json:"target_date"`
	CompletedAt   *time.Time             `json:"completed_at,omitempty"`
	Metadata      map[string]interface{} `json:"metadata,omitempty"`
}

// ComplianceRecommendation provides improvement guidance
type ComplianceRecommendation struct {
	ID             string                 `json:"id"`
	Type           string                 `json:"type"`
	Priority       string                 `json:"priority"`
	Title          string                 `json:"title"`
	Description    string                 `json:"description"`
	Rationale      string                 `json:"rationale"`
	Benefits       []string               `json:"benefits"`
	Implementation *ImplementationGuide   `json:"implementation"`
	Effort         string                 `json:"effort"`
	Cost           *float64               `json:"cost,omitempty"`
	Timeline       string                 `json:"timeline"`
	Dependencies   []string               `json:"dependencies"`
	Risks          []string               `json:"risks"`
	SuccessMetrics []string               `json:"success_metrics"`
	References     []string               `json:"references"`
	Status         string                 `json:"status"`
	AcceptedAt     *time.Time             `json:"accepted_at,omitempty"`
	ImplementedAt  *time.Time             `json:"implemented_at,omitempty"`
	Metadata       map[string]interface{} `json:"metadata,omitempty"`
}

// ComplianceEvidence represents supporting evidence
type ComplianceEvidence struct {
	ID           string                 `json:"id"`
	ControlID    string                 `json:"control_id"`
	Type         string                 `json:"type"` // document, screenshot, log, certificate
	Category     string                 `json:"category"`
	Title        string                 `json:"title"`
	Description  string                 `json:"description"`
	Source       string                 `json:"source"`
	Location     string                 `json:"location"`
	Format       string                 `json:"format"`
	Size         int64                  `json:"size,omitempty"`
	Hash         string                 `json:"hash,omitempty"`
	Version      string                 `json:"version,omitempty"`
	CreatedAt    time.Time              `json:"created_at"`
	ValidFrom    time.Time              `json:"valid_from"`
	ValidTo      *time.Time             `json:"valid_to,omitempty"`
	Integrity    bool                   `json:"integrity"`
	Authenticity bool                   `json:"authenticity"`
	CollectedBy  string                 `json:"collected_by"`
	ReviewedBy   string                 `json:"reviewed_by,omitempty"`
	ReviewedAt   *time.Time             `json:"reviewed_at,omitempty"`
	Tags         []string               `json:"tags,omitempty"`
	Metadata     map[string]interface{} `json:"metadata,omitempty"`
}

// Attestation represents management attestations
type Attestation struct {
	ID               string                 `json:"id"`
	Type             string                 `json:"type"` // control, domain, framework
	Scope            string                 `json:"scope"`
	Statement        string                 `json:"statement"`
	Attestor         string                 `json:"attestor"`
	Role             string                 `json:"role"`
	Date             time.Time              `json:"date"`
	Period           *DateRange             `json:"period"`
	Conditions       []string               `json:"conditions,omitempty"`
	Limitations      []string               `json:"limitations,omitempty"`
	Signature        string                 `json:"signature,omitempty"`
	DigitalSignature string                 `json:"digital_signature,omitempty"`
	WitnessedBy      string                 `json:"witnessed_by,omitempty"`
	Status           string                 `json:"status"`
	Metadata         map[string]interface{} `json:"metadata,omitempty"`
}

// ComplianceReporter manages compliance reporting
type ComplianceReporter struct {
	db         *sql.DB
	logger     *zap.Logger
	config     *ComplianceConfig
	frameworks map[ComplianceFramework]*FrameworkDefinition
	assessors  map[string]ComplianceAssessor
	collectors []EvidenceCollector
	validators []EvidenceValidator
}

// ComplianceConfig defines reporter configuration
type ComplianceConfig struct {
	SupportedFrameworks   []ComplianceFramework `json:"supported_frameworks"`
	DefaultFramework      ComplianceFramework   `json:"default_framework"`
	AssessmentFrequency   time.Duration         `json:"assessment_frequency"`
	EvidenceRetention     time.Duration         `json:"evidence_retention"`
	AutoAssessmentEnabled bool                  `json:"auto_assessment_enabled"`
	ContinuousMonitoring  bool                  `json:"continuous_monitoring"`
	RequireAttestation    bool                  `json:"require_attestation"`
	DigitalSignatures     bool                  `json:"digital_signatures"`
	AuditLogging          bool                  `json:"audit_logging"`
	EncryptEvidence       bool                  `json:"encrypt_evidence"`
}

// FrameworkDefinition defines compliance framework structure
type FrameworkDefinition struct {
	ID           ComplianceFramework    `json:"id"`
	Name         string                 `json:"name"`
	Version      string                 `json:"version"`
	Description  string                 `json:"description"`
	Domains      []Domain               `json:"domains"`
	Controls     []Control              `json:"controls"`
	Requirements []Requirement          `json:"requirements"`
	Mappings     map[string]interface{} `json:"mappings,omitempty"`
	References   []string               `json:"references"`
	LastUpdated  time.Time              `json:"last_updated"`
}

// Domain represents compliance domains
type Domain struct {
	ID          string   `json:"id"`
	Name        string   `json:"name"`
	Description string   `json:"description"`
	Controls    []string `json:"controls"`
	Weight      float64  `json:"weight"`
}

// Control represents compliance controls
type Control struct {
	ID             string                 `json:"id"`
	Name           string                 `json:"name"`
	Description    string                 `json:"description"`
	Objective      string                 `json:"objective"`
	Category       string                 `json:"category"`
	Type           string                 `json:"type"`           // preventive, detective, corrective
	Implementation string                 `json:"implementation"` // manual, automated, hybrid
	Frequency      string                 `json:"frequency"`
	Priority       string                 `json:"priority"`
	Requirements   []string               `json:"requirements"`
	EvidenceTypes  []string               `json:"evidence_types"`
	Testing        *TestingRequirements   `json:"testing"`
	Weight         float64                `json:"weight"`
	Metadata       map[string]interface{} `json:"metadata,omitempty"`
}

// Requirement represents specific requirements
type Requirement struct {
	ID          string   `json:"id"`
	ControlID   string   `json:"control_id"`
	Description string   `json:"description"`
	Type        string   `json:"type"`
	Mandatory   bool     `json:"mandatory"`
	Criteria    []string `json:"criteria"`
	Examples    []string `json:"examples,omitempty"`
}

// TestingRequirements defines testing specifications
type TestingRequirements struct {
	Type          string   `json:"type"`
	Frequency     string   `json:"frequency"`
	Methods       []string `json:"methods"`
	SampleSize    string   `json:"sample_size"`
	Criteria      []string `json:"criteria"`
	Documentation []string `json:"documentation"`
}

// ComplianceAssessor interface for assessments
type ComplianceAssessor interface {
	Assess(ctx context.Context, tenantID string, framework ComplianceFramework) (*ComplianceReport, error)
	AssessControl(ctx context.Context, tenantID string, controlID string) (*ControlAssessment, error)
	GetSupportedFrameworks() []ComplianceFramework
	GetAssessmentFrequency() time.Duration
}

// EvidenceCollector interface for evidence collection
type EvidenceCollector interface {
	Collect(ctx context.Context, tenantID string, controlID string) ([]*ComplianceEvidence, error)
	GetSupportedEvidenceTypes() []string
	GetCollectionSchedule() string
}

// EvidenceValidator interface for evidence validation
type EvidenceValidator interface {
	Validate(ctx context.Context, evidence *ComplianceEvidence) (*ValidationResult, error)
	GetValidationCriteria() []string
}

// ValidationResult represents evidence validation outcome
type ValidationResult struct {
	Valid       bool                   `json:"valid"`
	Score       float64                `json:"score"`
	Issues      []ValidationIssue      `json:"issues,omitempty"`
	Metadata    map[string]interface{} `json:"metadata,omitempty"`
	ValidatedAt time.Time              `json:"validated_at"`
	ValidatedBy string                 `json:"validated_by"`
}

// ValidationIssue represents validation problems
type ValidationIssue struct {
	Type        string `json:"type"`
	Severity    string `json:"severity"`
	Description string `json:"description"`
	Field       string `json:"field,omitempty"`
	Suggestion  string `json:"suggestion,omitempty"`
}

// NewComplianceReporter creates a new compliance reporter
func NewComplianceReporter(db *sql.DB, logger *zap.Logger, config *ComplianceConfig) *ComplianceReporter {
	reporter := &ComplianceReporter{
		db:         db,
		logger:     logger,
		config:     config,
		frameworks: make(map[ComplianceFramework]*FrameworkDefinition),
		assessors:  make(map[string]ComplianceAssessor),
		collectors: []EvidenceCollector{},
		validators: []EvidenceValidator{},
	}

	// Load framework definitions
	reporter.loadFrameworkDefinitions()

	// Register default assessors
	reporter.RegisterAssessor("default", NewDefaultComplianceAssessor(db, logger))

	return reporter
}

// RegisterAssessor registers a compliance assessor
func (cr *ComplianceReporter) RegisterAssessor(name string, assessor ComplianceAssessor) {
	cr.assessors[name] = assessor
}

// GenerateComplianceReport generates a comprehensive compliance report
func (cr *ComplianceReporter) GenerateComplianceReport(ctx context.Context, tenantID string, framework ComplianceFramework) (*ComplianceReport, error) {
	// Get framework definition
	frameworkDef, exists := cr.frameworks[framework]
	if !exists {
		return nil, fmt.Errorf("unsupported framework: %s", framework)
	}

	// Run assessment
	assessor := cr.assessors["default"]
	report, err := assessor.Assess(ctx, tenantID, framework)
	if err != nil {
		return nil, fmt.Errorf("assessment failed: %w", err)
	}

	// Enhance report with additional data
	if err := cr.enhanceReport(ctx, report, frameworkDef); err != nil {
		cr.logger.Warn("Failed to enhance report", zap.Error(err))
	}

	// Store report
	if err := cr.storeComplianceReport(ctx, report); err != nil {
		cr.logger.Warn("Failed to store compliance report", zap.Error(err))
	}

	cr.logger.Info("Compliance report generated",
		zap.String("report_id", report.ID),
		zap.String("framework", string(framework)),
		zap.Float64("score", report.OverallScore))

	return report, nil
}

// GetComplianceStatus returns current compliance status
func (cr *ComplianceReporter) GetComplianceStatus(ctx context.Context, tenantID string, framework ComplianceFramework) (*ComplianceStatus, error) {
	// Get latest report
	report, err := cr.getLatestReport(ctx, tenantID, framework)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest report: %w", err)
	}

	return &report.Status, nil
}

// TrackCompliance monitors ongoing compliance
func (cr *ComplianceReporter) TrackCompliance(ctx context.Context, tenantID string) error {
	if !cr.config.ContinuousMonitoring {
		return nil
	}

	for _, framework := range cr.config.SupportedFrameworks {
		go func(fw ComplianceFramework) {
			if err := cr.performContinuousAssessment(ctx, tenantID, fw); err != nil {
				cr.logger.Warn("Continuous assessment failed",
					zap.String("framework", string(fw)),
					zap.Error(err))
			}
		}(framework)
	}

	return nil
}

// Helper methods

func (cr *ComplianceReporter) loadFrameworkDefinitions() {
	// Load framework definitions from configuration or database
	// This would typically load from external sources or embedded data

	// Example: SOC 2 framework
	soc2 := &FrameworkDefinition{
		ID:          FrameworkSOC2,
		Name:        "SOC 2",
		Version:     "2017",
		Description: "Service Organization Control 2",
		Domains: []Domain{
			{ID: "security", Name: "Security", Description: "Security controls"},
			{ID: "availability", Name: "Availability", Description: "Availability controls"},
			{ID: "processing_integrity", Name: "Processing Integrity", Description: "Processing integrity controls"},
			{ID: "confidentiality", Name: "Confidentiality", Description: "Confidentiality controls"},
			{ID: "privacy", Name: "Privacy", Description: "Privacy controls"},
		},
		Controls:    []Control{}, // Would be populated with actual controls
		LastUpdated: time.Now(),
	}
	cr.frameworks[FrameworkSOC2] = soc2

	// Additional frameworks would be loaded similarly
}

func (cr *ComplianceReporter) enhanceReport(ctx context.Context, report *ComplianceReport, framework *FrameworkDefinition) error {
	// Collect additional evidence
	for _, control := range report.Controls {
		evidence, err := cr.collectEvidence(ctx, report.TenantID, control.ControlID)
		if err != nil {
			cr.logger.Warn("Failed to collect evidence",
				zap.String("control", control.ControlID),
				zap.Error(err))
			continue
		}
		report.Evidence = append(report.Evidence, evidence...)
	}

	// Generate recommendations
	recommendations := cr.generateRecommendations(report)
	report.Recommendations = append(report.Recommendations, recommendations...)

	return nil
}

func (cr *ComplianceReporter) collectEvidence(ctx context.Context, tenantID string, controlID string) ([]*ComplianceEvidence, error) {
	var allEvidence []*ComplianceEvidence

	for _, collector := range cr.collectors {
		evidence, err := collector.Collect(ctx, tenantID, controlID)
		if err != nil {
			continue
		}
		allEvidence = append(allEvidence, evidence...)
	}

	return allEvidence, nil
}

func (cr *ComplianceReporter) generateRecommendations(report *ComplianceReport) []ComplianceRecommendation {
	var recommendations []ComplianceRecommendation

	// Analyze gaps and generate recommendations
	for _, gap := range report.Gaps {
		rec := ComplianceRecommendation{
			ID:          generateRecommendationID(),
			Type:        "gap_remediation",
			Priority:    gap.Priority,
			Title:       fmt.Sprintf("Address %s Gap", gap.Title),
			Description: fmt.Sprintf("Remediate gap in control %s", gap.ControlID),
			Rationale:   gap.Description,
			Timeline:    gap.Timeline,
			Status:      "pending",
		}
		recommendations = append(recommendations, rec)
	}

	return recommendations
}

func (cr *ComplianceReporter) performContinuousAssessment(ctx context.Context, tenantID string, framework ComplianceFramework) error {
	// Implement continuous monitoring logic
	ticker := time.NewTicker(cr.config.AssessmentFrequency)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-ticker.C:
			_, err := cr.GenerateComplianceReport(ctx, tenantID, framework)
			if err != nil {
				cr.logger.Warn("Continuous assessment failed", zap.Error(err))
			}
		}
	}
}

func (cr *ComplianceReporter) storeComplianceReport(ctx context.Context, report *ComplianceReport) error {
	query := `
		INSERT INTO vulnerability_compliance_reports 
		(id, tenant_id, framework, version, title, description, period, status,
		 overall_score, controls, domains, findings, gaps, recommendations,
		 evidence, attestations, metadata, generated_at, generated_by,
		 expires_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20)`

	periodJSON, _ := json.Marshal(report.Period)
	controlsJSON, _ := json.Marshal(report.Controls)
	domainsJSON, _ := json.Marshal(report.Domains)
	findingsJSON, _ := json.Marshal(report.Findings)
	gapsJSON, _ := json.Marshal(report.Gaps)
	recommendationsJSON, _ := json.Marshal(report.Recommendations)
	evidenceJSON, _ := json.Marshal(report.Evidence)
	attestationsJSON, _ := json.Marshal(report.Attestations)
	metadataJSON, _ := json.Marshal(report.Metadata)

	_, err := cr.db.ExecContext(ctx, query,
		report.ID, report.TenantID, report.Framework, report.Version,
		report.Title, report.Description, periodJSON, report.Status,
		report.OverallScore, controlsJSON, domainsJSON, findingsJSON,
		gapsJSON, recommendationsJSON, evidenceJSON, attestationsJSON,
		metadataJSON, report.GeneratedAt, report.GeneratedBy, report.ExpiresAt,
	)

	return err
}

func (cr *ComplianceReporter) getLatestReport(ctx context.Context, tenantID string, framework ComplianceFramework) (*ComplianceReport, error) {
	query := `
		SELECT id, tenant_id, framework, version, title, description, period,
		       status, overall_score, controls, domains, findings, gaps,
		       recommendations, evidence, attestations, metadata,
		       generated_at, generated_by, reviewed_at, reviewed_by,
		       approved_at, approved_by, expires_at
		FROM vulnerability_compliance_reports 
		WHERE tenant_id = $1 AND framework = $2
		ORDER BY generated_at DESC 
		LIMIT 1`

	row := cr.db.QueryRowContext(ctx, query, tenantID, framework)

	report := &ComplianceReport{}
	var periodJSON, controlsJSON, domainsJSON, findingsJSON, gapsJSON []byte
	var recommendationsJSON, evidenceJSON, attestationsJSON, metadataJSON []byte

	err := row.Scan(
		&report.ID, &report.TenantID, &report.Framework, &report.Version,
		&report.Title, &report.Description, &periodJSON, &report.Status,
		&report.OverallScore, &controlsJSON, &domainsJSON, &findingsJSON,
		&gapsJSON, &recommendationsJSON, &evidenceJSON, &attestationsJSON,
		&metadataJSON, &report.GeneratedAt, &report.GeneratedBy,
		&report.ReviewedAt, &report.ReviewedBy, &report.ApprovedAt,
		&report.ApprovedBy, &report.ExpiresAt,
	)
	if err != nil {
		return nil, err
	}

	// Unmarshal JSON fields
	json.Unmarshal(periodJSON, &report.Period)
	json.Unmarshal(controlsJSON, &report.Controls)
	json.Unmarshal(domainsJSON, &report.Domains)
	json.Unmarshal(findingsJSON, &report.Findings)
	json.Unmarshal(gapsJSON, &report.Gaps)
	json.Unmarshal(recommendationsJSON, &report.Recommendations)
	json.Unmarshal(evidenceJSON, &report.Evidence)
	json.Unmarshal(attestationsJSON, &report.Attestations)
	json.Unmarshal(metadataJSON, &report.Metadata)

	return report, nil
}

// Utility functions

func generateRecommendationID() string {
	return fmt.Sprintf("rec_%d", time.Now().UnixNano())
}

// Default implementation

type DefaultComplianceAssessor struct {
	db     *sql.DB
	logger *zap.Logger
}

func NewDefaultComplianceAssessor(db *sql.DB, logger *zap.Logger) *DefaultComplianceAssessor {
	return &DefaultComplianceAssessor{db: db, logger: logger}
}

func (dca *DefaultComplianceAssessor) Assess(ctx context.Context, tenantID string, framework ComplianceFramework) (*ComplianceReport, error) {
	// Implementation for compliance assessment
	report := &ComplianceReport{
		ID:           fmt.Sprintf("comp_%d", time.Now().UnixNano()),
		TenantID:     tenantID,
		Framework:    framework,
		Version:      "1.0",
		Title:        fmt.Sprintf("%s Compliance Assessment", framework),
		Status:       StatusUnknown,
		OverallScore: 0.0,
		Controls:     []ControlAssessment{},
		Domains:      []DomainAssessment{},
		Findings:     []ComplianceFinding{},
		Gaps:         []ComplianceGap{},
		GeneratedAt:  time.Now(),
		GeneratedBy:  "system",
	}

	return report, nil
}

func (dca *DefaultComplianceAssessor) AssessControl(ctx context.Context, tenantID string, controlID string) (*ControlAssessment, error) {
	// Implementation for control assessment
	assessment := &ControlAssessment{
		ID:             fmt.Sprintf("ctrl_%d", time.Now().UnixNano()),
		ControlID:      controlID,
		Status:         StatusUnknown,
		Score:          0.0,
		LastAssessed:   time.Now(),
		NextAssessment: time.Now().AddDate(0, 0, 90),
	}

	return assessment, nil
}

func (dca *DefaultComplianceAssessor) GetSupportedFrameworks() []ComplianceFramework {
	return []ComplianceFramework{
		FrameworkSOC2,
		FrameworkISO27001,
		FrameworkNIST,
	}
}

func (dca *DefaultComplianceAssessor) GetAssessmentFrequency() time.Duration {
	return 24 * time.Hour // Daily
}
