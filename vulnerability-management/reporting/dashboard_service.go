package reporting

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"time"

	"go.uber.org/zap"
)

// DashboardType defines different dashboard types
type DashboardType string

const (
	DashboardExecutive   DashboardType = "executive"
	DashboardOperational DashboardType = "operational"
	DashboardTechnical   DashboardType = "technical"
	DashboardCompliance  DashboardType = "compliance"
	DashboardCustom      DashboardType = "custom"
)

// WidgetType defines widget types
type WidgetType string

const (
	WidgetKPI      WidgetType = "kpi"
	WidgetChart    WidgetType = "chart"
	WidgetTable    WidgetType = "table"
	WidgetText     WidgetType = "text"
	WidgetGauge    WidgetType = "gauge"
	WidgetHeatmap  WidgetType = "heatmap"
	WidgetTimeline WidgetType = "timeline"
	WidgetMap      WidgetType = "map"
	WidgetAlert    WidgetType = "alert"
	WidgetProgress WidgetType = "progress"
)

// ChartType defines chart types
type ChartType string

const (
	ChartLine    ChartType = "line"
	ChartBar     ChartType = "bar"
	ChartPie     ChartType = "pie"
	ChartArea    ChartType = "area"
	ChartScatter ChartType = "scatter"
	ChartHeatmap ChartType = "heatmap"
	ChartGauge   ChartType = "gauge"
	ChartFunnel  ChartType = "funnel"
	ChartRadar   ChartType = "radar"
	ChartTreemap ChartType = "treemap"
)

// Dashboard represents a monitoring dashboard
type Dashboard struct {
	ID              string                 `json:"id" db:"id"`
	TenantID        string                 `json:"tenant_id" db:"tenant_id"`
	Name            string                 `json:"name" db:"name"`
	Description     string                 `json:"description" db:"description"`
	Type            DashboardType          `json:"type" db:"type"`
	Layout          *DashboardLayout       `json:"layout" db:"layout"`
	Widgets         []Widget               `json:"widgets" db:"widgets"`
	Filters         map[string]interface{} `json:"filters,omitempty" db:"filters"`
	Permissions     *DashboardPermissions  `json:"permissions" db:"permissions"`
	Settings        *DashboardSettings     `json:"settings" db:"settings"`
	RefreshInterval time.Duration          `json:"refresh_interval" db:"refresh_interval"`
	IsTemplate      bool                   `json:"is_template" db:"is_template"`
	TemplateID      string                 `json:"template_id,omitempty" db:"template_id"`
	Tags            []string               `json:"tags,omitempty" db:"tags"`
	Version         int                    `json:"version" db:"version"`
	CreatedAt       time.Time              `json:"created_at" db:"created_at"`
	UpdatedAt       time.Time              `json:"updated_at" db:"updated_at"`
	CreatedBy       string                 `json:"created_by" db:"created_by"`
	LastViewedAt    *time.Time             `json:"last_viewed_at,omitempty" db:"last_viewed_at"`
	ViewCount       int                    `json:"view_count" db:"view_count"`
}

// DashboardPermissions defines access control
type DashboardPermissions struct {
	Public     bool     `json:"public"`
	SharedWith []string `json:"shared_with,omitempty"`
	EditRoles  []string `json:"edit_roles,omitempty"`
	ViewRoles  []string `json:"view_roles,omitempty"`
	Owner      string   `json:"owner"`
	Restricted bool     `json:"restricted"`
}

// DashboardSettings defines dashboard configuration
type DashboardSettings struct {
	Theme         string                `json:"theme,omitempty"`
	TimeRange     *TimeRange            `json:"time_range,omitempty"`
	AutoRefresh   bool                  `json:"auto_refresh"`
	ShowLegend    bool                  `json:"show_legend"`
	ShowToolbar   bool                  `json:"show_toolbar"`
	ShowFilters   bool                  `json:"show_filters"`
	ShowExport    bool                  `json:"show_export"`
	CompactMode   bool                  `json:"compact_mode"`
	FullScreen    bool                  `json:"full_screen"`
	CustomCSS     string                `json:"custom_css,omitempty"`
	Notifications *NotificationSettings `json:"notifications,omitempty"`
	Performance   *PerformanceSettings  `json:"performance,omitempty"`
	Localization  *LocalizationSettings `json:"localization,omitempty"`
}

// TimeRange defines time range configuration
type TimeRange struct {
	Type     string    `json:"type"` // relative, absolute, custom
	From     time.Time `json:"from,omitempty"`
	To       time.Time `json:"to,omitempty"`
	Relative string    `json:"relative,omitempty"` // last_hour, last_day, last_week, etc.
	Live     bool      `json:"live"`               // real-time updates
}

// NotificationSettings defines alert configurations
type NotificationSettings struct {
	Enabled    bool     `json:"enabled"`
	Channels   []string `json:"channels,omitempty"`   // email, slack, webhook
	Frequency  string   `json:"frequency,omitempty"`  // immediate, hourly, daily
	Conditions []string `json:"conditions,omitempty"` // threshold conditions
	Recipients []string `json:"recipients,omitempty"`
}

// PerformanceSettings defines performance configurations
type PerformanceSettings struct {
	CacheEnabled     bool          `json:"cache_enabled"`
	CacheTTL         time.Duration `json:"cache_ttl"`
	LazyLoading      bool          `json:"lazy_loading"`
	VirtualScrolling bool          `json:"virtual_scrolling"`
	MaxDataPoints    int           `json:"max_data_points"`
	SamplingRate     float64       `json:"sampling_rate"`
}

// LocalizationSettings defines internationalization
type LocalizationSettings struct {
	Language     string            `json:"language"`
	Timezone     string            `json:"timezone"`
	DateFormat   string            `json:"date_format"`
	TimeFormat   string            `json:"time_format"`
	NumberFormat string            `json:"number_format"`
	Currency     string            `json:"currency"`
	Translations map[string]string `json:"translations,omitempty"`
}

// Widget represents a dashboard widget
type Widget struct {
	ID            string                 `json:"id"`
	Type          WidgetType             `json:"type"`
	Title         string                 `json:"title"`
	Description   string                 `json:"description,omitempty"`
	Position      *WidgetPosition        `json:"position"`
	Size          *WidgetSize            `json:"size"`
	DataSource    *DataSource            `json:"data_source"`
	Visualization *VisualizationConfig   `json:"visualization"`
	Interactions  *InteractionConfig     `json:"interactions,omitempty"`
	Styling       *WidgetStyling         `json:"styling,omitempty"`
	Conditions    *ConditionalFormatting `json:"conditions,omitempty"`
	Drilldown     *DrilldownConfig       `json:"drilldown,omitempty"`
	Cache         *CacheConfig           `json:"cache,omitempty"`
	IsVisible     bool                   `json:"is_visible"`
	Order         int                    `json:"order"`
	CreatedAt     time.Time              `json:"created_at"`
	UpdatedAt     time.Time              `json:"updated_at"`
}

// WidgetSize defines widget dimensions
type WidgetSize struct {
	Width     int `json:"width"`
	Height    int `json:"height"`
	MinWidth  int `json:"min_width,omitempty"`
	MinHeight int `json:"min_height,omitempty"`
	MaxWidth  int `json:"max_width,omitempty"`
	MaxHeight int `json:"max_height,omitempty"`
}

// DataSource defines data configuration
type DataSource struct {
	Type        string                 `json:"type"` // metric, query, api, static
	MetricID    string                 `json:"metric_id,omitempty"`
	Query       string                 `json:"query,omitempty"`
	API         *APIConfig             `json:"api,omitempty"`
	StaticData  interface{}            `json:"static_data,omitempty"`
	Transform   *DataTransform         `json:"transform,omitempty"`
	Filters     map[string]interface{} `json:"filters,omitempty"`
	Aggregation *AggregationConfig     `json:"aggregation,omitempty"`
	Joins       []DataJoin             `json:"joins,omitempty"`
}

// APIConfig defines API data source
type APIConfig struct {
	URL        string            `json:"url"`
	Method     string            `json:"method"`
	Headers    map[string]string `json:"headers,omitempty"`
	Parameters map[string]string `json:"parameters,omitempty"`
	Body       string            `json:"body,omitempty"`
	AuthType   string            `json:"auth_type,omitempty"`
	AuthConfig map[string]string `json:"auth_config,omitempty"`
}

// DataTransform defines data transformation
type DataTransform struct {
	Operations []TransformOperation `json:"operations"`
	Mapping    map[string]string    `json:"mapping,omitempty"`
	Calculated []CalculatedField    `json:"calculated,omitempty"`
	Filters    []FilterOperation    `json:"filters,omitempty"`
	Sorting    []SortOperation      `json:"sorting,omitempty"`
}

// TransformOperation defines transformation operations
type TransformOperation struct {
	Type       string                 `json:"type"`
	Field      string                 `json:"field"`
	Parameters map[string]interface{} `json:"parameters,omitempty"`
}

// CalculatedField defines calculated fields
type CalculatedField struct {
	Name    string `json:"name"`
	Formula string `json:"formula"`
	Type    string `json:"type"`
}

// FilterOperation defines filter operations
type FilterOperation struct {
	Field    string      `json:"field"`
	Operator string      `json:"operator"` // eq, ne, gt, lt, gte, lte, in, contains
	Value    interface{} `json:"value"`
}

// SortOperation defines sorting operations
type SortOperation struct {
	Field string `json:"field"`
	Order string `json:"order"` // asc, desc
}

// AggregationConfig defines aggregation settings
type AggregationConfig struct {
	GroupBy     []string            `json:"group_by,omitempty"`
	Metrics     []AggregationMetric `json:"metrics"`
	Window      string              `json:"window,omitempty"`
	Granularity string              `json:"granularity,omitempty"`
}

// AggregationMetric defines metric aggregation
type AggregationMetric struct {
	Field    string `json:"field"`
	Function string `json:"function"` // sum, avg, min, max, count, distinct
	Alias    string `json:"alias,omitempty"`
}

// DataJoin defines data joining
type DataJoin struct {
	Type        string `json:"type"` // inner, left, right, full
	SourceField string `json:"source_field"`
	TargetField string `json:"target_field"`
	TargetTable string `json:"target_table"`
}

// VisualizationConfig defines visualization settings
type VisualizationConfig struct {
	ChartType ChartType              `json:"chart_type,omitempty"`
	Axes      *AxesConfig            `json:"axes,omitempty"`
	Series    []SeriesConfig         `json:"series,omitempty"`
	Colors    []string               `json:"colors,omitempty"`
	Theme     string                 `json:"theme,omitempty"`
	Animation *AnimationConfig       `json:"animation,omitempty"`
	Legend    *LegendConfig          `json:"legend,omitempty"`
	Tooltip   *TooltipConfig         `json:"tooltip,omitempty"`
	Grid      *GridConfig            `json:"grid,omitempty"`
	Zoom      *ZoomConfig            `json:"zoom,omitempty"`
	Options   map[string]interface{} `json:"options,omitempty"`
}

// AxesConfig defines chart axes
type AxesConfig struct {
	XAxis *AxisConfig `json:"x_axis,omitempty"`
	YAxis *AxisConfig `json:"y_axis,omitempty"`
}

// AxisConfig defines individual axis settings
type AxisConfig struct {
	Title     string      `json:"title,omitempty"`
	Type      string      `json:"type,omitempty"` // linear, logarithmic, time, category
	Min       interface{} `json:"min,omitempty"`
	Max       interface{} `json:"max,omitempty"`
	Format    string      `json:"format,omitempty"`
	Unit      string      `json:"unit,omitempty"`
	Position  string      `json:"position,omitempty"` // top, bottom, left, right
	Show      bool        `json:"show"`
	GridLines bool        `json:"grid_lines"`
	TickCount int         `json:"tick_count,omitempty"`
}

// SeriesConfig defines data series
type SeriesConfig struct {
	Name       string                 `json:"name"`
	Field      string                 `json:"field"`
	Type       string                 `json:"type,omitempty"`
	Color      string                 `json:"color,omitempty"`
	Fill       bool                   `json:"fill"`
	Smooth     bool                   `json:"smooth"`
	Stack      string                 `json:"stack,omitempty"`
	YAxisIndex int                    `json:"y_axis_index,omitempty"`
	Options    map[string]interface{} `json:"options,omitempty"`
}

// AnimationConfig defines animation settings
type AnimationConfig struct {
	Enabled  bool          `json:"enabled"`
	Duration time.Duration `json:"duration"`
	Easing   string        `json:"easing"`
	Delay    time.Duration `json:"delay,omitempty"`
}

// LegendConfig defines legend settings
type LegendConfig struct {
	Show     bool   `json:"show"`
	Position string `json:"position"` // top, bottom, left, right
	Align    string `json:"align"`    // start, center, end
	Layout   string `json:"layout"`   // horizontal, vertical
}

// TooltipConfig defines tooltip settings
type TooltipConfig struct {
	Show     bool   `json:"show"`
	Trigger  string `json:"trigger"` // hover, click
	Format   string `json:"format,omitempty"`
	Template string `json:"template,omitempty"`
	Position string `json:"position"` // auto, top, bottom, left, right
}

// GridConfig defines grid settings
type GridConfig struct {
	Show      bool    `json:"show"`
	Color     string  `json:"color,omitempty"`
	Opacity   float64 `json:"opacity,omitempty"`
	DashArray string  `json:"dash_array,omitempty"`
}

// ZoomConfig defines zoom settings
type ZoomConfig struct {
	Enabled bool   `json:"enabled"`
	Type    string `json:"type"` // x, y, xy
	Min     int    `json:"min,omitempty"`
	Max     int    `json:"max,omitempty"`
}

// InteractionConfig defines widget interactions
type InteractionConfig struct {
	Clickable   bool              `json:"clickable"`
	Hoverable   bool              `json:"hoverable"`
	Selectable  bool              `json:"selectable"`
	Zoomable    bool              `json:"zoomable"`
	Draggable   bool              `json:"draggable"`
	Resizable   bool              `json:"resizable"`
	CrossFilter bool              `json:"cross_filter"`
	Actions     []ActionConfig    `json:"actions,omitempty"`
	Events      map[string]string `json:"events,omitempty"`
	Shortcuts   map[string]string `json:"shortcuts,omitempty"`
}

// ActionConfig defines interactive actions
type ActionConfig struct {
	Type       string                 `json:"type"`    // navigate, filter, export, alert
	Trigger    string                 `json:"trigger"` // click, hover, select
	Target     string                 `json:"target,omitempty"`
	Parameters map[string]interface{} `json:"parameters,omitempty"`
	Condition  string                 `json:"condition,omitempty"`
}

// WidgetStyling defines widget appearance
type WidgetStyling struct {
	BackgroundColor string                 `json:"background_color,omitempty"`
	BorderColor     string                 `json:"border_color,omitempty"`
	BorderWidth     int                    `json:"border_width,omitempty"`
	BorderRadius    int                    `json:"border_radius,omitempty"`
	Shadow          bool                   `json:"shadow"`
	Padding         *Padding               `json:"padding,omitempty"`
	Margin          *Margin                `json:"margin,omitempty"`
	Typography      *Typography            `json:"typography,omitempty"`
	CustomCSS       string                 `json:"custom_css,omitempty"`
	Responsive      map[string]interface{} `json:"responsive,omitempty"`
}

// Padding defines padding values
type Padding struct {
	Top    int `json:"top"`
	Right  int `json:"right"`
	Bottom int `json:"bottom"`
	Left   int `json:"left"`
}

// Margin defines margin values
type Margin struct {
	Top    int `json:"top"`
	Right  int `json:"right"`
	Bottom int `json:"bottom"`
	Left   int `json:"left"`
}

// Typography defines text styling
type Typography struct {
	FontFamily string  `json:"font_family,omitempty"`
	FontSize   int     `json:"font_size,omitempty"`
	FontWeight string  `json:"font_weight,omitempty"`
	Color      string  `json:"color,omitempty"`
	LineHeight float64 `json:"line_height,omitempty"`
	TextAlign  string  `json:"text_align,omitempty"`
}

// ConditionalFormatting defines conditional formatting rules
type ConditionalFormatting struct {
	Rules []FormattingRule `json:"rules"`
}

// FormattingRule defines individual formatting rule
type FormattingRule struct {
	Condition  string                 `json:"condition"`
	Field      string                 `json:"field,omitempty"`
	Value      interface{}            `json:"value"`
	Operator   string                 `json:"operator"`
	Formatting map[string]interface{} `json:"formatting"`
	Priority   int                    `json:"priority"`
}

// DrilldownConfig defines drill-down navigation
type DrilldownConfig struct {
	Enabled     bool                   `json:"enabled"`
	Target      string                 `json:"target"` // dashboard, report, url
	TargetID    string                 `json:"target_id,omitempty"`
	Parameters  map[string]interface{} `json:"parameters,omitempty"`
	NewWindow   bool                   `json:"new_window"`
	Breadcrumbs bool                   `json:"breadcrumbs"`
}

// CacheConfig defines widget caching
type CacheConfig struct {
	Enabled bool          `json:"enabled"`
	TTL     time.Duration `json:"ttl"`
	Key     string        `json:"key,omitempty"`
	Tags    []string      `json:"tags,omitempty"`
}

// DashboardData represents runtime dashboard data
type DashboardData struct {
	DashboardID string                 `json:"dashboard_id"`
	TenantID    string                 `json:"tenant_id"`
	GeneratedAt time.Time              `json:"generated_at"`
	TimeRange   *TimeRange             `json:"time_range"`
	Widgets     map[string]interface{} `json:"widgets"`
	Metadata    map[string]interface{} `json:"metadata,omitempty"`
	Performance *PerformanceMetrics    `json:"performance,omitempty"`
}

// PerformanceMetrics tracks dashboard performance
type PerformanceMetrics struct {
	LoadTime      time.Duration          `json:"load_time"`
	RenderTime    time.Duration          `json:"render_time"`
	DataFetchTime time.Duration          `json:"data_fetch_time"`
	WidgetMetrics map[string]interface{} `json:"widget_metrics"`
	CacheHitRate  float64                `json:"cache_hit_rate"`
	ErrorCount    int                    `json:"error_count"`
	Warning       []string               `json:"warnings,omitempty"`
}

// DashboardService manages dashboard operations
type DashboardService struct {
	db             *sql.DB
	logger         *zap.Logger
	config         *DashboardConfig
	cache          DashboardCache
	metrics        DashboardMetrics
	renderer       DashboardRenderer
	dataProvider   DataProvider
	templateEngine TemplateEngine
}

// DashboardConfig defines service configuration
type DashboardConfig struct {
	MaxWidgets            int           `json:"max_widgets"`
	MaxDashboards         int           `json:"max_dashboards"`
	DefaultRefreshRate    time.Duration `json:"default_refresh_rate"`
	CacheEnabled          bool          `json:"cache_enabled"`
	CacheTTL              time.Duration `json:"cache_ttl"`
	RealTimeEnabled       bool          `json:"real_time_enabled"`
	ExportEnabled         bool          `json:"export_enabled"`
	SharingEnabled        bool          `json:"sharing_enabled"`
	TemplateEnabled       bool          `json:"template_enabled"`
	CustomCSSEnabled      bool          `json:"custom_css_enabled"`
	MaxDataPoints         int           `json:"max_data_points"`
	PerformanceMonitoring bool          `json:"performance_monitoring"`
}

// DashboardCache interface for caching
type DashboardCache interface {
	Get(key string) (interface{}, error)
	Set(key string, value interface{}, ttl time.Duration) error
	Delete(key string) error
	Clear() error
	GetDashboard(dashboardID string, tenantID string) (*Dashboard, error)
	SetDashboard(dashboard *Dashboard, ttl time.Duration) error
	GetDashboardData(dashboardID string, tenantID string) (*DashboardData, error)
	SetDashboardData(data *DashboardData, ttl time.Duration) error
}

// DashboardMetrics interface for metrics collection
type DashboardMetrics interface {
	DashboardViewed(dashboardID string, tenantID string)
	DashboardCreated(tenantID string)
	DashboardUpdated(dashboardID string, tenantID string)
	DashboardDeleted(dashboardID string, tenantID string)
	WidgetRendered(widgetID string, widgetType WidgetType, duration time.Duration)
	DataFetched(sourceType string, duration time.Duration)
	CacheHit(cacheType string)
	CacheMiss(cacheType string)
	ErrorOccurred(errorType string, dashboardID string)
}

// DashboardRenderer interface for rendering
type DashboardRenderer interface {
	RenderDashboard(dashboard *Dashboard, data *DashboardData) (interface{}, error)
	RenderWidget(widget *Widget, data interface{}) (interface{}, error)
	GenerateExport(dashboard *Dashboard, format string) ([]byte, error)
	GeneratePreview(dashboard *Dashboard) (interface{}, error)
}

// DataProvider interface for data retrieval
type DataProvider interface {
	GetWidgetData(ctx context.Context, widget *Widget, timeRange *TimeRange, tenantID string) (interface{}, error)
	GetMetricData(ctx context.Context, metricID string, timeRange *TimeRange, tenantID string) (interface{}, error)
	ExecuteQuery(ctx context.Context, query string, parameters map[string]interface{}, tenantID string) (interface{}, error)
	GetAPIData(ctx context.Context, config *APIConfig) (interface{}, error)
}

// TemplateEngine interface for template management
type TemplateEngine interface {
	CreateTemplate(dashboard *Dashboard) (*DashboardTemplate, error)
	ApplyTemplate(templateID string, parameters map[string]interface{}) (*Dashboard, error)
	ListTemplates(category string) ([]*DashboardTemplate, error)
	UpdateTemplate(template *DashboardTemplate) error
	DeleteTemplate(templateID string) error
}

// DashboardTemplate represents dashboard templates
type DashboardTemplate struct {
	ID          string              `json:"id"`
	Name        string              `json:"name"`
	Description string              `json:"description"`
	Category    string              `json:"category"`
	Dashboard   *Dashboard          `json:"dashboard"`
	Parameters  []TemplateParameter `json:"parameters"`
	Preview     string              `json:"preview,omitempty"`
	Tags        []string            `json:"tags,omitempty"`
	Version     string              `json:"version"`
	CreatedAt   time.Time           `json:"created_at"`
	UpdatedAt   time.Time           `json:"updated_at"`
	CreatedBy   string              `json:"created_by"`
	IsPublic    bool                `json:"is_public"`
	UsageCount  int                 `json:"usage_count"`
}

// TemplateParameter defines template parameters
type TemplateParameter struct {
	Name         string      `json:"name"`
	Type         string      `json:"type"`
	Description  string      `json:"description"`
	DefaultValue interface{} `json:"default_value,omitempty"`
	Required     bool        `json:"required"`
	Options      []string    `json:"options,omitempty"`
}

// NewDashboardService creates a new dashboard service
func NewDashboardService(db *sql.DB, logger *zap.Logger, config *DashboardConfig) *DashboardService {
	return &DashboardService{
		db:             db,
		logger:         logger,
		config:         config,
		cache:          NewDashboardMemoryCache(),
		metrics:        NewPrometheusDashboardMetrics(),
		renderer:       NewDefaultDashboardRenderer(),
		dataProvider:   NewDefaultDataProvider(db),
		templateEngine: NewDefaultTemplateEngine(db),
	}
}

// CreateDashboard creates a new dashboard
func (ds *DashboardService) CreateDashboard(ctx context.Context, dashboard *Dashboard) error {
	// Validate dashboard
	if err := ds.validateDashboard(dashboard); err != nil {
		return fmt.Errorf("invalid dashboard: %w", err)
	}

	// Set metadata
	if dashboard.ID == "" {
		dashboard.ID = generateDashboardID()
	}
	dashboard.CreatedAt = time.Now()
	dashboard.UpdatedAt = time.Now()
	dashboard.Version = 1

	// Store in database
	if err := ds.storeDashboard(ctx, dashboard); err != nil {
		return fmt.Errorf("failed to store dashboard: %w", err)
	}

	// Update cache
	if ds.config.CacheEnabled {
		if err := ds.cache.SetDashboard(dashboard, ds.config.CacheTTL); err != nil {
			ds.logger.Warn("Failed to cache dashboard", zap.Error(err))
		}
	}

	ds.metrics.DashboardCreated(dashboard.TenantID)

	ds.logger.Info("Dashboard created",
		zap.String("dashboard_id", dashboard.ID),
		zap.String("tenant_id", dashboard.TenantID),
		zap.String("name", dashboard.Name))

	return nil
}

// GetDashboard retrieves a dashboard
func (ds *DashboardService) GetDashboard(ctx context.Context, dashboardID string, tenantID string) (*Dashboard, error) {
	// Check cache first
	if ds.config.CacheEnabled {
		if cached, err := ds.cache.GetDashboard(dashboardID, tenantID); err == nil && cached != nil {
			ds.metrics.CacheHit("dashboard")
			return cached, nil
		}
		ds.metrics.CacheMiss("dashboard")
	}

	// Load from database
	dashboard, err := ds.loadDashboard(ctx, dashboardID, tenantID)
	if err != nil {
		return nil, fmt.Errorf("failed to load dashboard: %w", err)
	}

	// Update view statistics
	if err := ds.updateViewStats(ctx, dashboardID, tenantID); err != nil {
		ds.logger.Warn("Failed to update view stats", zap.Error(err))
	}

	// Cache the result
	if ds.config.CacheEnabled {
		if err := ds.cache.SetDashboard(dashboard, ds.config.CacheTTL); err != nil {
			ds.logger.Warn("Failed to cache dashboard", zap.Error(err))
		}
	}

	ds.metrics.DashboardViewed(dashboardID, tenantID)

	return dashboard, nil
}

// UpdateDashboard updates an existing dashboard
func (ds *DashboardService) UpdateDashboard(ctx context.Context, dashboard *Dashboard) error {
	// Validate dashboard
	if err := ds.validateDashboard(dashboard); err != nil {
		return fmt.Errorf("invalid dashboard: %w", err)
	}

	// Update metadata
	dashboard.UpdatedAt = time.Now()
	dashboard.Version++

	// Store in database
	if err := ds.updateDashboard(ctx, dashboard); err != nil {
		return fmt.Errorf("failed to update dashboard: %w", err)
	}

	// Update cache
	if ds.config.CacheEnabled {
		if err := ds.cache.SetDashboard(dashboard, ds.config.CacheTTL); err != nil {
			ds.logger.Warn("Failed to cache updated dashboard", zap.Error(err))
		}
	}

	ds.metrics.DashboardUpdated(dashboard.ID, dashboard.TenantID)

	ds.logger.Info("Dashboard updated",
		zap.String("dashboard_id", dashboard.ID),
		zap.String("tenant_id", dashboard.TenantID),
		zap.Int("version", dashboard.Version))

	return nil
}

// DeleteDashboard deletes a dashboard
func (ds *DashboardService) DeleteDashboard(ctx context.Context, dashboardID string, tenantID string) error {
	// Delete from database
	if err := ds.deleteDashboard(ctx, dashboardID, tenantID); err != nil {
		return fmt.Errorf("failed to delete dashboard: %w", err)
	}

	// Remove from cache
	if ds.config.CacheEnabled {
		cacheKey := fmt.Sprintf("dashboard:%s:%s", tenantID, dashboardID)
		if err := ds.cache.Delete(cacheKey); err != nil {
			ds.logger.Warn("Failed to remove dashboard from cache", zap.Error(err))
		}
	}

	ds.metrics.DashboardDeleted(dashboardID, tenantID)

	ds.logger.Info("Dashboard deleted",
		zap.String("dashboard_id", dashboardID),
		zap.String("tenant_id", tenantID))

	return nil
}

// GetDashboardData retrieves dashboard data
func (ds *DashboardService) GetDashboardData(ctx context.Context, dashboardID string, tenantID string, timeRange *TimeRange) (*DashboardData, error) {
	start := time.Now()

	// Check cache first
	cacheKey := fmt.Sprintf("data:%s:%s", tenantID, dashboardID)
	if ds.config.CacheEnabled {
		if cached, err := ds.cache.GetDashboardData(dashboardID, tenantID); err == nil && cached != nil {
			ds.metrics.CacheHit("dashboard_data")
			return cached, nil
		}
		ds.metrics.CacheMiss("dashboard_data")
	}

	// Get dashboard configuration
	dashboard, err := ds.GetDashboard(ctx, dashboardID, tenantID)
	if err != nil {
		return nil, fmt.Errorf("failed to get dashboard: %w", err)
	}

	// Apply time range
	if timeRange == nil {
		timeRange = dashboard.Settings.TimeRange
	}
	if timeRange == nil {
		timeRange = &TimeRange{
			Type:     "relative",
			Relative: "last_hour",
		}
	}

	// Collect widget data
	widgetData := make(map[string]interface{})
	widgetMetrics := make(map[string]interface{})

	for _, widget := range dashboard.Widgets {
		if !widget.IsVisible {
			continue
		}

		widgetStart := time.Now()
		data, err := ds.dataProvider.GetWidgetData(ctx, &widget, timeRange, tenantID)
		widgetDuration := time.Since(widgetStart)

		if err != nil {
			ds.logger.Warn("Failed to get widget data",
				zap.String("widget_id", widget.ID),
				zap.Error(err))
			ds.metrics.ErrorOccurred("widget_data_fetch", dashboardID)
			continue
		}

		widgetData[widget.ID] = data
		widgetMetrics[widget.ID] = map[string]interface{}{
			"fetch_time":  widgetDuration,
			"data_points": ds.countDataPoints(data),
		}

		ds.metrics.WidgetRendered(widget.ID, widget.Type, widgetDuration)
	}

	// Create dashboard data
	dashboardData := &DashboardData{
		DashboardID: dashboardID,
		TenantID:    tenantID,
		GeneratedAt: time.Now(),
		TimeRange:   timeRange,
		Widgets:     widgetData,
		Metadata: map[string]interface{}{
			"dashboard_name":  dashboard.Name,
			"widget_count":    len(dashboard.Widgets),
			"visible_widgets": len(widgetData),
		},
		Performance: &PerformanceMetrics{
			LoadTime:      time.Since(start),
			DataFetchTime: time.Since(start),
			WidgetMetrics: widgetMetrics,
			CacheHitRate:  ds.calculateCacheHitRate(),
			ErrorCount:    0, // Would be tracked from widget errors
		},
	}

	// Cache the result
	if ds.config.CacheEnabled {
		if err := ds.cache.SetDashboardData(dashboardData, ds.config.CacheTTL); err != nil {
			ds.logger.Warn("Failed to cache dashboard data", zap.Error(err))
		}
	}

	ds.logger.Debug("Dashboard data generated",
		zap.String("dashboard_id", dashboardID),
		zap.Duration("duration", time.Since(start)),
		zap.Int("widgets", len(widgetData)))

	return dashboardData, nil
}

// ListDashboards returns dashboards for a tenant
func (ds *DashboardService) ListDashboards(ctx context.Context, tenantID string, filters *DashboardFilters) ([]*Dashboard, error) {
	query := `
		SELECT id, tenant_id, name, description, type, layout, widgets, filters,
		       permissions, settings, refresh_interval, is_template, template_id,
		       tags, version, created_at, updated_at, created_by, last_viewed_at, view_count
		FROM vulnerability_dashboards 
		WHERE tenant_id = $1`

	args := []interface{}{tenantID}
	argIndex := 2

	if filters != nil {
		if filters.Type != "" {
			query += fmt.Sprintf(" AND type = $%d", argIndex)
			args = append(args, filters.Type)
			argIndex++
		}
		if len(filters.Tags) > 0 {
			query += fmt.Sprintf(" AND tags && $%d", argIndex)
			args = append(args, fmt.Sprintf("{%s}", join(filters.Tags, ",")))
			argIndex++
		}
		if filters.IsTemplate != nil {
			query += fmt.Sprintf(" AND is_template = $%d", argIndex)
			args = append(args, *filters.IsTemplate)
			argIndex++
		}
	}

	query += " ORDER BY "
	if filters != nil && filters.SortBy != "" {
		query += filters.SortBy
		if filters.SortOrder == "desc" {
			query += " DESC"
		} else {
			query += " ASC"
		}
	} else {
		query += "updated_at DESC"
	}

	if filters != nil && filters.Limit > 0 {
		query += fmt.Sprintf(" LIMIT $%d", argIndex)
		args = append(args, filters.Limit)
		argIndex++

		if filters.Offset > 0 {
			query += fmt.Sprintf(" OFFSET $%d", argIndex)
			args = append(args, filters.Offset)
		}
	}

	rows, err := ds.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to list dashboards: %w", err)
	}
	defer rows.Close()

	var dashboards []*Dashboard
	for rows.Next() {
		dashboard := &Dashboard{}
		var layoutJSON, widgetsJSON, filtersJSON, permissionsJSON, settingsJSON, tagsJSON []byte

		err := rows.Scan(
			&dashboard.ID, &dashboard.TenantID, &dashboard.Name, &dashboard.Description,
			&dashboard.Type, &layoutJSON, &widgetsJSON, &filtersJSON,
			&permissionsJSON, &settingsJSON, &dashboard.RefreshInterval,
			&dashboard.IsTemplate, &dashboard.TemplateID, &tagsJSON,
			&dashboard.Version, &dashboard.CreatedAt, &dashboard.UpdatedAt,
			&dashboard.CreatedBy, &dashboard.LastViewedAt, &dashboard.ViewCount,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan dashboard: %w", err)
		}

		// Unmarshal JSON fields
		if len(layoutJSON) > 0 {
			json.Unmarshal(layoutJSON, &dashboard.Layout)
		}
		if len(widgetsJSON) > 0 {
			json.Unmarshal(widgetsJSON, &dashboard.Widgets)
		}
		if len(filtersJSON) > 0 {
			json.Unmarshal(filtersJSON, &dashboard.Filters)
		}
		if len(permissionsJSON) > 0 {
			json.Unmarshal(permissionsJSON, &dashboard.Permissions)
		}
		if len(settingsJSON) > 0 {
			json.Unmarshal(settingsJSON, &dashboard.Settings)
		}
		if len(tagsJSON) > 0 {
			json.Unmarshal(tagsJSON, &dashboard.Tags)
		}

		dashboards = append(dashboards, dashboard)
	}

	return dashboards, nil
}

// DashboardFilters defines filtering options
type DashboardFilters struct {
	Type       DashboardType `json:"type,omitempty"`
	Tags       []string      `json:"tags,omitempty"`
	IsTemplate *bool         `json:"is_template,omitempty"`
	SortBy     string        `json:"sort_by,omitempty"`
	SortOrder  string        `json:"sort_order,omitempty"`
	Limit      int           `json:"limit,omitempty"`
	Offset     int           `json:"offset,omitempty"`
}

// Helper methods

func (ds *DashboardService) validateDashboard(dashboard *Dashboard) error {
	if dashboard.TenantID == "" {
		return fmt.Errorf("tenant_id is required")
	}
	if dashboard.Name == "" {
		return fmt.Errorf("name is required")
	}
	if len(dashboard.Widgets) > ds.config.MaxWidgets {
		return fmt.Errorf("too many widgets: max %d", ds.config.MaxWidgets)
	}

	// Validate widgets
	for _, widget := range dashboard.Widgets {
		if err := ds.validateWidget(&widget); err != nil {
			return fmt.Errorf("invalid widget %s: %w", widget.ID, err)
		}
	}

	return nil
}

func (ds *DashboardService) validateWidget(widget *Widget) error {
	if widget.ID == "" {
		widget.ID = generateWidgetID()
	}
	if widget.Type == "" {
		return fmt.Errorf("widget type is required")
	}
	if widget.Position == nil {
		return fmt.Errorf("widget position is required")
	}
	if widget.Size == nil {
		return fmt.Errorf("widget size is required")
	}

	return nil
}

func (ds *DashboardService) storeDashboard(ctx context.Context, dashboard *Dashboard) error {
	query := `
		INSERT INTO vulnerability_dashboards 
		(id, tenant_id, name, description, type, layout, widgets, filters,
		 permissions, settings, refresh_interval, is_template, template_id,
		 tags, version, created_at, updated_at, created_by, view_count)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)`

	layoutJSON, _ := json.Marshal(dashboard.Layout)
	widgetsJSON, _ := json.Marshal(dashboard.Widgets)
	filtersJSON, _ := json.Marshal(dashboard.Filters)
	permissionsJSON, _ := json.Marshal(dashboard.Permissions)
	settingsJSON, _ := json.Marshal(dashboard.Settings)
	tagsJSON, _ := json.Marshal(dashboard.Tags)

	_, err := ds.db.ExecContext(ctx, query,
		dashboard.ID, dashboard.TenantID, dashboard.Name, dashboard.Description,
		dashboard.Type, layoutJSON, widgetsJSON, filtersJSON,
		permissionsJSON, settingsJSON, dashboard.RefreshInterval,
		dashboard.IsTemplate, dashboard.TemplateID, tagsJSON,
		dashboard.Version, dashboard.CreatedAt, dashboard.UpdatedAt,
		dashboard.CreatedBy, dashboard.ViewCount,
	)

	return err
}

func (ds *DashboardService) loadDashboard(ctx context.Context, dashboardID string, tenantID string) (*Dashboard, error) {
	query := `
		SELECT id, tenant_id, name, description, type, layout, widgets, filters,
		       permissions, settings, refresh_interval, is_template, template_id,
		       tags, version, created_at, updated_at, created_by, last_viewed_at, view_count
		FROM vulnerability_dashboards 
		WHERE id = $1 AND tenant_id = $2`

	row := ds.db.QueryRowContext(ctx, query, dashboardID, tenantID)

	dashboard := &Dashboard{}
	var layoutJSON, widgetsJSON, filtersJSON, permissionsJSON, settingsJSON, tagsJSON []byte

	err := row.Scan(
		&dashboard.ID, &dashboard.TenantID, &dashboard.Name, &dashboard.Description,
		&dashboard.Type, &layoutJSON, &widgetsJSON, &filtersJSON,
		&permissionsJSON, &settingsJSON, &dashboard.RefreshInterval,
		&dashboard.IsTemplate, &dashboard.TemplateID, &tagsJSON,
		&dashboard.Version, &dashboard.CreatedAt, &dashboard.UpdatedAt,
		&dashboard.CreatedBy, &dashboard.LastViewedAt, &dashboard.ViewCount,
	)
	if err != nil {
		return nil, err
	}

	// Unmarshal JSON fields
	if len(layoutJSON) > 0 {
		json.Unmarshal(layoutJSON, &dashboard.Layout)
	}
	if len(widgetsJSON) > 0 {
		json.Unmarshal(widgetsJSON, &dashboard.Widgets)
	}
	if len(filtersJSON) > 0 {
		json.Unmarshal(filtersJSON, &dashboard.Filters)
	}
	if len(permissionsJSON) > 0 {
		json.Unmarshal(permissionsJSON, &dashboard.Permissions)
	}
	if len(settingsJSON) > 0 {
		json.Unmarshal(settingsJSON, &dashboard.Settings)
	}
	if len(tagsJSON) > 0 {
		json.Unmarshal(tagsJSON, &dashboard.Tags)
	}

	return dashboard, nil
}

func (ds *DashboardService) updateDashboard(ctx context.Context, dashboard *Dashboard) error {
	query := `
		UPDATE vulnerability_dashboards 
		SET name = $3, description = $4, type = $5, layout = $6, widgets = $7,
		    filters = $8, permissions = $9, settings = $10, refresh_interval = $11,
		    is_template = $12, template_id = $13, tags = $14, version = $15,
		    updated_at = $16
		WHERE id = $1 AND tenant_id = $2`

	layoutJSON, _ := json.Marshal(dashboard.Layout)
	widgetsJSON, _ := json.Marshal(dashboard.Widgets)
	filtersJSON, _ := json.Marshal(dashboard.Filters)
	permissionsJSON, _ := json.Marshal(dashboard.Permissions)
	settingsJSON, _ := json.Marshal(dashboard.Settings)
	tagsJSON, _ := json.Marshal(dashboard.Tags)

	_, err := ds.db.ExecContext(ctx, query,
		dashboard.ID, dashboard.TenantID, dashboard.Name, dashboard.Description,
		dashboard.Type, layoutJSON, widgetsJSON, filtersJSON,
		permissionsJSON, settingsJSON, dashboard.RefreshInterval,
		dashboard.IsTemplate, dashboard.TemplateID, tagsJSON,
		dashboard.Version, dashboard.UpdatedAt,
	)

	return err
}

func (ds *DashboardService) deleteDashboard(ctx context.Context, dashboardID string, tenantID string) error {
	query := `DELETE FROM vulnerability_dashboards WHERE id = $1 AND tenant_id = $2`
	_, err := ds.db.ExecContext(ctx, query, dashboardID, tenantID)
	return err
}

func (ds *DashboardService) updateViewStats(ctx context.Context, dashboardID string, tenantID string) error {
	query := `
		UPDATE vulnerability_dashboards 
		SET last_viewed_at = NOW(), view_count = view_count + 1
		WHERE id = $1 AND tenant_id = $2`

	_, err := ds.db.ExecContext(ctx, query, dashboardID, tenantID)
	return err
}

func (ds *DashboardService) countDataPoints(data interface{}) int {
	// Implementation would count actual data points
	// This is a placeholder
	return 0
}

func (ds *DashboardService) calculateCacheHitRate() float64 {
	// Implementation would calculate actual cache hit rate
	// This is a placeholder
	return 0.85
}

// Utility functions

func generateDashboardID() string {
	return fmt.Sprintf("dash_%d", time.Now().UnixNano())
}

func generateWidgetID() string {
	return fmt.Sprintf("widget_%d", time.Now().UnixNano())
}

func join(strs []string, sep string) string {
	if len(strs) == 0 {
		return ""
	}
	if len(strs) == 1 {
		return strs[0]
	}

	result := strs[0]
	for i := 1; i < len(strs); i++ {
		result += sep + strs[i]
	}
	return result
}

// Default implementations

type DashboardMemoryCache struct {
	data map[string]interface{}
}

func NewDashboardMemoryCache() *DashboardMemoryCache {
	return &DashboardMemoryCache{
		data: make(map[string]interface{}),
	}
}

func (c *DashboardMemoryCache) Get(key string) (interface{}, error) {
	if value, exists := c.data[key]; exists {
		return value, nil
	}
	return nil, fmt.Errorf("cache miss")
}

func (c *DashboardMemoryCache) Set(key string, value interface{}, ttl time.Duration) error {
	c.data[key] = value
	// TTL handling would be implemented with proper cache library
	return nil
}

func (c *DashboardMemoryCache) Delete(key string) error {
	delete(c.data, key)
	return nil
}

func (c *DashboardMemoryCache) Clear() error {
	c.data = make(map[string]interface{})
	return nil
}

func (c *DashboardMemoryCache) GetDashboard(dashboardID string, tenantID string) (*Dashboard, error) {
	key := fmt.Sprintf("dashboard:%s:%s", tenantID, dashboardID)
	value, err := c.Get(key)
	if err != nil {
		return nil, err
	}
	if dashboard, ok := value.(*Dashboard); ok {
		return dashboard, nil
	}
	return nil, fmt.Errorf("invalid cache entry")
}

func (c *DashboardMemoryCache) SetDashboard(dashboard *Dashboard, ttl time.Duration) error {
	key := fmt.Sprintf("dashboard:%s:%s", dashboard.TenantID, dashboard.ID)
	return c.Set(key, dashboard, ttl)
}

func (c *DashboardMemoryCache) GetDashboardData(dashboardID string, tenantID string) (*DashboardData, error) {
	key := fmt.Sprintf("data:%s:%s", tenantID, dashboardID)
	value, err := c.Get(key)
	if err != nil {
		return nil, err
	}
	if data, ok := value.(*DashboardData); ok {
		return data, nil
	}
	return nil, fmt.Errorf("invalid cache entry")
}

func (c *DashboardMemoryCache) SetDashboardData(data *DashboardData, ttl time.Duration) error {
	key := fmt.Sprintf("data:%s:%s", data.TenantID, data.DashboardID)
	return c.Set(key, data, ttl)
}

type PrometheusDashboardMetrics struct{}

func NewPrometheusDashboardMetrics() *PrometheusDashboardMetrics {
	return &PrometheusDashboardMetrics{}
}

func (m *PrometheusDashboardMetrics) DashboardViewed(dashboardID string, tenantID string) {
	// Prometheus metrics implementation
}

func (m *PrometheusDashboardMetrics) DashboardCreated(tenantID string) {
	// Prometheus metrics implementation
}

func (m *PrometheusDashboardMetrics) DashboardUpdated(dashboardID string, tenantID string) {
	// Prometheus metrics implementation
}

func (m *PrometheusDashboardMetrics) DashboardDeleted(dashboardID string, tenantID string) {
	// Prometheus metrics implementation
}

func (m *PrometheusDashboardMetrics) WidgetRendered(widgetID string, widgetType WidgetType, duration time.Duration) {
	// Prometheus metrics implementation
}

func (m *PrometheusDashboardMetrics) DataFetched(sourceType string, duration time.Duration) {
	// Prometheus metrics implementation
}

func (m *PrometheusDashboardMetrics) CacheHit(cacheType string) {
	// Prometheus metrics implementation
}

func (m *PrometheusDashboardMetrics) CacheMiss(cacheType string) {
	// Prometheus metrics implementation
}

func (m *PrometheusDashboardMetrics) ErrorOccurred(errorType string, dashboardID string) {
	// Prometheus metrics implementation
}

type DefaultDashboardRenderer struct{}

func NewDefaultDashboardRenderer() *DefaultDashboardRenderer {
	return &DefaultDashboardRenderer{}
}

func (r *DefaultDashboardRenderer) RenderDashboard(dashboard *Dashboard, data *DashboardData) (interface{}, error) {
	// Dashboard rendering implementation
	return nil, nil
}

func (r *DefaultDashboardRenderer) RenderWidget(widget *Widget, data interface{}) (interface{}, error) {
	// Widget rendering implementation
	return nil, nil
}

func (r *DefaultDashboardRenderer) GenerateExport(dashboard *Dashboard, format string) ([]byte, error) {
	// Export generation implementation
	return nil, nil
}

func (r *DefaultDashboardRenderer) GeneratePreview(dashboard *Dashboard) (interface{}, error) {
	// Preview generation implementation
	return nil, nil
}

type DefaultDataProvider struct {
	db *sql.DB
}

func NewDefaultDataProvider(db *sql.DB) *DefaultDataProvider {
	return &DefaultDataProvider{db: db}
}

func (p *DefaultDataProvider) GetWidgetData(ctx context.Context, widget *Widget, timeRange *TimeRange, tenantID string) (interface{}, error) {
	// Widget data retrieval implementation
	return nil, nil
}

func (p *DefaultDataProvider) GetMetricData(ctx context.Context, metricID string, timeRange *TimeRange, tenantID string) (interface{}, error) {
	// Metric data retrieval implementation
	return nil, nil
}

func (p *DefaultDataProvider) ExecuteQuery(ctx context.Context, query string, parameters map[string]interface{}, tenantID string) (interface{}, error) {
	// Query execution implementation
	return nil, nil
}

func (p *DefaultDataProvider) GetAPIData(ctx context.Context, config *APIConfig) (interface{}, error) {
	// API data retrieval implementation
	return nil, nil
}

type DefaultTemplateEngine struct {
	db *sql.DB
}

func NewDefaultTemplateEngine(db *sql.DB) *DefaultTemplateEngine {
	return &DefaultTemplateEngine{db: db}
}

func (e *DefaultTemplateEngine) CreateTemplate(dashboard *Dashboard) (*DashboardTemplate, error) {
	// Template creation implementation
	return nil, nil
}

func (e *DefaultTemplateEngine) ApplyTemplate(templateID string, parameters map[string]interface{}) (*Dashboard, error) {
	// Template application implementation
	return nil, nil
}

func (e *DefaultTemplateEngine) ListTemplates(category string) ([]*DashboardTemplate, error) {
	// Template listing implementation
	return nil, nil
}

func (e *DefaultTemplateEngine) UpdateTemplate(template *DashboardTemplate) error {
	// Template update implementation
	return nil
}

func (e *DefaultTemplateEngine) DeleteTemplate(templateID string) error {
	// Template deletion implementation
	return nil
}
