package reporting

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"sort"
	"time"

	"go.uber.org/zap"
)

// ImprovementType defines types of improvements
type ImprovementType string

const (
	ProcessImprovement     ImprovementType = "process"
	PerformanceImprovement ImprovementType = "performance"
	QualityImprovement     ImprovementType = "quality"
	SecurityImprovement    ImprovementType = "security"
	ComplianceImprovement  ImprovementType = "compliance"
	AutomationImprovement  ImprovementType = "automation"
)

// FeedbackType defines feedback categories
type FeedbackType string

const (
	UserFeedback     FeedbackType = "user"
	SystemFeedback   FeedbackType = "system"
	MetricsFeedback  FeedbackType = "metrics"
	ExternalFeedback FeedbackType = "external"
)

// Feedback represents improvement feedback
type Feedback struct {
	ID          string                 `json:"id" db:"id"`
	TenantID    string                 `json:"tenant_id" db:"tenant_id"`
	Type        FeedbackType           `json:"type" db:"type"`
	Source      string                 `json:"source" db:"source"`
	Category    string                 `json:"category" db:"category"`
	Title       string                 `json:"title" db:"title"`
	Description string                 `json:"description" db:"description"`
	Priority    string                 `json:"priority" db:"priority"`
	Impact      string                 `json:"impact" db:"impact"`
	Effort      string                 `json:"effort" db:"effort"`
	Data        map[string]interface{} `json:"data,omitempty" db:"data"`
	Status      string                 `json:"status" db:"status"`
	CreatedAt   time.Time              `json:"created_at" db:"created_at"`
	CreatedBy   string                 `json:"created_by" db:"created_by"`
	ProcessedAt *time.Time             `json:"processed_at,omitempty" db:"processed_at"`
	ProcessedBy string                 `json:"processed_by,omitempty" db:"processed_by"`
}

// ImprovementAction represents an improvement action
type ImprovementAction struct {
	ID                 string              `json:"id" db:"id"`
	TenantID           string              `json:"tenant_id" db:"tenant_id"`
	Type               ImprovementType     `json:"type" db:"type"`
	Title              string              `json:"title" db:"title"`
	Description        string              `json:"description" db:"description"`
	Justification      string              `json:"justification" db:"justification"`
	ExpectedBenefits   []string            `json:"expected_benefits" db:"expected_benefits"`
	ImplementationPlan *ImplementationPlan `json:"implementation_plan" db:"implementation_plan"`
	Metrics            []ImprovementMetric `json:"metrics" db:"metrics"`
	Status             string              `json:"status" db:"status"`
	Priority           int                 `json:"priority" db:"priority"`
	EstimatedROI       float64             `json:"estimated_roi" db:"estimated_roi"`
	ActualROI          *float64            `json:"actual_roi,omitempty" db:"actual_roi"`
	FeedbackSources    []string            `json:"feedback_sources" db:"feedback_sources"`
	ApprovedBy         string              `json:"approved_by,omitempty" db:"approved_by"`
	ApprovedAt         *time.Time          `json:"approved_at,omitempty" db:"approved_at"`
	ImplementedAt      *time.Time          `json:"implemented_at,omitempty" db:"implemented_at"`
	CreatedAt          time.Time           `json:"created_at" db:"created_at"`
	UpdatedAt          time.Time           `json:"updated_at" db:"updated_at"`
}

// ImplementationPlan defines action implementation
type ImplementationPlan struct {
	Phases         []ImplementationPhase `json:"phases"`
	Timeline       *Timeline             `json:"timeline"`
	Resources      []Resource            `json:"resources"`
	Dependencies   []string              `json:"dependencies"`
	RiskAssessment *RiskAssessment       `json:"risk_assessment"`
	RollbackPlan   string                `json:"rollback_plan"`
	TestingPlan    string                `json:"testing_plan"`
	Stakeholders   []string              `json:"stakeholders"`
	Communication  *CommunicationPlan    `json:"communication"`
}

// ImplementationPhase defines implementation phases
type ImplementationPhase struct {
	ID           string        `json:"id"`
	Name         string        `json:"name"`
	Description  string        `json:"description"`
	Tasks        []Task        `json:"tasks"`
	Dependencies []string      `json:"dependencies"`
	Duration     time.Duration `json:"duration"`
	Resources    []Resource    `json:"resources"`
	Milestones   []Milestone   `json:"milestones"`
	Criteria     []string      `json:"criteria"`
}

// Task defines implementation tasks
type Task struct {
	ID           string        `json:"id"`
	Name         string        `json:"name"`
	Description  string        `json:"description"`
	Assignee     string        `json:"assignee"`
	Duration     time.Duration `json:"duration"`
	Status       string        `json:"status"`
	Dependencies []string      `json:"dependencies"`
	CompletedAt  *time.Time    `json:"completed_at,omitempty"`
}

// Resource defines required resources
type Resource struct {
	Type        string  `json:"type"` // human, technical, financial
	Description string  `json:"description"`
	Quantity    float64 `json:"quantity"`
	Unit        string  `json:"unit"`
	Cost        float64 `json:"cost,omitempty"`
}

// Timeline defines implementation timeline
type Timeline struct {
	StartDate  time.Time     `json:"start_date"`
	EndDate    time.Time     `json:"end_date"`
	Milestones []Milestone   `json:"milestones"`
	BufferTime time.Duration `json:"buffer_time"`
}

// Milestone defines project milestones
type Milestone struct {
	ID          string     `json:"id"`
	Name        string     `json:"name"`
	Description string     `json:"description"`
	Date        time.Time  `json:"date"`
	Criteria    []string   `json:"criteria"`
	Status      string     `json:"status"`
	CompletedAt *time.Time `json:"completed_at,omitempty"`
}

// RiskAssessment defines implementation risks
type RiskAssessment struct {
	Risks          []Risk   `json:"risks"`
	OverallScore   float64  `json:"overall_score"`
	MitigationPlan string   `json:"mitigation_plan"`
	Contingencies  []string `json:"contingencies"`
}

// Risk defines individual risks
type Risk struct {
	ID          string  `json:"id"`
	Description string  `json:"description"`
	Probability float64 `json:"probability"` // 0-1
	Impact      float64 `json:"impact"`      // 0-1
	Score       float64 `json:"score"`       // probability * impact
	Mitigation  string  `json:"mitigation"`
	Owner       string  `json:"owner"`
}

// CommunicationPlan defines stakeholder communication
type CommunicationPlan struct {
	Stakeholders []Stakeholder        `json:"stakeholders"`
	Schedule     []CommunicationEvent `json:"schedule"`
	Channels     []string             `json:"channels"`
	Templates    map[string]string    `json:"templates"`
}

// Stakeholder defines project stakeholders
type Stakeholder struct {
	ID        string   `json:"id"`
	Name      string   `json:"name"`
	Role      string   `json:"role"`
	Interest  string   `json:"interest"`
	Influence string   `json:"influence"`
	Contact   string   `json:"contact"`
	Channels  []string `json:"channels"`
}

// CommunicationEvent defines communication events
type CommunicationEvent struct {
	Type        string    `json:"type"`
	Description string    `json:"description"`
	Audience    []string  `json:"audience"`
	Channel     string    `json:"channel"`
	Schedule    time.Time `json:"schedule"`
	Template    string    `json:"template,omitempty"`
}

// ImprovementMetric defines success metrics
type ImprovementMetric struct {
	ID          string     `json:"id"`
	Name        string     `json:"name"`
	Description string     `json:"description"`
	Type        string     `json:"type"` // kpi, performance, quality
	Unit        string     `json:"unit"`
	Baseline    float64    `json:"baseline"`
	Target      float64    `json:"target"`
	Threshold   float64    `json:"threshold"`
	Current     *float64   `json:"current,omitempty"`
	MeasuredAt  *time.Time `json:"measured_at,omitempty"`
}

// AnalysisResult represents improvement analysis
type AnalysisResult struct {
	ID              string                 `json:"id"`
	TenantID        string                 `json:"tenant_id"`
	Type            string                 `json:"type"`
	Period          *DateRange             `json:"period"`
	Scope           string                 `json:"scope"`
	Findings        []Finding              `json:"findings"`
	Recommendations []Recommendation       `json:"recommendations"`
	Trends          []Trend                `json:"trends"`
	Benchmarks      map[string]interface{} `json:"benchmarks"`
	ConfidenceScore float64                `json:"confidence_score"`
	GeneratedAt     time.Time              `json:"generated_at"`
	GeneratedBy     string                 `json:"generated_by"`
}

// Finding represents analysis findings
type Finding struct {
	ID          string                 `json:"id"`
	Category    string                 `json:"category"`
	Type        string                 `json:"type"`
	Severity    string                 `json:"severity"`
	Title       string                 `json:"title"`
	Description string                 `json:"description"`
	Evidence    []Evidence             `json:"evidence"`
	Impact      *ImpactAssessment      `json:"impact"`
	Confidence  float64                `json:"confidence"`
	Data        map[string]interface{} `json:"data,omitempty"`
}

// Evidence supports findings
type Evidence struct {
	Type        string                 `json:"type"`
	Source      string                 `json:"source"`
	Description string                 `json:"description"`
	Data        map[string]interface{} `json:"data"`
	Timestamp   time.Time              `json:"timestamp"`
}

// ImpactAssessment quantifies impact
type ImpactAssessment struct {
	Financial   *FinancialImpact   `json:"financial,omitempty"`
	Operational *OperationalImpact `json:"operational,omitempty"`
	Security    *SecurityImpact    `json:"security,omitempty"`
	Compliance  *ComplianceImpact  `json:"compliance,omitempty"`
	Reputation  *ReputationImpact  `json:"reputation,omitempty"`
}

// FinancialImpact quantifies financial effects
type FinancialImpact struct {
	CostSavings        float64       `json:"cost_savings"`
	RevenueLoss        float64       `json:"revenue_loss"`
	ImplementationCost float64       `json:"implementation_cost"`
	ROI                float64       `json:"roi"`
	PaybackPeriod      time.Duration `json:"payback_period"`
}

// OperationalImpact quantifies operational effects
type OperationalImpact struct {
	EfficiencyGain     float64       `json:"efficiency_gain"`
	TimeReduction      time.Duration `json:"time_reduction"`
	ResourceSavings    float64       `json:"resource_savings"`
	QualityImprovement float64       `json:"quality_improvement"`
}

// SecurityImpact quantifies security effects
type SecurityImpact struct {
	RiskReduction     float64 `json:"risk_reduction"`
	VulnReduction     int     `json:"vuln_reduction"`
	IncidentReduction int     `json:"incident_reduction"`
	ComplianceGain    float64 `json:"compliance_gain"`
}

// ComplianceImpact quantifies compliance effects
type ComplianceImpact struct {
	StandardsImprovement map[string]float64 `json:"standards_improvement"`
	AuditFindings        int                `json:"audit_findings"`
	ComplianceScore      float64            `json:"compliance_score"`
}

// ReputationImpact quantifies reputation effects
type ReputationImpact struct {
	StakeholderTrust float64 `json:"stakeholder_trust"`
	BrandValue       float64 `json:"brand_value"`
	MarketPosition   float64 `json:"market_position"`
}

// Recommendation suggests improvements
type Recommendation struct {
	ID              string               `json:"id"`
	Type            ImprovementType      `json:"type"`
	Priority        string               `json:"priority"`
	Title           string               `json:"title"`
	Description     string               `json:"description"`
	Rationale       string               `json:"rationale"`
	Benefits        []string             `json:"benefits"`
	Implementation  *ImplementationGuide `json:"implementation"`
	Effort          string               `json:"effort"`
	Timeline        string               `json:"timeline"`
	Dependencies    []string             `json:"dependencies"`
	Risks           []string             `json:"risks"`
	SuccessMetrics  []string             `json:"success_metrics"`
	ConfidenceScore float64              `json:"confidence_score"`
	Supporting      []string             `json:"supporting"`
}

// ImplementationGuide provides implementation guidance
type ImplementationGuide struct {
	Steps          []string              `json:"steps"`
	Prerequisites  []string              `json:"prerequisites"`
	Resources      []ResourceRequirement `json:"resources"`
	Considerations []string              `json:"considerations"`
	BestPractices  []string              `json:"best_practices"`
	CommonPitfalls []string              `json:"common_pitfalls"`
	References     []string              `json:"references"`
}

// ResourceRequirement defines resource needs
type ResourceRequirement struct {
	Type        string `json:"type"`
	Description string `json:"description"`
	Estimate    string `json:"estimate"`
	Critical    bool   `json:"critical"`
}

// Trend represents data trends
type Trend struct {
	ID           string    `json:"id"`
	Metric       string    `json:"metric"`
	Direction    string    `json:"direction"` // up, down, stable
	Magnitude    float64   `json:"magnitude"`
	Confidence   float64   `json:"confidence"`
	Period       string    `json:"period"`
	StartDate    time.Time `json:"start_date"`
	EndDate      time.Time `json:"end_date"`
	Description  string    `json:"description"`
	Significance string    `json:"significance"`
}

// ContinuousImprovementEngine manages improvement processes
type ContinuousImprovementEngine struct {
	db         *sql.DB
	logger     *zap.Logger
	config     *ImprovementConfig
	analyzers  map[string]ImprovementAnalyzer
	collectors []FeedbackCollector
	processors []FeedbackProcessor
	generators []RecommendationGenerator
	executors  []ActionExecutor
	monitors   []ProgressMonitor
}

// ImprovementConfig defines engine configuration
type ImprovementConfig struct {
	AnalysisInterval     time.Duration `json:"analysis_interval"`
	FeedbackRetention    time.Duration `json:"feedback_retention"`
	ActionTimeout        time.Duration `json:"action_timeout"`
	MinConfidenceScore   float64       `json:"min_confidence_score"`
	AutoApprovalROI      float64       `json:"auto_approval_roi"`
	MaxConcurrentActions int           `json:"max_concurrent_actions"`
	EnableML             bool          `json:"enable_ml"`
	EnablePrediction     bool          `json:"enable_prediction"`
}

// ImprovementAnalyzer interface for analysis
type ImprovementAnalyzer interface {
	Analyze(ctx context.Context, tenantID string, scope string, period *DateRange) (*AnalysisResult, error)
	GetSupportedTypes() []string
	GetRequiredData() []string
}

// FeedbackCollector interface for feedback collection
type FeedbackCollector interface {
	Collect(ctx context.Context, tenantID string) ([]*Feedback, error)
	GetSourceType() FeedbackType
	GetCategories() []string
}

// FeedbackProcessor interface for feedback processing
type FeedbackProcessor interface {
	Process(ctx context.Context, feedback *Feedback) error
	CanProcess(feedback *Feedback) bool
	GetPriority() int
}

// RecommendationGenerator interface for generating recommendations
type RecommendationGenerator interface {
	Generate(ctx context.Context, analysis *AnalysisResult, feedback []*Feedback) ([]*Recommendation, error)
	GetSupportedTypes() []ImprovementType
	GetConfidenceThreshold() float64
}

// ActionExecutor interface for executing improvements
type ActionExecutor interface {
	Execute(ctx context.Context, action *ImprovementAction) error
	CanExecute(action *ImprovementAction) bool
	GetExecutionTime(action *ImprovementAction) time.Duration
}

// ProgressMonitor interface for monitoring progress
type ProgressMonitor interface {
	Monitor(ctx context.Context, action *ImprovementAction) (*ProgressReport, error)
	GetMonitoringInterval() time.Duration
}

// ProgressReport represents action progress
type ProgressReport struct {
	ActionID            string                 `json:"action_id"`
	Status              string                 `json:"status"`
	Progress            float64                `json:"progress"` // 0-1
	CurrentPhase        string                 `json:"current_phase"`
	CompletedTasks      int                    `json:"completed_tasks"`
	TotalTasks          int                    `json:"total_tasks"`
	Metrics             map[string]interface{} `json:"metrics"`
	Issues              []Issue                `json:"issues"`
	NextMilestone       *Milestone             `json:"next_milestone,omitempty"`
	EstimatedCompletion *time.Time             `json:"estimated_completion,omitempty"`
	LastUpdated         time.Time              `json:"last_updated"`
}

// Issue represents implementation issues
type Issue struct {
	ID          string     `json:"id"`
	Type        string     `json:"type"`
	Severity    string     `json:"severity"`
	Description string     `json:"description"`
	Impact      string     `json:"impact"`
	Resolution  string     `json:"resolution,omitempty"`
	CreatedAt   time.Time  `json:"created_at"`
	ResolvedAt  *time.Time `json:"resolved_at,omitempty"`
}

// NewContinuousImprovementEngine creates new improvement engine
func NewContinuousImprovementEngine(db *sql.DB, logger *zap.Logger, config *ImprovementConfig) *ContinuousImprovementEngine {
	engine := &ContinuousImprovementEngine{
		db:         db,
		logger:     logger,
		config:     config,
		analyzers:  make(map[string]ImprovementAnalyzer),
		collectors: []FeedbackCollector{},
		processors: []FeedbackProcessor{},
		generators: []RecommendationGenerator{},
		executors:  []ActionExecutor{},
		monitors:   []ProgressMonitor{},
	}

	// Register default components
	engine.RegisterAnalyzer("performance", NewPerformanceAnalyzer(db))
	engine.RegisterAnalyzer("security", NewSecurityAnalyzer(db))
	engine.RegisterAnalyzer("process", NewProcessAnalyzer(db))

	return engine
}

// RegisterAnalyzer registers an improvement analyzer
func (cie *ContinuousImprovementEngine) RegisterAnalyzer(name string, analyzer ImprovementAnalyzer) {
	cie.analyzers[name] = analyzer
}

// SubmitFeedback submits feedback for processing
func (cie *ContinuousImprovementEngine) SubmitFeedback(ctx context.Context, feedback *Feedback) error {
	if feedback.ID == "" {
		feedback.ID = generateFeedbackID()
	}
	feedback.CreatedAt = time.Now()
	feedback.Status = "pending"

	// Store feedback
	if err := cie.storeFeedback(ctx, feedback); err != nil {
		return fmt.Errorf("failed to store feedback: %w", err)
	}

	// Process feedback asynchronously
	go func() {
		if err := cie.processFeedback(ctx, feedback); err != nil {
			cie.logger.Warn("Failed to process feedback", zap.Error(err))
		}
	}()

	cie.logger.Info("Feedback submitted",
		zap.String("feedback_id", feedback.ID),
		zap.String("type", string(feedback.Type)))

	return nil
}

// RunAnalysis performs improvement analysis
func (cie *ContinuousImprovementEngine) RunAnalysis(ctx context.Context, tenantID string, scope string) (*AnalysisResult, error) {
	period := &DateRange{
		Start: time.Now().AddDate(0, 0, -30),
		End:   time.Now(),
	}

	var allFindings []Finding
	var allTrends []Trend
	var recommendations []*Recommendation

	// Run all analyzers
	for name, analyzer := range cie.analyzers {
		result, err := analyzer.Analyze(ctx, tenantID, scope, period)
		if err != nil {
			cie.logger.Warn("Analysis failed", zap.String("analyzer", name), zap.Error(err))
			continue
		}

		allFindings = append(allFindings, result.Findings...)
		allTrends = append(allTrends, result.Trends...)
	}

	// Get relevant feedback
	feedback, err := cie.getRecentFeedback(ctx, tenantID, period)
	if err != nil {
		cie.logger.Warn("Failed to get feedback", zap.Error(err))
	}

	// Generate recommendations
	for _, generator := range cie.generators {
		analysisResult := &AnalysisResult{
			Findings: allFindings,
			Trends:   allTrends,
		}

		recs, err := generator.Generate(ctx, analysisResult, feedback)
		if err != nil {
			cie.logger.Warn("Recommendation generation failed", zap.Error(err))
			continue
		}
		recommendations = append(recommendations, recs...)
	}

	// Sort recommendations by priority and confidence
	sort.Slice(recommendations, func(i, j int) bool {
		if recommendations[i].Priority != recommendations[j].Priority {
			return getPriorityScore(recommendations[i].Priority) > getPriorityScore(recommendations[j].Priority)
		}
		return recommendations[i].ConfidenceScore > recommendations[j].ConfidenceScore
	})

	result := &AnalysisResult{
		ID:              generateAnalysisID(),
		TenantID:        tenantID,
		Type:            "comprehensive",
		Period:          period,
		Scope:           scope,
		Findings:        allFindings,
		Recommendations: convertRecommendations(recommendations),
		Trends:          allTrends,
		ConfidenceScore: cie.calculateOverallConfidence(allFindings, recommendations),
		GeneratedAt:     time.Now(),
		GeneratedBy:     "system",
	}

	// Store analysis result
	if err := cie.storeAnalysisResult(ctx, result); err != nil {
		cie.logger.Warn("Failed to store analysis result", zap.Error(err))
	}

	return result, nil
}

// CreateImprovementAction creates a new improvement action
func (cie *ContinuousImprovementEngine) CreateImprovementAction(ctx context.Context, action *ImprovementAction) error {
	if action.ID == "" {
		action.ID = generateActionID()
	}
	action.CreatedAt = time.Now()
	action.UpdatedAt = time.Now()
	action.Status = "pending_approval"

	// Auto-approve if ROI meets threshold
	if action.EstimatedROI >= cie.config.AutoApprovalROI {
		action.Status = "approved"
		action.ApprovedBy = "auto_approval"
		now := time.Now()
		action.ApprovedAt = &now
	}

	// Store action
	if err := cie.storeImprovementAction(ctx, action); err != nil {
		return fmt.Errorf("failed to store improvement action: %w", err)
	}

	cie.logger.Info("Improvement action created",
		zap.String("action_id", action.ID),
		zap.String("type", string(action.Type)),
		zap.String("status", action.Status))

	return nil
}

// Helper methods

func (cie *ContinuousImprovementEngine) processFeedback(ctx context.Context, feedback *Feedback) error {
	for _, processor := range cie.processors {
		if processor.CanProcess(feedback) {
			if err := processor.Process(ctx, feedback); err != nil {
				return err
			}
		}
	}

	feedback.Status = "processed"
	now := time.Now()
	feedback.ProcessedAt = &now
	feedback.ProcessedBy = "system"

	return cie.updateFeedback(ctx, feedback)
}

func (cie *ContinuousImprovementEngine) getRecentFeedback(ctx context.Context, tenantID string, period *DateRange) ([]*Feedback, error) {
	query := `
		SELECT id, tenant_id, type, source, category, title, description, 
		       priority, impact, effort, data, status, created_at, created_by,
		       processed_at, processed_by
		FROM vulnerability_feedback 
		WHERE tenant_id = $1 AND created_at BETWEEN $2 AND $3
		ORDER BY created_at DESC`

	rows, err := cie.db.QueryContext(ctx, query, tenantID, period.Start, period.End)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var feedback []*Feedback
	for rows.Next() {
		fb := &Feedback{}
		var dataJSON []byte

		err := rows.Scan(
			&fb.ID, &fb.TenantID, &fb.Type, &fb.Source, &fb.Category,
			&fb.Title, &fb.Description, &fb.Priority, &fb.Impact,
			&fb.Effort, &dataJSON, &fb.Status, &fb.CreatedAt,
			&fb.CreatedBy, &fb.ProcessedAt, &fb.ProcessedBy,
		)
		if err != nil {
			return nil, err
		}

		if len(dataJSON) > 0 {
			json.Unmarshal(dataJSON, &fb.Data)
		}

		feedback = append(feedback, fb)
	}

	return feedback, nil
}

func (cie *ContinuousImprovementEngine) calculateOverallConfidence(findings []Finding, recommendations []*Recommendation) float64 {
	if len(findings) == 0 && len(recommendations) == 0 {
		return 0.0
	}

	var totalConfidence float64
	var count int

	for _, finding := range findings {
		totalConfidence += finding.Confidence
		count++
	}

	for _, rec := range recommendations {
		totalConfidence += rec.ConfidenceScore
		count++
	}

	return totalConfidence / float64(count)
}

func (cie *ContinuousImprovementEngine) storeFeedback(ctx context.Context, feedback *Feedback) error {
	query := `
		INSERT INTO vulnerability_feedback 
		(id, tenant_id, type, source, category, title, description, priority,
		 impact, effort, data, status, created_at, created_by)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)`

	dataJSON, _ := json.Marshal(feedback.Data)

	_, err := cie.db.ExecContext(ctx, query,
		feedback.ID, feedback.TenantID, feedback.Type, feedback.Source,
		feedback.Category, feedback.Title, feedback.Description,
		feedback.Priority, feedback.Impact, feedback.Effort,
		dataJSON, feedback.Status, feedback.CreatedAt, feedback.CreatedBy,
	)

	return err
}

func (cie *ContinuousImprovementEngine) updateFeedback(ctx context.Context, feedback *Feedback) error {
	query := `
		UPDATE vulnerability_feedback 
		SET status = $3, processed_at = $4, processed_by = $5
		WHERE id = $1 AND tenant_id = $2`

	_, err := cie.db.ExecContext(ctx, query,
		feedback.ID, feedback.TenantID, feedback.Status,
		feedback.ProcessedAt, feedback.ProcessedBy,
	)

	return err
}

func (cie *ContinuousImprovementEngine) storeAnalysisResult(ctx context.Context, result *AnalysisResult) error {
	query := `
		INSERT INTO vulnerability_analysis_results 
		(id, tenant_id, type, period, scope, findings, recommendations, trends,
		 benchmarks, confidence_score, generated_at, generated_by)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)`

	periodJSON, _ := json.Marshal(result.Period)
	findingsJSON, _ := json.Marshal(result.Findings)
	recommendationsJSON, _ := json.Marshal(result.Recommendations)
	trendsJSON, _ := json.Marshal(result.Trends)
	benchmarksJSON, _ := json.Marshal(result.Benchmarks)

	_, err := cie.db.ExecContext(ctx, query,
		result.ID, result.TenantID, result.Type, periodJSON, result.Scope,
		findingsJSON, recommendationsJSON, trendsJSON, benchmarksJSON,
		result.ConfidenceScore, result.GeneratedAt, result.GeneratedBy,
	)

	return err
}

func (cie *ContinuousImprovementEngine) storeImprovementAction(ctx context.Context, action *ImprovementAction) error {
	query := `
		INSERT INTO vulnerability_improvement_actions 
		(id, tenant_id, type, title, description, justification, expected_benefits,
		 implementation_plan, metrics, status, priority, estimated_roi,
		 feedback_sources, approved_by, approved_at, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)`

	benefitsJSON, _ := json.Marshal(action.ExpectedBenefits)
	planJSON, _ := json.Marshal(action.ImplementationPlan)
	metricsJSON, _ := json.Marshal(action.Metrics)
	sourcesJSON, _ := json.Marshal(action.FeedbackSources)

	_, err := cie.db.ExecContext(ctx, query,
		action.ID, action.TenantID, action.Type, action.Title,
		action.Description, action.Justification, benefitsJSON,
		planJSON, metricsJSON, action.Status, action.Priority,
		action.EstimatedROI, sourcesJSON, action.ApprovedBy,
		action.ApprovedAt, action.CreatedAt, action.UpdatedAt,
	)

	return err
}

// Utility functions

func generateFeedbackID() string {
	return fmt.Sprintf("feedback_%d", time.Now().UnixNano())
}

func generateAnalysisID() string {
	return fmt.Sprintf("analysis_%d", time.Now().UnixNano())
}

func generateActionID() string {
	return fmt.Sprintf("action_%d", time.Now().UnixNano())
}

func getPriorityScore(priority string) int {
	switch priority {
	case "critical":
		return 4
	case "high":
		return 3
	case "medium":
		return 2
	case "low":
		return 1
	default:
		return 0
	}
}

func convertRecommendations(recs []*Recommendation) []Recommendation {
	result := make([]Recommendation, len(recs))
	for i, rec := range recs {
		result[i] = *rec
	}
	return result
}

// Placeholder analyzer implementations

type PerformanceAnalyzer struct {
	db *sql.DB
}

func NewPerformanceAnalyzer(db *sql.DB) *PerformanceAnalyzer {
	return &PerformanceAnalyzer{db: db}
}

func (pa *PerformanceAnalyzer) Analyze(ctx context.Context, tenantID string, scope string, period *DateRange) (*AnalysisResult, error) {
	// Implementation for performance analysis
	return &AnalysisResult{
		Findings: []Finding{},
		Trends:   []Trend{},
	}, nil
}

func (pa *PerformanceAnalyzer) GetSupportedTypes() []string {
	return []string{"performance", "efficiency"}
}

func (pa *PerformanceAnalyzer) GetRequiredData() []string {
	return []string{"metrics", "performance_logs"}
}

type SecurityAnalyzer struct {
	db *sql.DB
}

func NewSecurityAnalyzer(db *sql.DB) *SecurityAnalyzer {
	return &SecurityAnalyzer{db: db}
}

func (sa *SecurityAnalyzer) Analyze(ctx context.Context, tenantID string, scope string, period *DateRange) (*AnalysisResult, error) {
	// Implementation for security analysis
	return &AnalysisResult{
		Findings: []Finding{},
		Trends:   []Trend{},
	}, nil
}

func (sa *SecurityAnalyzer) GetSupportedTypes() []string {
	return []string{"security", "compliance"}
}

func (sa *SecurityAnalyzer) GetRequiredData() []string {
	return []string{"vulnerabilities", "incidents", "compliance_data"}
}

type ProcessAnalyzer struct {
	db *sql.DB
}

func NewProcessAnalyzer(db *sql.DB) *ProcessAnalyzer {
	return &ProcessAnalyzer{db: db}
}

func (pa *ProcessAnalyzer) Analyze(ctx context.Context, tenantID string, scope string, period *DateRange) (*AnalysisResult, error) {
	// Implementation for process analysis
	return &AnalysisResult{
		Findings: []Finding{},
		Trends:   []Trend{},
	}, nil
}

func (pa *ProcessAnalyzer) GetSupportedTypes() []string {
	return []string{"process", "workflow"}
}

func (pa *ProcessAnalyzer) GetRequiredData() []string {
	return []string{"process_metrics", "workflow_data"}
}
