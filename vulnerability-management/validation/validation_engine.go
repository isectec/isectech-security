package validation

import (
	"context"
	"fmt"
	"log/slog"
	"math"
	"regexp"
	"sort"
	"strings"
	"sync"
	"time"
)

// ValidationEngine coordinates all vulnerability validation processes
type ValidationEngine struct {
	config                ValidationConfig
	logger                *slog.Logger
	falsePositiveDetector *FalsePositiveDetector
	validationRules       []ValidationRule
	scoringEngine         *ScoringEngine
	externalValidators    map[string]ExternalValidator
	statistics            ValidationStatistics
	cache                 ValidationCache
	mutex                 sync.RWMutex
}

// ValidationConfig defines configuration for the validation engine
type ValidationConfig struct {
	// False positive detection
	EnableMLDetection      bool          `json:"enable_ml_detection"`
	FalsePositiveThreshold float64       `json:"false_positive_threshold"`
	MinConfidenceScore     float64       `json:"min_confidence_score"`
	MaxValidationTime      time.Duration `json:"max_validation_time"`

	// External validation
	EnableExternalValidation bool                       `json:"enable_external_validation"`
	ExternalValidators       map[string]ValidatorConfig `json:"external_validators"`
	ValidationTimeout        time.Duration              `json:"validation_timeout"`
	MaxConcurrentValidations int                        `json:"max_concurrent_validations"`

	// Rule-based validation
	EnableRuleValidation bool             `json:"enable_rule_validation"`
	CustomRules          []ValidationRule `json:"custom_rules"`
	RuleSetPath          string           `json:"rule_set_path"`

	// Scoring and prioritization
	EnablePrioritization   bool           `json:"enable_prioritization"`
	ScoringWeights         ScoringWeights `json:"scoring_weights"`
	BusinessCriticalAssets []string       `json:"business_critical_assets"`

	// Performance settings
	CacheEnabled    bool          `json:"cache_enabled"`
	CacheExpiration time.Duration `json:"cache_expiration"`
	CacheMaxSize    int           `json:"cache_max_size"`

	// iSECTECH specific settings
	TenantIsolation          bool     `json:"tenant_isolation"`
	CustomValidationPipeline []string `json:"custom_validation_pipeline"`
	ComplianceValidation     bool     `json:"compliance_validation"`
	PrivacyMode              bool     `json:"privacy_mode"`
}

// ValidatorConfig defines external validator configuration
type ValidatorConfig struct {
	Enabled      bool                   `json:"enabled"`
	Endpoint     string                 `json:"endpoint"`
	APIKey       string                 `json:"api_key"`
	Timeout      time.Duration          `json:"timeout"`
	RateLimit    int                    `json:"rate_limit"`
	Weight       float64                `json:"weight"`
	Priority     int                    `json:"priority"`
	CustomConfig map[string]interface{} `json:"custom_config"`
}

// ValidationRule defines a custom validation rule
type ValidationRule struct {
	ID          string                 `json:"id"`
	Name        string                 `json:"name"`
	Description string                 `json:"description"`
	Enabled     bool                   `json:"enabled"`
	Priority    int                    `json:"priority"`
	Conditions  []RuleCondition        `json:"conditions"`
	Actions     []RuleAction           `json:"actions"`
	Metadata    map[string]interface{} `json:"metadata"`
}

// RuleCondition defines conditions for validation rules
type RuleCondition struct {
	Field     string      `json:"field"`
	Operator  string      `json:"operator"`
	Value     interface{} `json:"value"`
	LogicalOp string      `json:"logical_op,omitempty"`
}

// RuleAction defines actions to take when rule conditions are met
type RuleAction struct {
	Type       string                 `json:"type"`
	Parameters map[string]interface{} `json:"parameters"`
}

// ScoringWeights defines weights for vulnerability scoring
type ScoringWeights struct {
	CVSSScore           float64 `json:"cvss_score"`
	ExploitAvailability float64 `json:"exploit_availability"`
	AssetCriticality    float64 `json:"asset_criticality"`
	NetworkExposure     float64 `json:"network_exposure"`
	PatchAvailability   float64 `json:"patch_availability"`
	ThreatIntelligence  float64 `json:"threat_intelligence"`
	BusinessImpact      float64 `json:"business_impact"`
	ComplianceImpact    float64 `json:"compliance_impact"`
}

// ValidationResult represents the result of vulnerability validation
type ValidationResult struct {
	VulnerabilityID    string                 `json:"vulnerability_id"`
	IsValid            bool                   `json:"is_valid"`
	ConfidenceScore    float64                `json:"confidence_score"`
	PriorityScore      float64                `json:"priority_score"`
	FalsePositiveRisk  float64                `json:"false_positive_risk"`
	ValidationReasons  []string               `json:"validation_reasons"`
	ExternalValidation map[string]bool        `json:"external_validation"`
	RuleMatches        []string               `json:"rule_matches"`
	EnrichmentData     map[string]interface{} `json:"enrichment_data"`
	ProcessingTime     time.Duration          `json:"processing_time"`
	Timestamp          time.Time              `json:"timestamp"`
}

// ValidationStatistics tracks validation engine performance
type ValidationStatistics struct {
	TotalValidated         int64     `json:"total_validated"`
	ValidVulnerabilities   int64     `json:"valid_vulnerabilities"`
	FalsePositivesDetected int64     `json:"false_positives_detected"`
	AverageConfidenceScore float64   `json:"average_confidence_score"`
	AverageProcessingTime  float64   `json:"average_processing_time"`
	ExternalValidationRate float64   `json:"external_validation_rate"`
	CacheHitRate           float64   `json:"cache_hit_rate"`
	ErrorRate              float64   `json:"error_rate"`
	LastUpdate             time.Time `json:"last_update"`
}

// ValidationCache provides caching for validation results
type ValidationCache struct {
	cache   map[string]*ValidationResult
	ttl     map[string]time.Time
	mutex   sync.RWMutex
	maxSize int
	enabled bool
}

// FalsePositiveDetector identifies likely false positives
type FalsePositiveDetector struct {
	config              FPDetectorConfig
	mlModel             MLModel
	statisticalAnalyzer *StatisticalAnalyzer
	patternMatcher      *PatternMatcher
	logger              *slog.Logger
}

// FPDetectorConfig configures false positive detection
type FPDetectorConfig struct {
	EnableMLDetection         bool          `json:"enable_ml_detection"`
	EnableStatisticalAnalysis bool          `json:"enable_statistical_analysis"`
	EnablePatternMatching     bool          `json:"enable_pattern_matching"`
	ThresholdScore            float64       `json:"threshold_score"`
	ModelPath                 string        `json:"model_path"`
	UpdateInterval            time.Duration `json:"update_interval"`
}

// ScoringEngine calculates vulnerability priority scores
type ScoringEngine struct {
	config           ScoringConfig
	weights          ScoringWeights
	assetCriticality map[string]float64
	threatIntel      ThreatIntelligenceService
	logger           *slog.Logger
}

// ScoringConfig configures the scoring engine
type ScoringConfig struct {
	EnableCustomScoring  bool               `json:"enable_custom_scoring"`
	DefaultWeights       ScoringWeights     `json:"default_weights"`
	AssetCriticalityMap  map[string]float64 `json:"asset_criticality_map"`
	MaxScore             float64            `json:"max_score"`
	MinScore             float64            `json:"min_score"`
	NormalizationEnabled bool               `json:"normalization_enabled"`
}

// ExternalValidator interface for external validation services
type ExternalValidator interface {
	ValidateVulnerability(ctx context.Context, vuln *Vulnerability) (*ExternalValidationResult, error)
	GetServiceInfo() ValidatorInfo
	IsHealthy(ctx context.Context) bool
}

// ExternalValidationResult represents external validation results
type ExternalValidationResult struct {
	ServiceName     string                 `json:"service_name"`
	IsValid         bool                   `json:"is_valid"`
	ConfidenceScore float64                `json:"confidence_score"`
	Metadata        map[string]interface{} `json:"metadata"`
	ResponseTime    time.Duration          `json:"response_time"`
}

// ValidatorInfo provides information about external validators
type ValidatorInfo struct {
	Name         string   `json:"name"`
	Version      string   `json:"version"`
	Description  string   `json:"description"`
	Capabilities []string `json:"capabilities"`
}

// Vulnerability represents a vulnerability for validation
type Vulnerability struct {
	ID               string                 `json:"id"`
	Title            string                 `json:"title"`
	Description      string                 `json:"description"`
	CVE              string                 `json:"cve,omitempty"`
	CVSS             float64                `json:"cvss"`
	Severity         string                 `json:"severity"`
	AssetID          string                 `json:"asset_id"`
	ScannerID        string                 `json:"scanner_id"`
	DiscoveryTime    time.Time              `json:"discovery_time"`
	Evidence         map[string]interface{} `json:"evidence"`
	TechnicalDetails map[string]interface{} `json:"technical_details"`
	NetworkContext   NetworkContext         `json:"network_context"`
}

// NetworkContext provides network-related vulnerability context
type NetworkContext struct {
	SourceIP         string `json:"source_ip"`
	DestinationIP    string `json:"destination_ip"`
	Port             int    `json:"port"`
	Protocol         string `json:"protocol"`
	IsExternalFacing bool   `json:"is_external_facing"`
	NetworkSegment   string `json:"network_segment"`
}

// NewValidationEngine creates a new validation engine instance
func NewValidationEngine(config ValidationConfig, logger *slog.Logger) (*ValidationEngine, error) {
	if logger == nil {
		logger = slog.Default()
	}

	// Initialize false positive detector
	fpDetector, err := NewFalsePositiveDetector(FPDetectorConfig{
		EnableMLDetection:         config.EnableMLDetection,
		EnableStatisticalAnalysis: true,
		EnablePatternMatching:     true,
		ThresholdScore:            config.FalsePositiveThreshold,
		UpdateInterval:            time.Hour,
	}, logger)
	if err != nil {
		return nil, fmt.Errorf("failed to create false positive detector: %w", err)
	}

	// Initialize scoring engine
	scoringEngine := NewScoringEngine(ScoringConfig{
		EnableCustomScoring:  config.EnablePrioritization,
		DefaultWeights:       config.ScoringWeights,
		MaxScore:             10.0,
		MinScore:             0.0,
		NormalizationEnabled: true,
	}, logger)

	// Initialize cache
	cache := ValidationCache{
		cache:   make(map[string]*ValidationResult),
		ttl:     make(map[string]time.Time),
		maxSize: config.CacheMaxSize,
		enabled: config.CacheEnabled,
	}

	engine := &ValidationEngine{
		config:                config,
		logger:                logger,
		falsePositiveDetector: fpDetector,
		validationRules:       config.CustomRules,
		scoringEngine:         scoringEngine,
		externalValidators:    make(map[string]ExternalValidator),
		cache:                 cache,
		statistics: ValidationStatistics{
			LastUpdate: time.Now(),
		},
	}

	// Initialize external validators
	if config.EnableExternalValidation {
		for name, validatorConfig := range config.ExternalValidators {
			if !validatorConfig.Enabled {
				continue
			}

			validator, err := engine.createExternalValidator(name, validatorConfig)
			if err != nil {
				logger.Warn("Failed to initialize external validator",
					"validator", name,
					"error", err)
				continue
			}

			engine.externalValidators[name] = validator
		}
	}

	return engine, nil
}

// ValidateVulnerability validates a single vulnerability
func (ve *ValidationEngine) ValidateVulnerability(ctx context.Context, vuln *Vulnerability) (*ValidationResult, error) {
	startTime := time.Now()

	// Check cache first
	if ve.config.CacheEnabled {
		if cached := ve.getCachedResult(vuln.ID); cached != nil {
			return cached, nil
		}
	}

	result := &ValidationResult{
		VulnerabilityID:    vuln.ID,
		ValidationReasons:  make([]string, 0),
		ExternalValidation: make(map[string]bool),
		RuleMatches:        make([]string, 0),
		EnrichmentData:     make(map[string]interface{}),
		Timestamp:          time.Now(),
	}

	// Apply validation timeout
	validationCtx, cancel := context.WithTimeout(ctx, ve.config.MaxValidationTime)
	defer cancel()

	// Step 1: False positive detection
	fpRisk, err := ve.falsePositiveDetector.AnalyzeVulnerability(validationCtx, vuln)
	if err != nil {
		ve.logger.Warn("False positive detection failed",
			"vulnerability_id", vuln.ID,
			"error", err)
		fpRisk = 0.0 // Default to no false positive risk
	}
	result.FalsePositiveRisk = fpRisk

	// Step 2: Rule-based validation
	if ve.config.EnableRuleValidation {
		ruleResults := ve.applyValidationRules(validationCtx, vuln)
		result.RuleMatches = ruleResults
		if len(ruleResults) > 0 {
			result.ValidationReasons = append(result.ValidationReasons, "Rule-based validation passed")
		}
	}

	// Step 3: External validation
	if ve.config.EnableExternalValidation {
		externalResults := ve.performExternalValidation(validationCtx, vuln)
		result.ExternalValidation = externalResults

		validCount := 0
		for _, isValid := range externalResults {
			if isValid {
				validCount++
			}
		}

		if validCount > 0 {
			result.ValidationReasons = append(result.ValidationReasons,
				fmt.Sprintf("External validation passed (%d/%d validators)", validCount, len(externalResults)))
		}
	}

	// Step 4: Calculate confidence score
	result.ConfidenceScore = ve.calculateConfidenceScore(result, vuln)

	// Step 5: Determine validity
	result.IsValid = result.ConfidenceScore >= ve.config.MinConfidenceScore &&
		result.FalsePositiveRisk < ve.config.FalsePositiveThreshold

	// Step 6: Calculate priority score
	if ve.config.EnablePrioritization && result.IsValid {
		priorityScore, err := ve.scoringEngine.CalculatePriorityScore(validationCtx, vuln, result)
		if err != nil {
			ve.logger.Warn("Priority scoring failed",
				"vulnerability_id", vuln.ID,
				"error", err)
			priorityScore = 5.0 // Default medium priority
		}
		result.PriorityScore = priorityScore
	}

	// Step 7: Record processing time and update statistics
	result.ProcessingTime = time.Since(startTime)
	ve.updateStatistics(result)

	// Step 8: Cache result
	if ve.config.CacheEnabled {
		ve.cacheResult(vuln.ID, result)
	}

	return result, nil
}

// ValidateBatch validates multiple vulnerabilities in parallel
func (ve *ValidationEngine) ValidateBatch(ctx context.Context, vulnerabilities []*Vulnerability) ([]*ValidationResult, error) {
	results := make([]*ValidationResult, len(vulnerabilities))
	semaphore := make(chan struct{}, ve.config.MaxConcurrentValidations)

	var wg sync.WaitGroup
	var mu sync.Mutex
	var validationErrors []error

	for i, vuln := range vulnerabilities {
		wg.Add(1)
		go func(index int, vulnerability *Vulnerability) {
			defer wg.Done()

			semaphore <- struct{}{}
			defer func() { <-semaphore }()

			result, err := ve.ValidateVulnerability(ctx, vulnerability)

			mu.Lock()
			if err != nil {
				validationErrors = append(validationErrors, fmt.Errorf("validation failed for %s: %w", vulnerability.ID, err))
				results[index] = &ValidationResult{
					VulnerabilityID: vulnerability.ID,
					IsValid:         false,
					ConfidenceScore: 0.0,
					Timestamp:       time.Now(),
				}
			} else {
				results[index] = result
			}
			mu.Unlock()
		}(i, vuln)
	}

	wg.Wait()

	if len(validationErrors) > 0 {
		ve.logger.Warn("Some validations failed",
			"total_errors", len(validationErrors),
			"total_vulnerabilities", len(vulnerabilities))
	}

	return results, nil
}

// applyValidationRules applies custom validation rules
func (ve *ValidationEngine) applyValidationRules(ctx context.Context, vuln *Vulnerability) []string {
	var matchedRules []string

	for _, rule := range ve.validationRules {
		if !rule.Enabled {
			continue
		}

		if ve.evaluateRuleConditions(rule.Conditions, vuln) {
			matchedRules = append(matchedRules, rule.ID)

			// Execute rule actions
			for _, action := range rule.Actions {
				ve.executeRuleAction(action, vuln)
			}
		}
	}

	return matchedRules
}

// evaluateRuleConditions evaluates rule conditions against vulnerability
func (ve *ValidationEngine) evaluateRuleConditions(conditions []RuleCondition, vuln *Vulnerability) bool {
	if len(conditions) == 0 {
		return true
	}

	result := true
	currentLogicalOp := "AND"

	for _, condition := range conditions {
		conditionResult := ve.evaluateCondition(condition, vuln)

		switch currentLogicalOp {
		case "AND":
			result = result && conditionResult
		case "OR":
			result = result || conditionResult
		case "NOT":
			result = result && !conditionResult
		}

		if condition.LogicalOp != "" {
			currentLogicalOp = condition.LogicalOp
		}
	}

	return result
}

// evaluateCondition evaluates a single condition
func (ve *ValidationEngine) evaluateCondition(condition RuleCondition, vuln *Vulnerability) bool {
	fieldValue := ve.getFieldValue(condition.Field, vuln)

	switch condition.Operator {
	case "equals":
		return ve.compareValues(fieldValue, condition.Value, "==")
	case "not_equals":
		return ve.compareValues(fieldValue, condition.Value, "!=")
	case "greater_than":
		return ve.compareValues(fieldValue, condition.Value, ">")
	case "less_than":
		return ve.compareValues(fieldValue, condition.Value, "<")
	case "contains":
		return ve.stringContains(fieldValue, condition.Value)
	case "regex":
		return ve.regexMatch(fieldValue, condition.Value)
	case "in":
		return ve.valueInList(fieldValue, condition.Value)
	default:
		return false
	}
}

// getFieldValue extracts field value from vulnerability
func (ve *ValidationEngine) getFieldValue(field string, vuln *Vulnerability) interface{} {
	switch field {
	case "cvss":
		return vuln.CVSS
	case "severity":
		return vuln.Severity
	case "cve":
		return vuln.CVE
	case "scanner_id":
		return vuln.ScannerID
	case "asset_id":
		return vuln.AssetID
	case "port":
		return vuln.NetworkContext.Port
	case "protocol":
		return vuln.NetworkContext.Protocol
	case "is_external_facing":
		return vuln.NetworkContext.IsExternalFacing
	default:
		// Check technical details
		if val, exists := vuln.TechnicalDetails[field]; exists {
			return val
		}
		// Check evidence
		if val, exists := vuln.Evidence[field]; exists {
			return val
		}
		return nil
	}
}

// Helper methods for condition evaluation
func (ve *ValidationEngine) compareValues(a, b interface{}, operator string) bool {
	// Implementation depends on types and operator
	// This is a simplified version
	switch operator {
	case "==":
		return fmt.Sprintf("%v", a) == fmt.Sprintf("%v", b)
	case "!=":
		return fmt.Sprintf("%v", a) != fmt.Sprintf("%v", b)
	// Add numeric comparisons for > and < operators
	default:
		return false
	}
}

func (ve *ValidationEngine) stringContains(haystack, needle interface{}) bool {
	haystackStr := fmt.Sprintf("%v", haystack)
	needleStr := fmt.Sprintf("%v", needle)
	return strings.Contains(strings.ToLower(haystackStr), strings.ToLower(needleStr))
}

func (ve *ValidationEngine) regexMatch(value, pattern interface{}) bool {
	valueStr := fmt.Sprintf("%v", value)
	patternStr := fmt.Sprintf("%v", pattern)

	regex, err := regexp.Compile(patternStr)
	if err != nil {
		return false
	}

	return regex.MatchString(valueStr)
}

func (ve *ValidationEngine) valueInList(value, list interface{}) bool {
	// Convert list to slice and check if value exists
	// This is a simplified implementation
	valueStr := fmt.Sprintf("%v", value)
	listStr := fmt.Sprintf("%v", list)
	return strings.Contains(listStr, valueStr)
}

// executeRuleAction executes a rule action
func (ve *ValidationEngine) executeRuleAction(action RuleAction, vuln *Vulnerability) {
	switch action.Type {
	case "log":
		level := action.Parameters["level"].(string)
		message := action.Parameters["message"].(string)
		switch level {
		case "info":
			ve.logger.Info(message, "vulnerability_id", vuln.ID)
		case "warn":
			ve.logger.Warn(message, "vulnerability_id", vuln.ID)
		case "error":
			ve.logger.Error(message, "vulnerability_id", vuln.ID)
		}
	case "tag":
		// Add tags to vulnerability (implementation specific)
		tag := action.Parameters["tag"].(string)
		if vuln.TechnicalDetails == nil {
			vuln.TechnicalDetails = make(map[string]interface{})
		}
		tags, exists := vuln.TechnicalDetails["tags"].([]string)
		if !exists {
			tags = make([]string, 0)
		}
		vuln.TechnicalDetails["tags"] = append(tags, tag)
	case "set_severity":
		severity := action.Parameters["severity"].(string)
		vuln.Severity = severity
	}
}

// performExternalValidation performs validation using external services
func (ve *ValidationEngine) performExternalValidation(ctx context.Context, vuln *Vulnerability) map[string]bool {
	results := make(map[string]bool)

	var wg sync.WaitGroup
	var mu sync.Mutex

	for name, validator := range ve.externalValidators {
		wg.Add(1)
		go func(validatorName string, v ExternalValidator) {
			defer wg.Done()

			validationCtx, cancel := context.WithTimeout(ctx, ve.config.ValidationTimeout)
			defer cancel()

			result, err := v.ValidateVulnerability(validationCtx, vuln)

			mu.Lock()
			if err != nil {
				ve.logger.Warn("External validation failed",
					"validator", validatorName,
					"vulnerability_id", vuln.ID,
					"error", err)
				results[validatorName] = false
			} else {
				results[validatorName] = result.IsValid
			}
			mu.Unlock()
		}(name, validator)
	}

	wg.Wait()
	return results
}

// calculateConfidenceScore calculates overall confidence score
func (ve *ValidationEngine) calculateConfidenceScore(result *ValidationResult, vuln *Vulnerability) float64 {
	var score float64 = 0.0
	var weights float64 = 0.0

	// False positive risk (inverse relationship)
	fpWeight := 0.3
	fpScore := math.Max(0, 1.0-result.FalsePositiveRisk)
	score += fpScore * fpWeight
	weights += fpWeight

	// External validation
	if len(result.ExternalValidation) > 0 {
		extWeight := 0.4
		validCount := 0
		for _, isValid := range result.ExternalValidation {
			if isValid {
				validCount++
			}
		}
		extScore := float64(validCount) / float64(len(result.ExternalValidation))
		score += extScore * extWeight
		weights += extWeight
	}

	// Rule validation
	if len(result.RuleMatches) > 0 {
		ruleWeight := 0.2
		// More matched rules = higher confidence
		ruleScore := math.Min(1.0, float64(len(result.RuleMatches))/3.0)
		score += ruleScore * ruleWeight
		weights += ruleWeight
	}

	// CVSS score influence
	cvssWeight := 0.1
	cvssScore := math.Min(1.0, vuln.CVSS/10.0)
	score += cvssScore * cvssWeight
	weights += cvssWeight

	if weights > 0 {
		return score / weights
	}

	return 0.5 // Default medium confidence
}

// Cache management methods
func (ve *ValidationEngine) getCachedResult(vulnerabilityID string) *ValidationResult {
	ve.cache.mutex.RLock()
	defer ve.cache.mutex.RUnlock()

	if !ve.cache.enabled {
		return nil
	}

	result, exists := ve.cache.cache[vulnerabilityID]
	if !exists {
		return nil
	}

	// Check TTL
	if ttl, exists := ve.cache.ttl[vulnerabilityID]; exists {
		if time.Now().After(ttl) {
			// Remove expired entry
			delete(ve.cache.cache, vulnerabilityID)
			delete(ve.cache.ttl, vulnerabilityID)
			return nil
		}
	}

	return result
}

func (ve *ValidationEngine) cacheResult(vulnerabilityID string, result *ValidationResult) {
	ve.cache.mutex.Lock()
	defer ve.cache.mutex.Unlock()

	if !ve.cache.enabled {
		return
	}

	// Check cache size limit
	if len(ve.cache.cache) >= ve.cache.maxSize {
		// Remove oldest entries (simplified LRU)
		ve.evictOldestCacheEntries(ve.cache.maxSize / 4)
	}

	ve.cache.cache[vulnerabilityID] = result
	ve.cache.ttl[vulnerabilityID] = time.Now().Add(ve.config.CacheExpiration)
}

func (ve *ValidationEngine) evictOldestCacheEntries(count int) {
	// Get all TTL entries and sort by time
	type cacheEntry struct {
		id  string
		ttl time.Time
	}

	entries := make([]cacheEntry, 0, len(ve.cache.ttl))
	for id, ttl := range ve.cache.ttl {
		entries = append(entries, cacheEntry{id: id, ttl: ttl})
	}

	sort.Slice(entries, func(i, j int) bool {
		return entries[i].ttl.Before(entries[j].ttl)
	})

	// Remove oldest entries
	for i := 0; i < count && i < len(entries); i++ {
		id := entries[i].id
		delete(ve.cache.cache, id)
		delete(ve.cache.ttl, id)
	}
}

// updateStatistics updates validation statistics
func (ve *ValidationEngine) updateStatistics(result *ValidationResult) {
	ve.mutex.Lock()
	defer ve.mutex.Unlock()

	ve.statistics.TotalValidated++

	if result.IsValid {
		ve.statistics.ValidVulnerabilities++
	}

	if result.FalsePositiveRisk > ve.config.FalsePositiveThreshold {
		ve.statistics.FalsePositivesDetected++
	}

	// Update averages
	totalProcessingTime := ve.statistics.AverageProcessingTime * float64(ve.statistics.TotalValidated-1)
	totalProcessingTime += result.ProcessingTime.Seconds()
	ve.statistics.AverageProcessingTime = totalProcessingTime / float64(ve.statistics.TotalValidated)

	totalConfidenceScore := ve.statistics.AverageConfidenceScore * float64(ve.statistics.TotalValidated-1)
	totalConfidenceScore += result.ConfidenceScore
	ve.statistics.AverageConfidenceScore = totalConfidenceScore / float64(ve.statistics.TotalValidated)

	ve.statistics.LastUpdate = time.Now()
}

// GetStatistics returns current validation statistics
func (ve *ValidationEngine) GetStatistics() ValidationStatistics {
	ve.mutex.RLock()
	defer ve.mutex.RUnlock()
	return ve.statistics
}

// createExternalValidator creates an external validator instance
func (ve *ValidationEngine) createExternalValidator(name string, config ValidatorConfig) (ExternalValidator, error) {
	// Factory pattern for creating different types of external validators
	switch name {
	case "nist_nvd":
		return NewNISTNVDValidator(config)
	case "mitre_cve":
		return NewMITRECVEValidator(config)
	case "vulndb":
		return NewVulnDBValidator(config)
	case "isectech_custom":
		return NewISECTECHCustomValidator(config)
	default:
		return nil, fmt.Errorf("unknown validator type: %s", name)
	}
}

// Close gracefully shuts down the validation engine
func (ve *ValidationEngine) Close() error {
	ve.logger.Info("Shutting down validation engine")

	// Close external validators
	for name, validator := range ve.externalValidators {
		if closer, ok := validator.(interface{ Close() error }); ok {
			if err := closer.Close(); err != nil {
				ve.logger.Warn("Failed to close external validator",
					"validator", name,
					"error", err)
			}
		}
	}

	// Clear cache
	ve.cache.mutex.Lock()
	ve.cache.cache = make(map[string]*ValidationResult)
	ve.cache.ttl = make(map[string]time.Time)
	ve.cache.mutex.Unlock()

	return nil
}

// Placeholder interfaces and types for external components
type MLModel interface {
	Predict(features []float64) (float64, error)
	IsLoaded() bool
}

type StatisticalAnalyzer struct {
	// Implementation for statistical analysis
}

type PatternMatcher struct {
	// Implementation for pattern matching
}

type ThreatIntelligenceService interface {
	GetThreatScore(ctx context.Context, cve string) (float64, error)
}
