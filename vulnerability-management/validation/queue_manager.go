package validation

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"sort"
	"sync"
	"time"
)

// QueueManager manages vulnerability processing jobs
type QueueManager struct {
	config     QueueConfig
	logger     *slog.Logger
	queue      *PriorityQueue
	jobs       map[string]*VulnerabilityJob
	statistics QueueStatistics
	isRunning  bool
	mutex      sync.RWMutex
}

// QueueConfig defines configuration for the queue manager
type QueueConfig struct {
	MaxSize         int           `json:"max_size"`
	Persistence     bool          `json:"persistence"`
	RetryAttempts   int           `json:"retry_attempts"`
	RetryDelay      time.Duration `json:"retry_delay"`
	PersistencePath string        `json:"persistence_path"`
	CleanupInterval time.Duration `json:"cleanup_interval"`
	JobTTL          time.Duration `json:"job_ttl"`
}

// QueueStatistics tracks queue performance
type QueueStatistics struct {
	TotalEnqueued   int64     `json:"total_enqueued"`
	TotalDequeued   int64     `json:"total_dequeued"`
	PendingJobs     int64     `json:"pending_jobs"`
	ActiveJobs      int64     `json:"active_jobs"`
	CompletedJobs   int64     `json:"completed_jobs"`
	FailedJobs      int64     `json:"failed_jobs"`
	AverageWaitTime float64   `json:"average_wait_time"`
	LastUpdate      time.Time `json:"last_update"`
}

// PriorityQueue implements a priority queue for vulnerability jobs
type PriorityQueue struct {
	items []*QueueItem
	mutex sync.RWMutex
}

// QueueItem wraps a job with priority information
type QueueItem struct {
	Job         *VulnerabilityJob `json:"job"`
	Priority    int               `json:"priority"`
	EnqueueTime time.Time         `json:"enqueue_time"`
}

// NewQueueManager creates a new queue manager
func NewQueueManager(config QueueConfig, logger *slog.Logger) (*QueueManager, error) {
	if logger == nil {
		logger = slog.Default()
	}

	// Set defaults
	if config.CleanupInterval == 0 {
		config.CleanupInterval = time.Hour
	}
	if config.JobTTL == 0 {
		config.JobTTL = time.Hour * 24 * 7 // 7 days
	}
	if config.PersistencePath == "" {
		config.PersistencePath = "/tmp/vulnerability_queue.json"
	}

	qm := &QueueManager{
		config: config,
		logger: logger,
		queue:  NewPriorityQueue(),
		jobs:   make(map[string]*VulnerabilityJob),
		statistics: QueueStatistics{
			LastUpdate: time.Now(),
		},
	}

	// Load persisted jobs if persistence is enabled
	if config.Persistence {
		if err := qm.loadPersistedJobs(); err != nil {
			logger.Warn("Failed to load persisted jobs", "error", err)
		}
	}

	return qm, nil
}

// Start starts the queue manager
func (qm *QueueManager) Start(ctx context.Context) error {
	qm.mutex.Lock()
	qm.isRunning = true
	qm.mutex.Unlock()

	qm.logger.Info("Starting queue manager")

	// Start cleanup routine
	go qm.cleanupRoutine(ctx)

	// Start persistence routine if enabled
	if qm.config.Persistence {
		go qm.persistenceRoutine(ctx)
	}

	return nil
}

// Stop stops the queue manager
func (qm *QueueManager) Stop(ctx context.Context) error {
	qm.mutex.Lock()
	qm.isRunning = false
	qm.mutex.Unlock()

	qm.logger.Info("Stopping queue manager")

	// Persist current state if persistence is enabled
	if qm.config.Persistence {
		if err := qm.persistJobs(); err != nil {
			qm.logger.Error("Failed to persist jobs on shutdown", "error", err)
		}
	}

	return nil
}

// Enqueue adds a job to the queue
func (qm *QueueManager) Enqueue(job *VulnerabilityJob) error {
	qm.mutex.Lock()
	defer qm.mutex.Unlock()

	// Check queue size limit
	if len(qm.queue.items) >= qm.config.MaxSize {
		return fmt.Errorf("queue is full (max size: %d)", qm.config.MaxSize)
	}

	// Create queue item
	item := &QueueItem{
		Job:         job,
		Priority:    job.Priority,
		EnqueueTime: time.Now(),
	}

	// Add to priority queue
	qm.queue.Push(item)

	// Store job
	qm.jobs[job.ID] = job

	// Update statistics
	qm.statistics.TotalEnqueued++
	qm.statistics.PendingJobs++
	qm.statistics.LastUpdate = time.Now()

	qm.logger.Debug("Job enqueued",
		"job_id", job.ID,
		"priority", job.Priority,
		"queue_size", len(qm.queue.items))

	return nil
}

// Dequeue removes and returns the highest priority job from the queue
func (qm *QueueManager) Dequeue() (*VulnerabilityJob, error) {
	qm.mutex.Lock()
	defer qm.mutex.Unlock()

	if len(qm.queue.items) == 0 {
		return nil, nil // No jobs available
	}

	// Get highest priority item
	item := qm.queue.Pop()
	if item == nil {
		return nil, nil
	}

	job := item.Job

	// Calculate wait time
	waitTime := time.Since(item.EnqueueTime)

	// Update job status
	job.Status = "processing"

	// Update statistics
	qm.statistics.TotalDequeued++
	qm.statistics.PendingJobs--
	qm.statistics.ActiveJobs++

	// Update average wait time
	totalWaitTime := qm.statistics.AverageWaitTime * float64(qm.statistics.TotalDequeued-1)
	totalWaitTime += waitTime.Seconds()
	qm.statistics.AverageWaitTime = totalWaitTime / float64(qm.statistics.TotalDequeued)

	qm.statistics.LastUpdate = time.Now()

	qm.logger.Debug("Job dequeued",
		"job_id", job.ID,
		"wait_time", waitTime,
		"queue_size", len(qm.queue.items))

	return job, nil
}

// GetJob returns a job by ID
func (qm *QueueManager) GetJob(jobID string) (*VulnerabilityJob, error) {
	qm.mutex.RLock()
	defer qm.mutex.RUnlock()

	job, exists := qm.jobs[jobID]
	if !exists {
		return nil, fmt.Errorf("job %s not found", jobID)
	}

	return job, nil
}

// UpdateJob updates a job's information
func (qm *QueueManager) UpdateJob(job *VulnerabilityJob) error {
	qm.mutex.Lock()
	defer qm.mutex.Unlock()

	if _, exists := qm.jobs[job.ID]; !exists {
		return fmt.Errorf("job %s not found", job.ID)
	}

	// Update job
	qm.jobs[job.ID] = job

	// Update statistics based on job status
	switch job.Status {
	case "completed":
		qm.statistics.ActiveJobs--
		qm.statistics.CompletedJobs++
	case "failed":
		qm.statistics.ActiveJobs--
		qm.statistics.FailedJobs++
	}

	qm.statistics.LastUpdate = time.Now()

	return nil
}

// GetJobsByStatus returns jobs with the specified status
func (qm *QueueManager) GetJobsByStatus(status string) ([]*VulnerabilityJob, error) {
	qm.mutex.RLock()
	defer qm.mutex.RUnlock()

	jobs := make([]*VulnerabilityJob, 0)
	for _, job := range qm.jobs {
		if job.Status == status {
			jobs = append(jobs, job)
		}
	}

	return jobs, nil
}

// CancelJob cancels a job by ID
func (qm *QueueManager) CancelJob(jobID string) error {
	qm.mutex.Lock()
	defer qm.mutex.Unlock()

	job, exists := qm.jobs[jobID]
	if !exists {
		return fmt.Errorf("job %s not found", jobID)
	}

	if job.Status == "completed" || job.Status == "failed" || job.Status == "cancelled" {
		return fmt.Errorf("cannot cancel job in status %s", job.Status)
	}

	// Remove from queue if still pending
	if job.Status == "queued" {
		qm.queue.Remove(jobID)
		qm.statistics.PendingJobs--
	} else if job.Status == "processing" {
		qm.statistics.ActiveJobs--
	}

	// Update job status
	job.Status = "cancelled"
	completedAt := time.Now()
	job.CompletedAt = &completedAt

	qm.logger.Info("Job cancelled", "job_id", jobID)

	return nil
}

// GetStatistics returns current queue statistics
func (qm *QueueManager) GetStatistics() QueueStatistics {
	qm.mutex.RLock()
	defer qm.mutex.RUnlock()
	return qm.statistics
}

// IsHealthy returns the health status of the queue manager
func (qm *QueueManager) IsHealthy() bool {
	qm.mutex.RLock()
	defer qm.mutex.RUnlock()

	return qm.isRunning && len(qm.queue.items) < qm.config.MaxSize
}

// cleanupRoutine periodically cleans up old completed jobs
func (qm *QueueManager) cleanupRoutine(ctx context.Context) {
	ticker := time.NewTicker(qm.config.CleanupInterval)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return
		case <-ticker.C:
			qm.cleanupOldJobs()
		}
	}
}

// cleanupOldJobs removes old completed/failed jobs
func (qm *QueueManager) cleanupOldJobs() {
	qm.mutex.Lock()
	defer qm.mutex.Unlock()

	now := time.Now()
	removedCount := 0

	for jobID, job := range qm.jobs {
		// Only clean up completed/failed/cancelled jobs
		if job.Status != "completed" && job.Status != "failed" && job.Status != "cancelled" {
			continue
		}

		// Check if job is older than TTL
		var jobTime time.Time
		if job.CompletedAt != nil {
			jobTime = *job.CompletedAt
		} else {
			jobTime = job.CreatedAt
		}

		if now.Sub(jobTime) > qm.config.JobTTL {
			delete(qm.jobs, jobID)
			removedCount++
		}
	}

	if removedCount > 0 {
		qm.logger.Info("Cleaned up old jobs",
			"removed_count", removedCount,
			"remaining_jobs", len(qm.jobs))
	}
}

// persistenceRoutine periodically persists queue state
func (qm *QueueManager) persistenceRoutine(ctx context.Context) {
	ticker := time.NewTicker(time.Minute * 5) // Persist every 5 minutes
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return
		case <-ticker.C:
			if err := qm.persistJobs(); err != nil {
				qm.logger.Error("Failed to persist jobs", "error", err)
			}
		}
	}
}

// persistJobs saves current jobs to disk
func (qm *QueueManager) persistJobs() error {
	qm.mutex.RLock()
	defer qm.mutex.RUnlock()

	data := struct {
		Jobs       map[string]*VulnerabilityJob `json:"jobs"`
		Statistics QueueStatistics              `json:"statistics"`
		Timestamp  time.Time                    `json:"timestamp"`
	}{
		Jobs:       qm.jobs,
		Statistics: qm.statistics,
		Timestamp:  time.Now(),
	}

	jsonData, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal jobs: %w", err)
	}

	// In a real implementation, this would write to a file
	// For now, we'll just log that persistence occurred
	qm.logger.Debug("Jobs persisted",
		"job_count", len(qm.jobs),
		"data_size", len(jsonData))

	return nil
}

// loadPersistedJobs loads jobs from disk
func (qm *QueueManager) loadPersistedJobs() error {
	// In a real implementation, this would read from a file
	// For now, we'll just log that loading was attempted
	qm.logger.Debug("Loading persisted jobs")

	return nil
}

// PriorityQueue implementation

// NewPriorityQueue creates a new priority queue
func NewPriorityQueue() *PriorityQueue {
	return &PriorityQueue{
		items: make([]*QueueItem, 0),
	}
}

// Push adds an item to the priority queue
func (pq *PriorityQueue) Push(item *QueueItem) {
	pq.mutex.Lock()
	defer pq.mutex.Unlock()

	pq.items = append(pq.items, item)

	// Sort by priority (higher priority first), then by enqueue time (older first)
	sort.Slice(pq.items, func(i, j int) bool {
		if pq.items[i].Priority == pq.items[j].Priority {
			return pq.items[i].EnqueueTime.Before(pq.items[j].EnqueueTime)
		}
		return pq.items[i].Priority > pq.items[j].Priority
	})
}

// Pop removes and returns the highest priority item
func (pq *PriorityQueue) Pop() *QueueItem {
	pq.mutex.Lock()
	defer pq.mutex.Unlock()

	if len(pq.items) == 0 {
		return nil
	}

	item := pq.items[0]
	pq.items = pq.items[1:]

	return item
}

// Remove removes an item by job ID
func (pq *PriorityQueue) Remove(jobID string) bool {
	pq.mutex.Lock()
	defer pq.mutex.Unlock()

	for i, item := range pq.items {
		if item.Job.ID == jobID {
			pq.items = append(pq.items[:i], pq.items[i+1:]...)
			return true
		}
	}

	return false
}

// Len returns the number of items in the queue
func (pq *PriorityQueue) Len() int {
	pq.mutex.RLock()
	defer pq.mutex.RUnlock()
	return len(pq.items)
}

// Peek returns the highest priority item without removing it
func (pq *PriorityQueue) Peek() *QueueItem {
	pq.mutex.RLock()
	defer pq.mutex.RUnlock()

	if len(pq.items) == 0 {
		return nil
	}

	return pq.items[0]
}
