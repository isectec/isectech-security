package validation

import (
	"context"
	"fmt"
	"log/slog"
	"sync"
	"time"
)

// AutomationPipeline coordinates automated vulnerability validation and enrichment
type AutomationPipeline struct {
	config              AutomationConfig
	logger              *slog.Logger
	validationEngine    *ValidationEngine
	scoringEngine       *ScoringEngine
	enrichmentService   EnrichmentService
	notificationService NotificationService
	workflowEngine      *WorkflowEngine
	queueManager        *QueueManager
	statistics          AutomationStatistics
	isRunning           bool
	stopChannel         chan struct{}
	mutex               sync.RWMutex
}

// AutomationConfig defines configuration for the automation pipeline
type AutomationConfig struct {
	// Processing settings
	MaxConcurrentJobs  int           `json:"max_concurrent_jobs"`
	ProcessingTimeout  time.Duration `json:"processing_timeout"`
	BatchSize          int           `json:"batch_size"`
	ProcessingInterval time.Duration `json:"processing_interval"`

	// Queue settings
	QueueMaxSize       int           `json:"queue_max_size"`
	QueuePersistence   bool          `json:"queue_persistence"`
	QueueRetryAttempts int           `json:"queue_retry_attempts"`
	QueueRetryDelay    time.Duration `json:"queue_retry_delay"`

	// Workflow settings
	EnableWorkflows bool                          `json:"enable_workflows"`
	WorkflowTimeout time.Duration                 `json:"workflow_timeout"`
	DefaultWorkflow string                        `json:"default_workflow"`
	CustomWorkflows map[string]WorkflowDefinition `json:"custom_workflows"`

	// Notification settings
	EnableNotifications   bool     `json:"enable_notifications"`
	NotificationChannels  []string `json:"notification_channels"`
	NotificationThreshold float64  `json:"notification_threshold"`

	// Quality control
	MinConfidenceThreshold float64 `json:"min_confidence_threshold"`
	RequireValidation      bool    `json:"require_validation"`
	RequireEnrichment      bool    `json:"require_enrichment"`

	// Performance settings
	EnableMetrics       bool          `json:"enable_metrics"`
	MetricsInterval     time.Duration `json:"metrics_interval"`
	EnableHealthCheck   bool          `json:"enable_health_check"`
	HealthCheckInterval time.Duration `json:"health_check_interval"`

	// iSECTECH specific
	TenantIsolation     bool `json:"tenant_isolation"`
	ComplianceReporting bool `json:"compliance_reporting"`
	BusinessHoursOnly   bool `json:"business_hours_only"`
	PriorityByAsset     bool `json:"priority_by_asset"`
}

// AutomationStatistics tracks pipeline performance
type AutomationStatistics struct {
	TotalProcessed        int64     `json:"total_processed"`
	SuccessfulProcessed   int64     `json:"successful_processed"`
	FailedProcessed       int64     `json:"failed_processed"`
	QueuedItems           int64     `json:"queued_items"`
	AverageProcessingTime float64   `json:"average_processing_time"`
	ThroughputPerHour     float64   `json:"throughput_per_hour"`
	ErrorRate             float64   `json:"error_rate"`
	LastProcessingTime    time.Time `json:"last_processing_time"`
	LastUpdate            time.Time `json:"last_update"`

	// Component statistics
	ValidationStats   map[string]interface{} `json:"validation_stats"`
	ScoringStats      map[string]interface{} `json:"scoring_stats"`
	EnrichmentStats   map[string]interface{} `json:"enrichment_stats"`
	NotificationStats map[string]interface{} `json:"notification_stats"`
}

// VulnerabilityJob represents a vulnerability processing job
type VulnerabilityJob struct {
	ID              string                 `json:"id"`
	VulnerabilityID string                 `json:"vulnerability_id"`
	Vulnerability   *Vulnerability         `json:"vulnerability"`
	Priority        int                    `json:"priority"`
	WorkflowName    string                 `json:"workflow_name"`
	Status          string                 `json:"status"`
	Progress        JobProgress            `json:"progress"`
	Results         *JobResults            `json:"results,omitempty"`
	Errors          []JobError             `json:"errors,omitempty"`
	Metadata        map[string]interface{} `json:"metadata"`
	CreatedAt       time.Time              `json:"created_at"`
	StartedAt       *time.Time             `json:"started_at,omitempty"`
	CompletedAt     *time.Time             `json:"completed_at,omitempty"`
	RetryCount      int                    `json:"retry_count"`
	TenantID        string                 `json:"tenant_id,omitempty"`
}

// JobProgress tracks job execution progress
type JobProgress struct {
	CurrentStep     string    `json:"current_step"`
	CompletedSteps  []string  `json:"completed_steps"`
	TotalSteps      int       `json:"total_steps"`
	PercentComplete float64   `json:"percent_complete"`
	LastUpdate      time.Time `json:"last_update"`
}

// JobResults contains the results of vulnerability processing
type JobResults struct {
	ValidationResult *ValidationResult `json:"validation_result,omitempty"`
	ScoringResult    *ScoringResult    `json:"scoring_result,omitempty"`
	EnrichmentResult *EnrichmentResult `json:"enrichment_result,omitempty"`
	WorkflowResult   *WorkflowResult   `json:"workflow_result,omitempty"`
	FinalScore       float64           `json:"final_score"`
	FinalPriority    string            `json:"final_priority"`
	Recommendations  []string          `json:"recommendations"`
	ProcessingTime   time.Duration     `json:"processing_time"`
	QualityMetrics   QualityMetrics    `json:"quality_metrics"`
}

// JobError represents an error during job processing
type JobError struct {
	Step        string    `json:"step"`
	Message     string    `json:"message"`
	ErrorCode   string    `json:"error_code"`
	Timestamp   time.Time `json:"timestamp"`
	Recoverable bool      `json:"recoverable"`
}

// QualityMetrics tracks the quality of processing results
type QualityMetrics struct {
	DataCompleteness  float64 `json:"data_completeness"`
	ValidationQuality float64 `json:"validation_quality"`
	EnrichmentQuality float64 `json:"enrichment_quality"`
	OverallQuality    float64 `json:"overall_quality"`
}

// EnrichmentService interface for vulnerability enrichment
type EnrichmentService interface {
	EnrichVulnerability(ctx context.Context, vuln *Vulnerability, validationResult *ValidationResult) (*EnrichmentResult, error)
	GetEnrichmentCapabilities() []string
	IsHealthy(ctx context.Context) bool
}

// EnrichmentResult contains enrichment data
type EnrichmentResult struct {
	VulnerabilityID    string                 `json:"vulnerability_id"`
	EnrichmentData     map[string]interface{} `json:"enrichment_data"`
	ExternalReferences []ExternalReference    `json:"external_references"`
	ThreatIntelligence *ThreatIntelData       `json:"threat_intelligence,omitempty"`
	ExploitInfo        *ExploitInfo           `json:"exploit_info,omitempty"`
	PatchInfo          *PatchInfo             `json:"patch_info,omitempty"`
	VendorAdvisories   []VendorAdvisory       `json:"vendor_advisories"`
	ComplianceMapping  []ComplianceMapping    `json:"compliance_mapping"`
	BusinessContext    *BusinessImpactInfo    `json:"business_context,omitempty"`
	ProcessingTime     time.Duration          `json:"processing_time"`
	QualityScore       float64                `json:"quality_score"`
	DataSources        []string               `json:"data_sources"`
	Timestamp          time.Time              `json:"timestamp"`
}

// ExternalReference represents external references for vulnerabilities
type ExternalReference struct {
	Source      string                 `json:"source"`
	URL         string                 `json:"url"`
	Type        string                 `json:"type"`
	Title       string                 `json:"title"`
	Description string                 `json:"description"`
	Metadata    map[string]interface{} `json:"metadata"`
}

// ComplianceMapping maps vulnerabilities to compliance requirements
type ComplianceMapping struct {
	Standard    string   `json:"standard"`
	Control     string   `json:"control"`
	Requirement string   `json:"requirement"`
	Impact      string   `json:"impact"`
	Timeline    string   `json:"timeline"`
	References  []string `json:"references"`
}

// NotificationService interface for sending notifications
type NotificationService interface {
	SendNotification(ctx context.Context, notification *Notification) error
	GetChannels() []string
	IsHealthy(ctx context.Context) bool
}

// Notification represents a system notification
type Notification struct {
	ID         string                 `json:"id"`
	Type       string                 `json:"type"`
	Priority   string                 `json:"priority"`
	Title      string                 `json:"title"`
	Message    string                 `json:"message"`
	Recipients []string               `json:"recipients"`
	Channels   []string               `json:"channels"`
	Data       map[string]interface{} `json:"data"`
	Timestamp  time.Time              `json:"timestamp"`
	TenantID   string                 `json:"tenant_id,omitempty"`
}

// NewAutomationPipeline creates a new automation pipeline instance
func NewAutomationPipeline(config AutomationConfig, validationEngine *ValidationEngine, scoringEngine *ScoringEngine, logger *slog.Logger) (*AutomationPipeline, error) {
	if logger == nil {
		logger = slog.Default()
	}

	// Initialize queue manager
	queueManager, err := NewQueueManager(QueueConfig{
		MaxSize:       config.QueueMaxSize,
		Persistence:   config.QueuePersistence,
		RetryAttempts: config.QueueRetryAttempts,
		RetryDelay:    config.QueueRetryDelay,
	}, logger)
	if err != nil {
		return nil, fmt.Errorf("failed to create queue manager: %w", err)
	}

	// Initialize workflow engine
	workflowEngine, err := NewWorkflowEngine(WorkflowConfig{
		Enabled:         config.EnableWorkflows,
		Timeout:         config.WorkflowTimeout,
		DefaultWorkflow: config.DefaultWorkflow,
		CustomWorkflows: config.CustomWorkflows,
	}, logger)
	if err != nil {
		return nil, fmt.Errorf("failed to create workflow engine: %w", err)
	}

	pipeline := &AutomationPipeline{
		config:           config,
		logger:           logger,
		validationEngine: validationEngine,
		scoringEngine:    scoringEngine,
		workflowEngine:   workflowEngine,
		queueManager:     queueManager,
		stopChannel:      make(chan struct{}),
		statistics: AutomationStatistics{
			ValidationStats:   make(map[string]interface{}),
			ScoringStats:      make(map[string]interface{}),
			EnrichmentStats:   make(map[string]interface{}),
			NotificationStats: make(map[string]interface{}),
			LastUpdate:        time.Now(),
		},
	}

	return pipeline, nil
}

// Start begins the automation pipeline
func (ap *AutomationPipeline) Start(ctx context.Context) error {
	ap.mutex.Lock()
	if ap.isRunning {
		ap.mutex.Unlock()
		return fmt.Errorf("pipeline is already running")
	}
	ap.isRunning = true
	ap.mutex.Unlock()

	ap.logger.Info("Starting automation pipeline")

	// Start queue manager
	if err := ap.queueManager.Start(ctx); err != nil {
		return fmt.Errorf("failed to start queue manager: %w", err)
	}

	// Start workflow engine
	if err := ap.workflowEngine.Start(ctx); err != nil {
		return fmt.Errorf("failed to start workflow engine: %w", err)
	}

	// Start processing goroutines
	for i := 0; i < ap.config.MaxConcurrentJobs; i++ {
		go ap.processJobs(ctx, i)
	}

	// Start metrics collection if enabled
	if ap.config.EnableMetrics {
		go ap.collectMetrics(ctx)
	}

	// Start health checks if enabled
	if ap.config.EnableHealthCheck {
		go ap.performHealthChecks(ctx)
	}

	ap.logger.Info("Automation pipeline started successfully")
	return nil
}

// Stop gracefully stops the automation pipeline
func (ap *AutomationPipeline) Stop(ctx context.Context) error {
	ap.mutex.Lock()
	if !ap.isRunning {
		ap.mutex.Unlock()
		return fmt.Errorf("pipeline is not running")
	}
	ap.isRunning = false
	ap.mutex.Unlock()

	ap.logger.Info("Stopping automation pipeline")

	// Signal stop to all goroutines
	close(ap.stopChannel)

	// Stop components
	if err := ap.queueManager.Stop(ctx); err != nil {
		ap.logger.Error("Failed to stop queue manager", "error", err)
	}

	if err := ap.workflowEngine.Stop(ctx); err != nil {
		ap.logger.Error("Failed to stop workflow engine", "error", err)
	}

	ap.logger.Info("Automation pipeline stopped")
	return nil
}

// SubmitVulnerability submits a vulnerability for automated processing
func (ap *AutomationPipeline) SubmitVulnerability(vuln *Vulnerability, priority int, workflowName string) (*VulnerabilityJob, error) {
	if !ap.isRunning {
		return nil, fmt.Errorf("pipeline is not running")
	}

	// Create job
	job := &VulnerabilityJob{
		ID:              ap.generateJobID(),
		VulnerabilityID: vuln.ID,
		Vulnerability:   vuln,
		Priority:        priority,
		WorkflowName:    workflowName,
		Status:          "queued",
		Progress: JobProgress{
			CurrentStep:     "queued",
			CompletedSteps:  make([]string, 0),
			TotalSteps:      0,
			PercentComplete: 0.0,
			LastUpdate:      time.Now(),
		},
		Metadata:   make(map[string]interface{}),
		CreatedAt:  time.Now(),
		RetryCount: 0,
	}

	// Add tenant information if tenant isolation is enabled
	if ap.config.TenantIsolation {
		if tenantID, exists := vuln.TechnicalDetails["tenant_id"]; exists {
			job.TenantID = tenantID.(string)
		}
	}

	// Submit to queue
	if err := ap.queueManager.Enqueue(job); err != nil {
		return nil, fmt.Errorf("failed to enqueue job: %w", err)
	}

	ap.logger.Info("Vulnerability submitted for processing",
		"job_id", job.ID,
		"vulnerability_id", vuln.ID,
		"priority", priority,
		"workflow", workflowName)

	return job, nil
}

// SubmitBatch submits multiple vulnerabilities for batch processing
func (ap *AutomationPipeline) SubmitBatch(vulnerabilities []*Vulnerability, priority int, workflowName string) ([]*VulnerabilityJob, error) {
	jobs := make([]*VulnerabilityJob, len(vulnerabilities))

	for i, vuln := range vulnerabilities {
		job, err := ap.SubmitVulnerability(vuln, priority, workflowName)
		if err != nil {
			ap.logger.Error("Failed to submit vulnerability in batch",
				"vulnerability_id", vuln.ID,
				"error", err)
			continue
		}
		jobs[i] = job
	}

	ap.logger.Info("Vulnerability batch submitted",
		"total_count", len(vulnerabilities),
		"successful_count", len(jobs),
		"priority", priority,
		"workflow", workflowName)

	return jobs, nil
}

// GetJobStatus returns the current status of a job
func (ap *AutomationPipeline) GetJobStatus(jobID string) (*VulnerabilityJob, error) {
	return ap.queueManager.GetJob(jobID)
}

// processJobs processes jobs from the queue
func (ap *AutomationPipeline) processJobs(ctx context.Context, workerID int) {
	ap.logger.Info("Starting job processor", "worker_id", workerID)

	for {
		select {
		case <-ap.stopChannel:
			ap.logger.Info("Job processor stopping", "worker_id", workerID)
			return
		case <-ctx.Done():
			ap.logger.Info("Job processor context cancelled", "worker_id", workerID)
			return
		default:
			// Try to dequeue a job
			job, err := ap.queueManager.Dequeue()
			if err != nil {
				// No jobs available, wait a bit
				time.Sleep(time.Second)
				continue
			}

			if job == nil {
				time.Sleep(time.Second)
				continue
			}

			// Process the job
			ap.processJob(ctx, job, workerID)
		}
	}
}

// processJob processes a single vulnerability job
func (ap *AutomationPipeline) processJob(ctx context.Context, job *VulnerabilityJob, workerID int) {
	startTime := time.Now()
	job.Status = "processing"
	job.StartedAt = &startTime

	ap.logger.Info("Processing job",
		"job_id", job.ID,
		"vulnerability_id", job.VulnerabilityID,
		"worker_id", workerID)

	// Create job-specific context with timeout
	jobCtx, cancel := context.WithTimeout(ctx, ap.config.ProcessingTimeout)
	defer cancel()

	// Initialize results
	job.Results = &JobResults{
		Recommendations: make([]string, 0),
	}

	// Execute workflow
	if ap.config.EnableWorkflows {
		workflowResult, err := ap.executeWorkflow(jobCtx, job)
		if err != nil {
			ap.handleJobError(job, "workflow_execution", err, false)
			return
		}
		job.Results.WorkflowResult = workflowResult
	} else {
		// Execute default processing pipeline
		if err := ap.executeDefaultPipeline(jobCtx, job); err != nil {
			ap.handleJobError(job, "default_pipeline", err, false)
			return
		}
	}

	// Complete job
	completedAt := time.Now()
	job.CompletedAt = &completedAt
	job.Status = "completed"
	job.Results.ProcessingTime = completedAt.Sub(startTime)
	job.Progress.PercentComplete = 100.0
	job.Progress.CurrentStep = "completed"
	job.Progress.LastUpdate = completedAt

	// Calculate quality metrics
	job.Results.QualityMetrics = ap.calculateQualityMetrics(job.Results)

	// Send notifications if enabled and thresholds met
	if ap.config.EnableNotifications && job.Results.FinalScore >= ap.config.NotificationThreshold {
		ap.sendJobNotification(jobCtx, job)
	}

	// Update statistics
	ap.updateJobStatistics(job, true)

	ap.logger.Info("Job completed successfully",
		"job_id", job.ID,
		"vulnerability_id", job.VulnerabilityID,
		"processing_time", job.Results.ProcessingTime,
		"final_score", job.Results.FinalScore,
		"final_priority", job.Results.FinalPriority)

	// Update job in queue manager
	ap.queueManager.UpdateJob(job)
}

// executeDefaultPipeline executes the default processing pipeline
func (ap *AutomationPipeline) executeDefaultPipeline(ctx context.Context, job *VulnerabilityJob) error {
	// Step 1: Validation
	job.Progress.CurrentStep = "validation"
	job.Progress.LastUpdate = time.Now()

	if ap.config.RequireValidation {
		validationResult, err := ap.validationEngine.ValidateVulnerability(ctx, job.Vulnerability)
		if err != nil {
			return fmt.Errorf("validation failed: %w", err)
		}
		job.Results.ValidationResult = validationResult
		job.Progress.CompletedSteps = append(job.Progress.CompletedSteps, "validation")
		job.Progress.PercentComplete = 25.0
	}

	// Step 2: Scoring
	job.Progress.CurrentStep = "scoring"
	job.Progress.LastUpdate = time.Now()

	scoringResult, err := ap.scoringEngine.CalculatePriorityScore(ctx, job.Vulnerability, job.Results.ValidationResult)
	if err != nil {
		return fmt.Errorf("scoring failed: %w", err)
	}
	job.Results.FinalScore = scoringResult
	job.Results.FinalPriority = ap.scoringEngine.determinePriority(scoringResult)
	job.Progress.CompletedSteps = append(job.Progress.CompletedSteps, "scoring")
	job.Progress.PercentComplete = 50.0

	// Step 3: Enrichment
	job.Progress.CurrentStep = "enrichment"
	job.Progress.LastUpdate = time.Now()

	if ap.config.RequireEnrichment && ap.enrichmentService != nil {
		enrichmentResult, err := ap.enrichmentService.EnrichVulnerability(ctx, job.Vulnerability, job.Results.ValidationResult)
		if err != nil {
			ap.logger.Warn("Enrichment failed, continuing without enrichment",
				"job_id", job.ID,
				"error", err)
		} else {
			job.Results.EnrichmentResult = enrichmentResult
		}
	}
	job.Progress.CompletedSteps = append(job.Progress.CompletedSteps, "enrichment")
	job.Progress.PercentComplete = 75.0

	// Step 4: Generate recommendations
	job.Progress.CurrentStep = "recommendations"
	job.Progress.LastUpdate = time.Now()

	job.Results.Recommendations = ap.generateRecommendations(job)
	job.Progress.CompletedSteps = append(job.Progress.CompletedSteps, "recommendations")
	job.Progress.PercentComplete = 100.0

	return nil
}

// executeWorkflow executes a custom workflow
func (ap *AutomationPipeline) executeWorkflow(ctx context.Context, job *VulnerabilityJob) (*WorkflowResult, error) {
	workflowName := job.WorkflowName
	if workflowName == "" {
		workflowName = ap.config.DefaultWorkflow
	}

	return ap.workflowEngine.ExecuteWorkflow(ctx, workflowName, job)
}

// generateRecommendations generates recommendations based on processing results
func (ap *AutomationPipeline) generateRecommendations(job *VulnerabilityJob) []string {
	recommendations := make([]string, 0)

	// Base recommendations on final score and priority
	switch job.Results.FinalPriority {
	case "critical":
		recommendations = append(recommendations, "Immediate action required - treat as emergency")
		recommendations = append(recommendations, "Activate incident response procedures")
		recommendations = append(recommendations, "Consider emergency patching or system isolation")
	case "high":
		recommendations = append(recommendations, "Address within 24-48 hours")
		recommendations = append(recommendations, "Prioritize in next maintenance window")
	case "medium":
		recommendations = append(recommendations, "Address within 1-2 weeks")
		recommendations = append(recommendations, "Include in regular patching cycle")
	case "low":
		recommendations = append(recommendations, "Address in next scheduled maintenance")
	}

	// Add validation-based recommendations
	if job.Results.ValidationResult != nil {
		if job.Results.ValidationResult.FalsePositiveRisk > 0.7 {
			recommendations = append(recommendations, "High false positive risk - verify manually before action")
		}
		if job.Results.ValidationResult.ConfidenceScore < 0.5 {
			recommendations = append(recommendations, "Low confidence score - additional validation recommended")
		}
	}

	// Add enrichment-based recommendations
	if job.Results.EnrichmentResult != nil {
		if job.Results.EnrichmentResult.ExploitInfo != nil && job.Results.EnrichmentResult.ExploitInfo.HasPublicExploit {
			recommendations = append(recommendations, "Public exploits available - expedite remediation")
		}
		if job.Results.EnrichmentResult.PatchInfo != nil && job.Results.EnrichmentResult.PatchInfo.PatchAvailable {
			recommendations = append(recommendations, "Patch available - apply security update")
		}
	}

	// Add business context recommendations
	if job.Vulnerability.NetworkContext.IsExternalFacing {
		recommendations = append(recommendations, "External-facing asset - consider additional monitoring")
	}

	// Add compliance recommendations
	if ap.config.ComplianceReporting {
		recommendations = append(recommendations, "Document remediation for compliance audit trail")
	}

	return recommendations
}

// calculateQualityMetrics calculates quality metrics for processing results
func (ap *AutomationPipeline) calculateQualityMetrics(results *JobResults) QualityMetrics {
	metrics := QualityMetrics{}

	// Data completeness
	completeness := 0.0
	totalComponents := 4.0 // validation, scoring, enrichment, recommendations

	if results.ValidationResult != nil {
		completeness += 1.0
	}
	if results.FinalScore > 0 {
		completeness += 1.0
	}
	if results.EnrichmentResult != nil {
		completeness += 1.0
	}
	if len(results.Recommendations) > 0 {
		completeness += 1.0
	}

	metrics.DataCompleteness = completeness / totalComponents

	// Validation quality
	if results.ValidationResult != nil {
		metrics.ValidationQuality = results.ValidationResult.ConfidenceScore
	} else {
		metrics.ValidationQuality = 0.5 // Default if no validation
	}

	// Enrichment quality
	if results.EnrichmentResult != nil {
		metrics.EnrichmentQuality = results.EnrichmentResult.QualityScore
	} else {
		metrics.EnrichmentQuality = 0.5 // Default if no enrichment
	}

	// Overall quality (weighted average)
	metrics.OverallQuality = (metrics.DataCompleteness*0.3 +
		metrics.ValidationQuality*0.4 +
		metrics.EnrichmentQuality*0.3)

	return metrics
}

// handleJobError handles job processing errors
func (ap *AutomationPipeline) handleJobError(job *VulnerabilityJob, step string, err error, recoverable bool) {
	jobError := JobError{
		Step:        step,
		Message:     err.Error(),
		ErrorCode:   "PROCESSING_ERROR",
		Timestamp:   time.Now(),
		Recoverable: recoverable,
	}

	if job.Errors == nil {
		job.Errors = make([]JobError, 0)
	}
	job.Errors = append(job.Errors, jobError)

	// Retry logic for recoverable errors
	if recoverable && job.RetryCount < ap.config.QueueRetryAttempts {
		job.RetryCount++
		job.Status = "retrying"

		ap.logger.Warn("Job error, will retry",
			"job_id", job.ID,
			"step", step,
			"error", err,
			"retry_count", job.RetryCount)

		// Re-queue the job for retry
		go func() {
			time.Sleep(ap.config.QueueRetryDelay)
			ap.queueManager.Enqueue(job)
		}()
	} else {
		// Mark job as failed
		job.Status = "failed"
		completedAt := time.Now()
		job.CompletedAt = &completedAt

		ap.logger.Error("Job failed permanently",
			"job_id", job.ID,
			"step", step,
			"error", err,
			"retry_count", job.RetryCount)

		// Update statistics
		ap.updateJobStatistics(job, false)

		// Send error notification if enabled
		if ap.config.EnableNotifications {
			ap.sendErrorNotification(context.Background(), job, err)
		}
	}

	// Update job in queue manager
	ap.queueManager.UpdateJob(job)
}

// sendJobNotification sends a notification for completed job
func (ap *AutomationPipeline) sendJobNotification(ctx context.Context, job *VulnerabilityJob) {
	if ap.notificationService == nil {
		return
	}

	notification := &Notification{
		ID:       fmt.Sprintf("job_%s", job.ID),
		Type:     "vulnerability_processed",
		Priority: job.Results.FinalPriority,
		Title:    fmt.Sprintf("High Priority Vulnerability Detected: %s", job.Vulnerability.Title),
		Message: fmt.Sprintf("Vulnerability %s has been processed with final score %.1f (%s priority)",
			job.Vulnerability.ID, job.Results.FinalScore, job.Results.FinalPriority),
		Recipients: ap.config.NotificationChannels,
		Channels:   ap.config.NotificationChannels,
		Data: map[string]interface{}{
			"job_id":           job.ID,
			"vulnerability_id": job.VulnerabilityID,
			"final_score":      job.Results.FinalScore,
			"final_priority":   job.Results.FinalPriority,
			"processing_time":  job.Results.ProcessingTime,
			"recommendations":  job.Results.Recommendations,
		},
		Timestamp: time.Now(),
		TenantID:  job.TenantID,
	}

	if err := ap.notificationService.SendNotification(ctx, notification); err != nil {
		ap.logger.Error("Failed to send job notification",
			"job_id", job.ID,
			"error", err)
	}
}

// sendErrorNotification sends a notification for failed job
func (ap *AutomationPipeline) sendErrorNotification(ctx context.Context, job *VulnerabilityJob, err error) {
	if ap.notificationService == nil {
		return
	}

	notification := &Notification{
		ID:         fmt.Sprintf("job_error_%s", job.ID),
		Type:       "processing_error",
		Priority:   "high",
		Title:      "Vulnerability Processing Failed",
		Message:    fmt.Sprintf("Failed to process vulnerability %s: %s", job.VulnerabilityID, err.Error()),
		Recipients: ap.config.NotificationChannels,
		Channels:   ap.config.NotificationChannels,
		Data: map[string]interface{}{
			"job_id":           job.ID,
			"vulnerability_id": job.VulnerabilityID,
			"error":            err.Error(),
			"retry_count":      job.RetryCount,
		},
		Timestamp: time.Now(),
		TenantID:  job.TenantID,
	}

	ap.notificationService.SendNotification(ctx, notification)
}

// collectMetrics collects and updates pipeline metrics
func (ap *AutomationPipeline) collectMetrics(ctx context.Context) {
	ticker := time.NewTicker(ap.config.MetricsInterval)
	defer ticker.Stop()

	for {
		select {
		case <-ap.stopChannel:
			return
		case <-ctx.Done():
			return
		case <-ticker.C:
			ap.updateMetrics()
		}
	}
}

// updateMetrics updates pipeline metrics
func (ap *AutomationPipeline) updateMetrics() {
	ap.mutex.Lock()
	defer ap.mutex.Unlock()

	// Update component statistics
	if ap.validationEngine != nil {
		ap.statistics.ValidationStats["validation_engine"] = ap.validationEngine.GetStatistics()
	}

	if ap.scoringEngine != nil {
		ap.statistics.ScoringStats["scoring_engine"] = ap.scoringEngine.GetStatistics()
	}

	// Update queue statistics
	queueStats := ap.queueManager.GetStatistics()
	ap.statistics.QueuedItems = queueStats.PendingJobs

	// Calculate throughput
	if ap.statistics.TotalProcessed > 0 {
		totalTime := time.Since(ap.statistics.LastUpdate).Hours()
		if totalTime > 0 {
			ap.statistics.ThroughputPerHour = float64(ap.statistics.TotalProcessed) / totalTime
		}
	}

	// Calculate error rate
	if ap.statistics.TotalProcessed > 0 {
		ap.statistics.ErrorRate = float64(ap.statistics.FailedProcessed) / float64(ap.statistics.TotalProcessed)
	}

	ap.statistics.LastUpdate = time.Now()
}

// updateJobStatistics updates statistics based on job completion
func (ap *AutomationPipeline) updateJobStatistics(job *VulnerabilityJob, success bool) {
	ap.mutex.Lock()
	defer ap.mutex.Unlock()

	ap.statistics.TotalProcessed++

	if success {
		ap.statistics.SuccessfulProcessed++
	} else {
		ap.statistics.FailedProcessed++
	}

	// Update average processing time
	if job.Results != nil {
		totalTime := ap.statistics.AverageProcessingTime * float64(ap.statistics.TotalProcessed-1)
		totalTime += job.Results.ProcessingTime.Seconds()
		ap.statistics.AverageProcessingTime = totalTime / float64(ap.statistics.TotalProcessed)
	}

	ap.statistics.LastProcessingTime = time.Now()
}

// performHealthChecks performs periodic health checks
func (ap *AutomationPipeline) performHealthChecks(ctx context.Context) {
	ticker := time.NewTicker(ap.config.HealthCheckInterval)
	defer ticker.Stop()

	for {
		select {
		case <-ap.stopChannel:
			return
		case <-ctx.Done():
			return
		case <-ticker.C:
			ap.checkHealth(ctx)
		}
	}
}

// checkHealth performs health checks on pipeline components
func (ap *AutomationPipeline) checkHealth(ctx context.Context) {
	healthStatus := make(map[string]bool)

	// Check validation engine
	if ap.validationEngine != nil {
		// Validation engine doesn't have direct health check, assume healthy if not nil
		healthStatus["validation_engine"] = true
	}

	// Check scoring engine
	if ap.scoringEngine != nil {
		// Scoring engine doesn't have direct health check, assume healthy if not nil
		healthStatus["scoring_engine"] = true
	}

	// Check enrichment service
	if ap.enrichmentService != nil {
		healthStatus["enrichment_service"] = ap.enrichmentService.IsHealthy(ctx)
	}

	// Check notification service
	if ap.notificationService != nil {
		healthStatus["notification_service"] = ap.notificationService.IsHealthy(ctx)
	}

	// Check queue manager
	healthStatus["queue_manager"] = ap.queueManager.IsHealthy()

	// Check workflow engine
	healthStatus["workflow_engine"] = ap.workflowEngine.IsHealthy()

	// Log health status
	unhealthyComponents := make([]string, 0)
	for component, healthy := range healthStatus {
		if !healthy {
			unhealthyComponents = append(unhealthyComponents, component)
		}
	}

	if len(unhealthyComponents) > 0 {
		ap.logger.Warn("Unhealthy components detected",
			"unhealthy_components", unhealthyComponents)
	} else {
		ap.logger.Debug("All components healthy")
	}
}

// generateJobID generates a unique job ID
func (ap *AutomationPipeline) generateJobID() string {
	return fmt.Sprintf("job_%d_%d", time.Now().UnixNano(), ap.statistics.TotalProcessed)
}

// GetStatistics returns current pipeline statistics
func (ap *AutomationPipeline) GetStatistics() AutomationStatistics {
	ap.mutex.RLock()
	defer ap.mutex.RUnlock()
	return ap.statistics
}

// SetEnrichmentService sets the enrichment service
func (ap *AutomationPipeline) SetEnrichmentService(service EnrichmentService) {
	ap.enrichmentService = service
}

// SetNotificationService sets the notification service
func (ap *AutomationPipeline) SetNotificationService(service NotificationService) {
	ap.notificationService = service
}

// GetJobsByStatus returns jobs with the specified status
func (ap *AutomationPipeline) GetJobsByStatus(status string) ([]*VulnerabilityJob, error) {
	return ap.queueManager.GetJobsByStatus(status)
}

// GetPendingJobsCount returns the count of pending jobs
func (ap *AutomationPipeline) GetPendingJobsCount() int64 {
	stats := ap.queueManager.GetStatistics()
	return stats.PendingJobs
}

// GetActiveJobsCount returns the count of active (processing) jobs
func (ap *AutomationPipeline) GetActiveJobsCount() int64 {
	stats := ap.queueManager.GetStatistics()
	return stats.ActiveJobs
}

// CancelJob cancels a job by ID
func (ap *AutomationPipeline) CancelJob(jobID string) error {
	return ap.queueManager.CancelJob(jobID)
}

// RetryJob retries a failed job
func (ap *AutomationPipeline) RetryJob(jobID string) error {
	job, err := ap.queueManager.GetJob(jobID)
	if err != nil {
		return err
	}

	if job.Status != "failed" {
		return fmt.Errorf("job %s is not in failed state", jobID)
	}

	// Reset job state
	job.Status = "queued"
	job.RetryCount = 0
	job.Errors = nil
	job.StartedAt = nil
	job.CompletedAt = nil
	job.Progress = JobProgress{
		CurrentStep:     "queued",
		CompletedSteps:  make([]string, 0),
		TotalSteps:      0,
		PercentComplete: 0.0,
		LastUpdate:      time.Now(),
	}

	// Re-queue the job
	return ap.queueManager.Enqueue(job)
}
