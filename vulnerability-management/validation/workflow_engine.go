package validation

import (
	"context"
	"fmt"
	"log/slog"
	"sync"
	"time"
)

// WorkflowEngine executes custom validation and enrichment workflows
type WorkflowEngine struct {
	config     WorkflowConfig
	logger     *slog.Logger
	workflows  map[string]*WorkflowDefinition
	executor   *WorkflowExecutor
	statistics WorkflowStatistics
	isRunning  bool
	mutex      sync.RWMutex
}

// WorkflowConfig defines configuration for the workflow engine
type WorkflowConfig struct {
	Enabled         bool                          `json:"enabled"`
	Timeout         time.Duration                 `json:"timeout"`
	DefaultWorkflow string                        `json:"default_workflow"`
	CustomWorkflows map[string]WorkflowDefinition `json:"custom_workflows"`
	MaxConcurrent   int                           `json:"max_concurrent"`
	StepTimeout     time.Duration                 `json:"step_timeout"`
	RetryAttempts   int                           `json:"retry_attempts"`
	RetryDelay      time.Duration                 `json:"retry_delay"`
}

// WorkflowDefinition defines a custom workflow
type WorkflowDefinition struct {
	ID          string                 `json:"id"`
	Name        string                 `json:"name"`
	Description string                 `json:"description"`
	Version     string                 `json:"version"`
	Enabled     bool                   `json:"enabled"`
	Steps       []WorkflowStep         `json:"steps"`
	Conditions  []WorkflowCondition    `json:"conditions,omitempty"`
	Parameters  map[string]interface{} `json:"parameters,omitempty"`
	Metadata    map[string]interface{} `json:"metadata,omitempty"`
	CreatedAt   time.Time              `json:"created_at"`
	UpdatedAt   time.Time              `json:"updated_at"`
}

// WorkflowStep defines a single step in a workflow
type WorkflowStep struct {
	ID          string                 `json:"id"`
	Name        string                 `json:"name"`
	Type        string                 `json:"type"`
	Action      string                 `json:"action"`
	Parameters  map[string]interface{} `json:"parameters,omitempty"`
	Conditions  []WorkflowCondition    `json:"conditions,omitempty"`
	OnSuccess   []string               `json:"on_success,omitempty"`
	OnFailure   []string               `json:"on_failure,omitempty"`
	Timeout     time.Duration          `json:"timeout,omitempty"`
	RetryPolicy *RetryPolicy           `json:"retry_policy,omitempty"`
	Required    bool                   `json:"required"`
	Parallel    bool                   `json:"parallel"`
	Order       int                    `json:"order"`
}

// WorkflowCondition defines conditions for workflow execution
type WorkflowCondition struct {
	Field    string      `json:"field"`
	Operator string      `json:"operator"`
	Value    interface{} `json:"value"`
	Type     string      `json:"type"` // "vulnerability", "asset", "validation_result", etc.
}

// RetryPolicy defines retry behavior for workflow steps
type RetryPolicy struct {
	MaxAttempts int           `json:"max_attempts"`
	Delay       time.Duration `json:"delay"`
	BackoffType string        `json:"backoff_type"` // "fixed", "exponential", "linear"
	MaxDelay    time.Duration `json:"max_delay"`
}

// WorkflowResult contains the result of workflow execution
type WorkflowResult struct {
	WorkflowID    string                 `json:"workflow_id"`
	WorkflowName  string                 `json:"workflow_name"`
	JobID         string                 `json:"job_id"`
	Status        string                 `json:"status"`
	StartTime     time.Time              `json:"start_time"`
	EndTime       *time.Time             `json:"end_time,omitempty"`
	ExecutionTime time.Duration          `json:"execution_time"`
	StepResults   []WorkflowStepResult   `json:"step_results"`
	FinalState    map[string]interface{} `json:"final_state"`
	Errors        []WorkflowError        `json:"errors,omitempty"`
	Metrics       WorkflowMetrics        `json:"metrics"`
}

// WorkflowStepResult contains the result of a single workflow step
type WorkflowStepResult struct {
	StepID        string                 `json:"step_id"`
	StepName      string                 `json:"step_name"`
	Status        string                 `json:"status"`
	StartTime     time.Time              `json:"start_time"`
	EndTime       *time.Time             `json:"end_time,omitempty"`
	ExecutionTime time.Duration          `json:"execution_time"`
	Output        map[string]interface{} `json:"output,omitempty"`
	Error         *WorkflowError         `json:"error,omitempty"`
	RetryCount    int                    `json:"retry_count"`
}

// WorkflowError represents an error during workflow execution
type WorkflowError struct {
	StepID      string                 `json:"step_id,omitempty"`
	ErrorType   string                 `json:"error_type"`
	Message     string                 `json:"message"`
	Details     map[string]interface{} `json:"details,omitempty"`
	Timestamp   time.Time              `json:"timestamp"`
	Recoverable bool                   `json:"recoverable"`
}

// WorkflowMetrics tracks workflow execution metrics
type WorkflowMetrics struct {
	TotalSteps      int     `json:"total_steps"`
	CompletedSteps  int     `json:"completed_steps"`
	FailedSteps     int     `json:"failed_steps"`
	SkippedSteps    int     `json:"skipped_steps"`
	ParallelSteps   int     `json:"parallel_steps"`
	SuccessRate     float64 `json:"success_rate"`
	AverageStepTime float64 `json:"average_step_time"`
}

// WorkflowStatistics tracks overall workflow engine performance
type WorkflowStatistics struct {
	TotalExecutions      int64                   `json:"total_executions"`
	SuccessfulExecutions int64                   `json:"successful_executions"`
	FailedExecutions     int64                   `json:"failed_executions"`
	AverageExecutionTime float64                 `json:"average_execution_time"`
	WorkflowStats        map[string]WorkflowStat `json:"workflow_stats"`
	LastUpdate           time.Time               `json:"last_update"`
}

// WorkflowStat tracks statistics for individual workflows
type WorkflowStat struct {
	ExecutionCount int64     `json:"execution_count"`
	SuccessCount   int64     `json:"success_count"`
	FailureCount   int64     `json:"failure_count"`
	AverageTime    float64   `json:"average_time"`
	LastExecution  time.Time `json:"last_execution"`
}

// WorkflowExecutor executes workflow steps
type WorkflowExecutor struct {
	validationEngine  *ValidationEngine
	scoringEngine     *ScoringEngine
	enrichmentService EnrichmentService
	logger            *slog.Logger
	stepExecutors     map[string]StepExecutor
}

// StepExecutor interface for executing different types of workflow steps
type StepExecutor interface {
	Execute(ctx context.Context, step *WorkflowStep, job *VulnerabilityJob, state map[string]interface{}) (*WorkflowStepResult, error)
	GetStepType() string
}

// WorkflowContext contains context for workflow execution
type WorkflowContext struct {
	Job       *VulnerabilityJob
	State     map[string]interface{}
	Variables map[string]interface{}
	Results   map[string]interface{}
}

// NewWorkflowEngine creates a new workflow engine
func NewWorkflowEngine(config WorkflowConfig, logger *slog.Logger) (*WorkflowEngine, error) {
	if logger == nil {
		logger = slog.Default()
	}

	// Set defaults
	if config.MaxConcurrent == 0 {
		config.MaxConcurrent = 10
	}
	if config.StepTimeout == 0 {
		config.StepTimeout = time.Minute * 5
	}
	if config.Timeout == 0 {
		config.Timeout = time.Minute * 30
	}

	executor := &WorkflowExecutor{
		logger:        logger,
		stepExecutors: make(map[string]StepExecutor),
	}

	// Register built-in step executors
	executor.registerBuiltinExecutors()

	engine := &WorkflowEngine{
		config:    config,
		logger:    logger,
		workflows: make(map[string]*WorkflowDefinition),
		executor:  executor,
		statistics: WorkflowStatistics{
			WorkflowStats: make(map[string]WorkflowStat),
			LastUpdate:    time.Now(),
		},
	}

	// Load custom workflows
	for id, workflow := range config.CustomWorkflows {
		workflowCopy := workflow
		engine.workflows[id] = &workflowCopy
	}

	// Create default workflows if none exist
	if len(engine.workflows) == 0 {
		engine.createDefaultWorkflows()
	}

	return engine, nil
}

// Start starts the workflow engine
func (we *WorkflowEngine) Start(ctx context.Context) error {
	we.mutex.Lock()
	we.isRunning = true
	we.mutex.Unlock()

	we.logger.Info("Starting workflow engine",
		"workflow_count", len(we.workflows),
		"enabled", we.config.Enabled)

	return nil
}

// Stop stops the workflow engine
func (we *WorkflowEngine) Stop(ctx context.Context) error {
	we.mutex.Lock()
	we.isRunning = false
	we.mutex.Unlock()

	we.logger.Info("Stopping workflow engine")
	return nil
}

// ExecuteWorkflow executes a workflow for a vulnerability job
func (we *WorkflowEngine) ExecuteWorkflow(ctx context.Context, workflowName string, job *VulnerabilityJob) (*WorkflowResult, error) {
	if !we.config.Enabled {
		return nil, fmt.Errorf("workflow engine is disabled")
	}

	workflow, exists := we.workflows[workflowName]
	if !exists {
		return nil, fmt.Errorf("workflow %s not found", workflowName)
	}

	if !workflow.Enabled {
		return nil, fmt.Errorf("workflow %s is disabled", workflowName)
	}

	startTime := time.Now()
	we.logger.Info("Executing workflow",
		"workflow", workflowName,
		"job_id", job.ID,
		"vulnerability_id", job.VulnerabilityID)

	// Create workflow context
	workflowCtx, cancel := context.WithTimeout(ctx, we.config.Timeout)
	defer cancel()

	context := &WorkflowContext{
		Job:       job,
		State:     make(map[string]interface{}),
		Variables: make(map[string]interface{}),
		Results:   make(map[string]interface{}),
	}

	// Initialize state with job data
	context.State["vulnerability"] = job.Vulnerability
	context.State["job"] = job

	// Check workflow conditions
	if !we.evaluateWorkflowConditions(workflow.Conditions, context) {
		return &WorkflowResult{
			WorkflowID:    workflow.ID,
			WorkflowName:  workflow.Name,
			JobID:         job.ID,
			Status:        "skipped",
			StartTime:     startTime,
			EndTime:       &startTime,
			ExecutionTime: 0,
			StepResults:   make([]WorkflowStepResult, 0),
			FinalState:    context.State,
		}, nil
	}

	result := &WorkflowResult{
		WorkflowID:   workflow.ID,
		WorkflowName: workflow.Name,
		JobID:        job.ID,
		Status:       "running",
		StartTime:    startTime,
		StepResults:  make([]WorkflowStepResult, 0),
		Errors:       make([]WorkflowError, 0),
	}

	// Execute workflow steps
	if err := we.executeWorkflowSteps(workflowCtx, workflow, context, result); err != nil {
		result.Status = "failed"
		result.Errors = append(result.Errors, WorkflowError{
			ErrorType:   "workflow_execution",
			Message:     err.Error(),
			Timestamp:   time.Now(),
			Recoverable: false,
		})
	} else {
		result.Status = "completed"
	}

	endTime := time.Now()
	result.EndTime = &endTime
	result.ExecutionTime = endTime.Sub(startTime)
	result.FinalState = context.State

	// Calculate metrics
	result.Metrics = we.calculateWorkflowMetrics(result)

	// Update statistics
	we.updateWorkflowStatistics(workflowName, result)

	we.logger.Info("Workflow execution completed",
		"workflow", workflowName,
		"job_id", job.ID,
		"status", result.Status,
		"execution_time", result.ExecutionTime,
		"steps_completed", result.Metrics.CompletedSteps,
		"steps_failed", result.Metrics.FailedSteps)

	return result, nil
}

// executeWorkflowSteps executes all steps in a workflow
func (we *WorkflowEngine) executeWorkflowSteps(ctx context.Context, workflow *WorkflowDefinition, workflowCtx *WorkflowContext, result *WorkflowResult) error {
	// Sort steps by order
	steps := make([]WorkflowStep, len(workflow.Steps))
	copy(steps, workflow.Steps)

	// Group steps by order for parallel execution
	stepGroups := we.groupStepsByOrder(steps)

	for _, stepGroup := range stepGroups {
		if len(stepGroup) == 1 && !stepGroup[0].Parallel {
			// Execute single step
			stepResult, err := we.executeStep(ctx, &stepGroup[0], workflowCtx)
			result.StepResults = append(result.StepResults, *stepResult)

			if err != nil && stepGroup[0].Required {
				return fmt.Errorf("required step %s failed: %w", stepGroup[0].ID, err)
			}
		} else {
			// Execute steps in parallel
			stepResults, err := we.executeStepsParallel(ctx, stepGroup, workflowCtx)
			result.StepResults = append(result.StepResults, stepResults...)

			if err != nil {
				// Check if any required steps failed
				for _, step := range stepGroup {
					if step.Required {
						for _, stepResult := range stepResults {
							if stepResult.StepID == step.ID && stepResult.Status == "failed" {
								return fmt.Errorf("required step %s failed: %w", step.ID, err)
							}
						}
					}
				}
			}
		}
	}

	return nil
}

// executeStep executes a single workflow step
func (we *WorkflowEngine) executeStep(ctx context.Context, step *WorkflowStep, workflowCtx *WorkflowContext) (*WorkflowStepResult, error) {
	startTime := time.Now()

	result := &WorkflowStepResult{
		StepID:     step.ID,
		StepName:   step.Name,
		Status:     "running",
		StartTime:  startTime,
		Output:     make(map[string]interface{}),
		RetryCount: 0,
	}

	we.logger.Debug("Executing workflow step",
		"step_id", step.ID,
		"step_name", step.Name,
		"step_type", step.Type)

	// Check step conditions
	if !we.evaluateStepConditions(step.Conditions, workflowCtx) {
		result.Status = "skipped"
		endTime := time.Now()
		result.EndTime = &endTime
		result.ExecutionTime = endTime.Sub(startTime)
		return result, nil
	}

	// Set step timeout
	stepTimeout := step.Timeout
	if stepTimeout == 0 {
		stepTimeout = we.config.StepTimeout
	}

	stepCtx, cancel := context.WithTimeout(ctx, stepTimeout)
	defer cancel()

	// Execute step with retry logic
	var err error
	maxRetries := 1
	if step.RetryPolicy != nil {
		maxRetries = step.RetryPolicy.MaxAttempts
	}

	for attempt := 0; attempt < maxRetries; attempt++ {
		if attempt > 0 {
			result.RetryCount++
			we.logger.Debug("Retrying workflow step",
				"step_id", step.ID,
				"attempt", attempt+1,
				"max_attempts", maxRetries)

			// Apply retry delay
			if step.RetryPolicy != nil {
				delay := we.calculateRetryDelay(step.RetryPolicy, attempt)
				time.Sleep(delay)
			}
		}

		// Get step executor
		executor, exists := we.executor.stepExecutors[step.Type]
		if !exists {
			err = fmt.Errorf("no executor found for step type: %s", step.Type)
			break
		}

		// Execute step
		stepResult, execErr := executor.Execute(stepCtx, step, workflowCtx.Job, workflowCtx.State)
		if execErr == nil {
			result.Output = stepResult.Output
			result.Status = "completed"
			break
		}

		err = execErr
		we.logger.Warn("Step execution failed",
			"step_id", step.ID,
			"attempt", attempt+1,
			"error", err)
	}

	endTime := time.Now()
	result.EndTime = &endTime
	result.ExecutionTime = endTime.Sub(startTime)

	if err != nil {
		result.Status = "failed"
		result.Error = &WorkflowError{
			StepID:      step.ID,
			ErrorType:   "step_execution",
			Message:     err.Error(),
			Timestamp:   endTime,
			Recoverable: false,
		}
		return result, err
	}

	// Update workflow context with step results
	workflowCtx.Results[step.ID] = result.Output

	return result, nil
}

// executeStepsParallel executes multiple steps in parallel
func (we *WorkflowEngine) executeStepsParallel(ctx context.Context, steps []WorkflowStep, workflowCtx *WorkflowContext) ([]WorkflowStepResult, error) {
	results := make([]WorkflowStepResult, len(steps))
	errors := make([]error, len(steps))

	var wg sync.WaitGroup
	semaphore := make(chan struct{}, we.config.MaxConcurrent)

	for i, step := range steps {
		wg.Add(1)
		go func(index int, step WorkflowStep) {
			defer wg.Done()

			semaphore <- struct{}{}
			defer func() { <-semaphore }()

			result, err := we.executeStep(ctx, &step, workflowCtx)
			results[index] = *result
			errors[index] = err
		}(i, step)
	}

	wg.Wait()

	// Check for errors
	var firstError error
	for _, err := range errors {
		if err != nil && firstError == nil {
			firstError = err
		}
	}

	return results, firstError
}

// groupStepsByOrder groups steps by their execution order
func (we *WorkflowEngine) groupStepsByOrder(steps []WorkflowStep) [][]WorkflowStep {
	// Group steps by order
	orderGroups := make(map[int][]WorkflowStep)
	for _, step := range steps {
		order := step.Order
		if order == 0 {
			order = 1 // Default order
		}
		orderGroups[order] = append(orderGroups[order], step)
	}

	// Sort by order and create groups
	var orders []int
	for order := range orderGroups {
		orders = append(orders, order)
	}

	// Simple sorting since we can't import sort
	for i := 0; i < len(orders); i++ {
		for j := i + 1; j < len(orders); j++ {
			if orders[i] > orders[j] {
				orders[i], orders[j] = orders[j], orders[i]
			}
		}
	}

	groups := make([][]WorkflowStep, len(orders))
	for i, order := range orders {
		groups[i] = orderGroups[order]
	}

	return groups
}

// evaluateWorkflowConditions evaluates workflow-level conditions
func (we *WorkflowEngine) evaluateWorkflowConditions(conditions []WorkflowCondition, context *WorkflowContext) bool {
	if len(conditions) == 0 {
		return true
	}

	for _, condition := range conditions {
		if !we.evaluateCondition(condition, context) {
			return false
		}
	}

	return true
}

// evaluateStepConditions evaluates step-level conditions
func (we *WorkflowEngine) evaluateStepConditions(conditions []WorkflowCondition, context *WorkflowContext) bool {
	if len(conditions) == 0 {
		return true
	}

	for _, condition := range conditions {
		if !we.evaluateCondition(condition, context) {
			return false
		}
	}

	return true
}

// evaluateCondition evaluates a single condition
func (we *WorkflowEngine) evaluateCondition(condition WorkflowCondition, context *WorkflowContext) bool {
	var value interface{}

	// Get value based on condition type
	switch condition.Type {
	case "vulnerability":
		value = we.getVulnerabilityFieldValue(condition.Field, context.Job.Vulnerability)
	case "job":
		value = we.getJobFieldValue(condition.Field, context.Job)
	case "state":
		value = context.State[condition.Field]
	case "variable":
		value = context.Variables[condition.Field]
	default:
		return false
	}

	// Evaluate condition
	return we.evaluateValue(value, condition.Operator, condition.Value)
}

// getVulnerabilityFieldValue gets a field value from vulnerability
func (we *WorkflowEngine) getVulnerabilityFieldValue(field string, vuln *Vulnerability) interface{} {
	switch field {
	case "cvss":
		return vuln.CVSS
	case "severity":
		return vuln.Severity
	case "cve":
		return vuln.CVE
	case "scanner_id":
		return vuln.ScannerID
	case "asset_id":
		return vuln.AssetID
	case "is_external_facing":
		return vuln.NetworkContext.IsExternalFacing
	case "port":
		return vuln.NetworkContext.Port
	default:
		return nil
	}
}

// getJobFieldValue gets a field value from job
func (we *WorkflowEngine) getJobFieldValue(field string, job *VulnerabilityJob) interface{} {
	switch field {
	case "priority":
		return job.Priority
	case "status":
		return job.Status
	case "retry_count":
		return job.RetryCount
	case "tenant_id":
		return job.TenantID
	default:
		return nil
	}
}

// evaluateValue evaluates a value against a condition
func (we *WorkflowEngine) evaluateValue(value interface{}, operator string, expected interface{}) bool {
	switch operator {
	case "equals", "==":
		return fmt.Sprintf("%v", value) == fmt.Sprintf("%v", expected)
	case "not_equals", "!=":
		return fmt.Sprintf("%v", value) != fmt.Sprintf("%v", expected)
	case "greater_than", ">":
		return we.compareNumeric(value, expected, ">")
	case "less_than", "<":
		return we.compareNumeric(value, expected, "<")
	case "greater_equal", ">=":
		return we.compareNumeric(value, expected, ">=")
	case "less_equal", "<=":
		return we.compareNumeric(value, expected, "<=")
	case "contains":
		return we.containsValue(value, expected)
	case "in":
		return we.valueInList(value, expected)
	default:
		return false
	}
}

// compareNumeric compares numeric values
func (we *WorkflowEngine) compareNumeric(a, b interface{}, operator string) bool {
	// Simple numeric comparison - would need proper type conversion in real implementation
	aVal, aOk := a.(float64)
	bVal, bOk := b.(float64)

	if !aOk || !bOk {
		return false
	}

	switch operator {
	case ">":
		return aVal > bVal
	case "<":
		return aVal < bVal
	case ">=":
		return aVal >= bVal
	case "<=":
		return aVal <= bVal
	default:
		return false
	}
}

// containsValue checks if value contains expected
func (we *WorkflowEngine) containsValue(value, expected interface{}) bool {
	valueStr := fmt.Sprintf("%v", value)
	expectedStr := fmt.Sprintf("%v", expected)

	// Simple string contains check
	return len(valueStr) >= len(expectedStr) &&
		valueStr[:len(expectedStr)] == expectedStr ||
		(len(valueStr) > len(expectedStr) &&
			valueStr[len(valueStr)-len(expectedStr):] == expectedStr)
}

// valueInList checks if value is in expected list
func (we *WorkflowEngine) valueInList(value, expected interface{}) bool {
	// Simple implementation - would need proper type handling
	valueStr := fmt.Sprintf("%v", value)
	expectedStr := fmt.Sprintf("%v", expected)
	return valueStr == expectedStr
}

// calculateRetryDelay calculates retry delay based on policy
func (we *WorkflowEngine) calculateRetryDelay(policy *RetryPolicy, attempt int) time.Duration {
	switch policy.BackoffType {
	case "exponential":
		delay := policy.Delay * time.Duration(1<<uint(attempt))
		if delay > policy.MaxDelay {
			delay = policy.MaxDelay
		}
		return delay
	case "linear":
		delay := policy.Delay * time.Duration(attempt+1)
		if delay > policy.MaxDelay {
			delay = policy.MaxDelay
		}
		return delay
	default: // fixed
		return policy.Delay
	}
}

// calculateWorkflowMetrics calculates metrics for workflow execution
func (we *WorkflowEngine) calculateWorkflowMetrics(result *WorkflowResult) WorkflowMetrics {
	metrics := WorkflowMetrics{
		TotalSteps: len(result.StepResults),
	}

	var totalStepTime float64
	parallelSteps := 0

	for _, stepResult := range result.StepResults {
		switch stepResult.Status {
		case "completed":
			metrics.CompletedSteps++
		case "failed":
			metrics.FailedSteps++
		case "skipped":
			metrics.SkippedSteps++
		}

		totalStepTime += stepResult.ExecutionTime.Seconds()

		// Note: This is simplified - would need to track parallel execution properly
		if parallelSteps > 0 {
			parallelSteps++
		}
	}

	if metrics.TotalSteps > 0 {
		metrics.SuccessRate = float64(metrics.CompletedSteps) / float64(metrics.TotalSteps)
		metrics.AverageStepTime = totalStepTime / float64(metrics.TotalSteps)
	}

	metrics.ParallelSteps = parallelSteps

	return metrics
}

// updateWorkflowStatistics updates workflow execution statistics
func (we *WorkflowEngine) updateWorkflowStatistics(workflowName string, result *WorkflowResult) {
	we.mutex.Lock()
	defer we.mutex.Unlock()

	we.statistics.TotalExecutions++

	if result.Status == "completed" {
		we.statistics.SuccessfulExecutions++
	} else {
		we.statistics.FailedExecutions++
	}

	// Update average execution time
	totalTime := we.statistics.AverageExecutionTime * float64(we.statistics.TotalExecutions-1)
	totalTime += result.ExecutionTime.Seconds()
	we.statistics.AverageExecutionTime = totalTime / float64(we.statistics.TotalExecutions)

	// Update workflow-specific statistics
	workflowStat := we.statistics.WorkflowStats[workflowName]
	workflowStat.ExecutionCount++
	workflowStat.LastExecution = time.Now()

	if result.Status == "completed" {
		workflowStat.SuccessCount++
	} else {
		workflowStat.FailureCount++
	}

	// Update workflow average time
	totalWorkflowTime := workflowStat.AverageTime * float64(workflowStat.ExecutionCount-1)
	totalWorkflowTime += result.ExecutionTime.Seconds()
	workflowStat.AverageTime = totalWorkflowTime / float64(workflowStat.ExecutionCount)

	we.statistics.WorkflowStats[workflowName] = workflowStat
	we.statistics.LastUpdate = time.Now()
}

// createDefaultWorkflows creates default workflows
func (we *WorkflowEngine) createDefaultWorkflows() {
	// Create standard validation workflow
	standardWorkflow := &WorkflowDefinition{
		ID:          "standard_validation",
		Name:        "Standard Vulnerability Validation",
		Description: "Standard workflow for vulnerability validation and scoring",
		Version:     "1.0",
		Enabled:     true,
		Steps: []WorkflowStep{
			{
				ID:       "validate",
				Name:     "Validate Vulnerability",
				Type:     "validation",
				Action:   "validate",
				Required: true,
				Order:    1,
			},
			{
				ID:       "score",
				Name:     "Calculate Priority Score",
				Type:     "scoring",
				Action:   "score",
				Required: true,
				Order:    2,
			},
			{
				ID:       "enrich",
				Name:     "Enrich Vulnerability Data",
				Type:     "enrichment",
				Action:   "enrich",
				Required: false,
				Order:    3,
			},
		},
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	// Create high priority workflow
	highPriorityWorkflow := &WorkflowDefinition{
		ID:          "high_priority",
		Name:        "High Priority Vulnerability Processing",
		Description: "Enhanced workflow for high priority vulnerabilities",
		Version:     "1.0",
		Enabled:     true,
		Conditions: []WorkflowCondition{
			{
				Field:    "cvss",
				Operator: "greater_than",
				Value:    7.0,
				Type:     "vulnerability",
			},
		},
		Steps: []WorkflowStep{
			{
				ID:       "validate",
				Name:     "Validate Vulnerability",
				Type:     "validation",
				Action:   "validate",
				Required: true,
				Order:    1,
			},
			{
				ID:       "external_validate",
				Name:     "External Validation",
				Type:     "external_validation",
				Action:   "validate_external",
				Required: false,
				Order:    1,
				Parallel: true,
			},
			{
				ID:       "score",
				Name:     "Calculate Priority Score",
				Type:     "scoring",
				Action:   "score",
				Required: true,
				Order:    2,
			},
			{
				ID:       "enrich",
				Name:     "Comprehensive Enrichment",
				Type:     "enrichment",
				Action:   "enrich_comprehensive",
				Required: true,
				Order:    3,
			},
			{
				ID:       "notify",
				Name:     "Send High Priority Notification",
				Type:     "notification",
				Action:   "notify_high_priority",
				Required: false,
				Order:    4,
			},
		},
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	we.workflows["standard"] = standardWorkflow
	we.workflows["high_priority"] = highPriorityWorkflow
	we.config.DefaultWorkflow = "standard"
}

// GetStatistics returns current workflow engine statistics
func (we *WorkflowEngine) GetStatistics() WorkflowStatistics {
	we.mutex.RLock()
	defer we.mutex.RUnlock()
	return we.statistics
}

// IsHealthy returns the health status of the workflow engine
func (we *WorkflowEngine) IsHealthy() bool {
	we.mutex.RLock()
	defer we.mutex.RUnlock()
	return we.isRunning
}

// SetValidationEngine sets the validation engine for the executor
func (we *WorkflowEngine) SetValidationEngine(engine *ValidationEngine) {
	we.executor.validationEngine = engine
}

// SetScoringEngine sets the scoring engine for the executor
func (we *WorkflowEngine) SetScoringEngine(engine *ScoringEngine) {
	we.executor.scoringEngine = engine
}

// SetEnrichmentService sets the enrichment service for the executor
func (we *WorkflowEngine) SetEnrichmentService(service EnrichmentService) {
	we.executor.enrichmentService = service
}

// registerBuiltinExecutors registers built-in step executors
func (we *WorkflowExecutor) registerBuiltinExecutors() {
	we.stepExecutors["validation"] = &ValidationStepExecutor{
		validationEngine: we.validationEngine,
		logger:           we.logger,
	}

	we.stepExecutors["scoring"] = &ScoringStepExecutor{
		scoringEngine: we.scoringEngine,
		logger:        we.logger,
	}

	we.stepExecutors["enrichment"] = &EnrichmentStepExecutor{
		enrichmentService: we.enrichmentService,
		logger:            we.logger,
	}

	we.stepExecutors["notification"] = &NotificationStepExecutor{
		logger: we.logger,
	}

	we.stepExecutors["external_validation"] = &ExternalValidationStepExecutor{
		logger: we.logger,
	}
}

// Built-in step executors
type ValidationStepExecutor struct {
	validationEngine *ValidationEngine
	logger           *slog.Logger
}

func (vse *ValidationStepExecutor) Execute(ctx context.Context, step *WorkflowStep, job *VulnerabilityJob, state map[string]interface{}) (*WorkflowStepResult, error) {
	if vse.validationEngine == nil {
		return nil, fmt.Errorf("validation engine not available")
	}

	result, err := vse.validationEngine.ValidateVulnerability(ctx, job.Vulnerability)
	if err != nil {
		return nil, err
	}

	return &WorkflowStepResult{
		Output: map[string]interface{}{
			"validation_result": result,
		},
	}, nil
}

func (vse *ValidationStepExecutor) GetStepType() string {
	return "validation"
}

type ScoringStepExecutor struct {
	scoringEngine *ScoringEngine
	logger        *slog.Logger
}

func (sse *ScoringStepExecutor) Execute(ctx context.Context, step *WorkflowStep, job *VulnerabilityJob, state map[string]interface{}) (*WorkflowStepResult, error) {
	if sse.scoringEngine == nil {
		return nil, fmt.Errorf("scoring engine not available")
	}

	var validationResult *ValidationResult
	if vr, exists := state["validation_result"]; exists {
		validationResult = vr.(*ValidationResult)
	}

	score, err := sse.scoringEngine.CalculatePriorityScore(ctx, job.Vulnerability, validationResult)
	if err != nil {
		return nil, err
	}

	return &WorkflowStepResult{
		Output: map[string]interface{}{
			"priority_score": score,
		},
	}, nil
}

func (sse *ScoringStepExecutor) GetStepType() string {
	return "scoring"
}

type EnrichmentStepExecutor struct {
	enrichmentService EnrichmentService
	logger            *slog.Logger
}

func (ese *EnrichmentStepExecutor) Execute(ctx context.Context, step *WorkflowStep, job *VulnerabilityJob, state map[string]interface{}) (*WorkflowStepResult, error) {
	if ese.enrichmentService == nil {
		return nil, fmt.Errorf("enrichment service not available")
	}

	var validationResult *ValidationResult
	if vr, exists := state["validation_result"]; exists {
		validationResult = vr.(*ValidationResult)
	}

	result, err := ese.enrichmentService.EnrichVulnerability(ctx, job.Vulnerability, validationResult)
	if err != nil {
		return nil, err
	}

	return &WorkflowStepResult{
		Output: map[string]interface{}{
			"enrichment_result": result,
		},
	}, nil
}

func (ese *EnrichmentStepExecutor) GetStepType() string {
	return "enrichment"
}

type NotificationStepExecutor struct {
	logger *slog.Logger
}

func (nse *NotificationStepExecutor) Execute(ctx context.Context, step *WorkflowStep, job *VulnerabilityJob, state map[string]interface{}) (*WorkflowStepResult, error) {
	// Placeholder implementation
	nse.logger.Info("Sending notification",
		"job_id", job.ID,
		"vulnerability_id", job.VulnerabilityID)

	return &WorkflowStepResult{
		Output: map[string]interface{}{
			"notification_sent": true,
		},
	}, nil
}

func (nse *NotificationStepExecutor) GetStepType() string {
	return "notification"
}

type ExternalValidationStepExecutor struct {
	logger *slog.Logger
}

func (evse *ExternalValidationStepExecutor) Execute(ctx context.Context, step *WorkflowStep, job *VulnerabilityJob, state map[string]interface{}) (*WorkflowStepResult, error) {
	// Placeholder implementation
	evse.logger.Info("Performing external validation",
		"job_id", job.ID,
		"vulnerability_id", job.VulnerabilityID)

	return &WorkflowStepResult{
		Output: map[string]interface{}{
			"external_validation_result": "passed",
		},
	}, nil
}

func (evse *ExternalValidationStepExecutor) GetStepType() string {
	return "external_validation"
}
