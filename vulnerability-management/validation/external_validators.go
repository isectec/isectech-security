package validation

import (
	"context"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"net/url"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"time"
)

// NIST NVD Validator
type NISTNVDValidator struct {
	config     ValidatorConfig
	client     *http.Client
	logger     *slog.Logger
	statistics NISTValidatorStatistics
	mutex      sync.RWMutex
}

type NISTValidatorStatistics struct {
	TotalRequests     int64     `json:"total_requests"`
	SuccessfulLookups int64     `json:"successful_lookups"`
	FailedLookups     int64     `json:"failed_lookups"`
	AverageResponseTime float64 `json:"average_response_time"`
	LastUpdate        time.Time `json:"last_update"`
}

type NISTCVEResponse struct {
	ResultsPerPage int `json:"resultsPerPage"`
	StartIndex     int `json:"startIndex"`
	TotalResults   int `json:"totalResults"`
	Format         string `json:"format"`
	Version        string `json:"version"`
	Timestamp      string `json:"timestamp"`
	Vulnerabilities []NISTVulnerability `json:"vulnerabilities"`
}

type NISTVulnerability struct {
	CVE struct {
		ID               string `json:"id"`
		SourceIdentifier string `json:"sourceIdentifier"`
		Published        string `json:"published"`
		LastModified     string `json:"lastModified"`
		VulnStatus       string `json:"vulnStatus"`
		Descriptions     []struct {
			Lang  string `json:"lang"`
			Value string `json:"value"`
		} `json:"descriptions"`
		Metrics struct {
			CVSSMetricV31 []struct {
				Source   string `json:"source"`
				Type     string `json:"type"`
				CVSSData struct {
					Version               string  `json:"version"`
					VectorString          string  `json:"vectorString"`
					AttackVector          string  `json:"attackVector"`
					AttackComplexity      string  `json:"attackComplexity"`
					PrivilegesRequired    string  `json:"privilegesRequired"`
					UserInteraction       string  `json:"userInteraction"`
					Scope                 string  `json:"scope"`
					ConfidentialityImpact string  `json:"confidentialityImpact"`
					IntegrityImpact       string  `json:"integrityImpact"`
					AvailabilityImpact    string  `json:"availabilityImpact"`
					BaseScore             float64 `json:"baseScore"`
					BaseSeverity          string  `json:"baseSeverity"`
				} `json:"cvssData"`
				ExploitabilityScore float64 `json:"exploitabilityScore"`
				ImpactScore         float64 `json:"impactScore"`
			} `json:"cvssMetricV31"`
		} `json:"metrics"`
		Weaknesses []struct {
			Source      string `json:"source"`
			Type        string `json:"type"`
			Description []struct {
				Lang  string `json:"lang"`
				Value string `json:"value"`
			} `json:"description"`
		} `json:"weaknesses"`
		Configurations []struct {
			Nodes []struct {
				Operator string `json:"operator"`
				Negate   bool   `json:"negate"`
				CPEMatch []struct {
					Vulnerable            bool   `json:"vulnerable"`
					Criteria              string `json:"criteria"`
					VersionStartIncluding string `json:"versionStartIncluding,omitempty"`
					VersionEndExcluding   string `json:"versionEndExcluding,omitempty"`
				} `json:"cpeMatch"`
			} `json:"nodes"`
		} `json:"configurations"`
		References []struct {
			URL    string   `json:"url"`
			Source string   `json:"source"`
			Tags   []string `json:"tags,omitempty"`
		} `json:"references"`
	} `json:"cve"`
}

// MITRE CVE Validator
type MITRECVEValidator struct {
	config     ValidatorConfig
	client     *http.Client
	logger     *slog.Logger
	statistics MITREValidatorStatistics
	mutex      sync.RWMutex
}

type MITREValidatorStatistics struct {
	TotalRequests       int64     `json:"total_requests"`
	SuccessfulLookups   int64     `json:"successful_lookups"`
	FailedLookups       int64     `json:"failed_lookups"`
	AverageResponseTime float64   `json:"average_response_time"`
	LastUpdate          time.Time `json:"last_update"`
}

// VulnDB Validator
type VulnDBValidator struct {
	config     ValidatorConfig
	client     *http.Client
	logger     *slog.Logger
	statistics VulnDBValidatorStatistics
	mutex      sync.RWMutex
}

type VulnDBValidatorStatistics struct {
	TotalRequests       int64     `json:"total_requests"`
	SuccessfulLookups   int64     `json:"successful_lookups"`
	FailedLookups       int64     `json:"failed_lookups"`
	AverageResponseTime float64   `json:"average_response_time"`
	LastUpdate          time.Time `json:"last_update"`
}

// iSECTECH Custom Validator
type ISECTECHCustomValidator struct {
	config           ValidatorConfig
	client           *http.Client
	logger           *slog.Logger
	internalDB       InternalVulnDatabase
	threatFeedClient ThreatFeedClient
	statistics       ISECTECHValidatorStatistics
	mutex            sync.RWMutex
}

type ISECTECHValidatorStatistics struct {
	TotalRequests         int64     `json:"total_requests"`
	SuccessfulValidations int64     `json:"successful_validations"`
	FailedValidations     int64     `json:"failed_validations"`
	InternalDBHits        int64     `json:"internal_db_hits"`
	ThreatFeedHits        int64     `json:"threat_feed_hits"`
	AverageResponseTime   float64   `json:"average_response_time"`
	LastUpdate            time.Time `json:"last_update"`
}

// InternalVulnDatabase interface for iSECTECH's internal vulnerability database
type InternalVulnDatabase interface {
	LookupVulnerability(ctx context.Context, cve string, fingerprint string) (*InternalVulnRecord, error)
	ValidateFingerprint(ctx context.Context, vuln *Vulnerability) (*FingerprintValidation, error)
	GetCustomRules(ctx context.Context, vulnType string) ([]CustomValidationRule, error)
}

type InternalVulnRecord struct {
	CVE                  string                 `json:"cve"`
	InternalID           string                 `json:"internal_id"`
	Confidence           float64                `json:"confidence"`
	ValidationHistory    []ValidationEvent     `json:"validation_history"`
	KnownFalsePositives  []FalsePositivePattern `json:"known_false_positives"`
	CustomMetadata       map[string]interface{} `json:"custom_metadata"`
	LastValidated        time.Time             `json:"last_validated"`
	ValidationCount      int                   `json:"validation_count"`
}

type ValidationEvent struct {
	Timestamp    time.Time `json:"timestamp"`
	ValidatorID  string    `json:"validator_id"`
	Result       bool      `json:"result"`
	Confidence   float64   `json:"confidence"`
	Notes        string    `json:"notes"`
}

type FalsePositivePattern struct {
	Pattern     string    `json:"pattern"`
	Scanner     string    `json:"scanner"`
	Confidence  float64   `json:"confidence"`
	FirstSeen   time.Time `json:"first_seen"`
	LastSeen    time.Time `json:"last_seen"`
	Occurrences int       `json:"occurrences"`
}

type FingerprintValidation struct {
	IsValid         bool     `json:"is_valid"`
	MatchedFingerprints []string `json:"matched_fingerprints"`
	Confidence      float64  `json:"confidence"`
	ValidationRules []string `json:"validation_rules"`
}

type CustomValidationRule struct {
	ID          string                 `json:"id"`
	Name        string                 `json:"name"`
	Type        string                 `json:"type"`
	Pattern     string                 `json:"pattern"`
	Confidence  float64                `json:"confidence"`
	Enabled     bool                   `json:"enabled"`
	Metadata    map[string]interface{} `json:"metadata"`
}

// ThreatFeedClient interface for threat intelligence feeds
type ThreatFeedClient interface {
	QueryThreatFeed(ctx context.Context, indicators []string) (*ThreatFeedResponse, error)
	IsIOCKnown(ctx context.Context, ioc string) (bool, error)
	GetThreatContext(ctx context.Context, cve string) (*ThreatContext, error)
}

type ThreatFeedResponse struct {
	Indicators []ThreatIndicator      `json:"indicators"`
	Context    map[string]interface{} `json:"context"`
	Timestamp  time.Time              `json:"timestamp"`
}

type ThreatIndicator struct {
	Value      string    `json:"value"`
	Type       string    `json:"type"`
	Confidence float64   `json:"confidence"`
	FirstSeen  time.Time `json:"first_seen"`
	LastSeen   time.Time `json:"last_seen"`
	Tags       []string  `json:"tags"`
}

type ThreatContext struct {
	CVE            string                 `json:"cve"`
	ThreatActors   []string               `json:"threat_actors"`
	Campaigns      []string               `json:"campaigns"`
	Malware        []string               `json:"malware"`
	ExploitKits    []string               `json:"exploit_kits"`
	IOCs           []ThreatIndicator      `json:"iocs"`
	GeographicData map[string]interface{} `json:"geographic_data"`
	Confidence     float64                `json:"confidence"`
	LastUpdated    time.Time              `json:"last_updated"`
}

// Constructor functions

func NewNISTNVDValidator(config ValidatorConfig) (ExternalValidator, error) {
	client := &http.Client{
		Timeout: config.Timeout,
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: false,
			},
			MaxIdleConns:        10,
			IdleConnTimeout:     30 * time.Second,
			DisableCompression:  false,
		},
	}

	return &NISTNVDValidator{
		config: config,
		client: client,
		logger: slog.Default(),
		statistics: NISTValidatorStatistics{
			LastUpdate: time.Now(),
		},
	}, nil
}

func NewMITRECVEValidator(config ValidatorConfig) (ExternalValidator, error) {
	client := &http.Client{
		Timeout: config.Timeout,
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: false,
			},
		},
	}

	return &MITRECVEValidator{
		config: config,
		client: client,
		logger: slog.Default(),
		statistics: MITREValidatorStatistics{
			LastUpdate: time.Now(),
		},
	}, nil
}

func NewVulnDBValidator(config ValidatorConfig) (ExternalValidator, error) {
	client := &http.Client{
		Timeout: config.Timeout,
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: false,
			},
		},
	}

	return &VulnDBValidator{
		config: config,
		client: client,
		logger: slog.Default(),
		statistics: VulnDBValidatorStatistics{
			LastUpdate: time.Now(),
		},
	}, nil
}

func NewISECTECHCustomValidator(config ValidatorConfig) (ExternalValidator, error) {
	client := &http.Client{
		Timeout: config.Timeout,
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: false,
			},
		},
	}

	validator := &ISECTECHCustomValidator{
		config: config,
		client: client,
		logger: slog.Default(),
		statistics: ISECTECHValidatorStatistics{
			LastUpdate: time.Now(),
		},
	}

	// Initialize internal components
	// These would be configured based on iSECTECH's specific requirements
	if internalDBEndpoint, exists := config.CustomConfig["internal_db_endpoint"]; exists {
		validator.internalDB = NewInternalVulnDB(internalDBEndpoint.(string))
	}

	if threatFeedEndpoint, exists := config.CustomConfig["threat_feed_endpoint"]; exists {
		validator.threatFeedClient = NewThreatFeedClient(threatFeedEndpoint.(string), config.APIKey)
	}

	return validator, nil
}

// NIST NVD Validator implementation

func (nv *NISTNVDValidator) ValidateVulnerability(ctx context.Context, vuln *Vulnerability) (*ExternalValidationResult, error) {
	startTime := time.Now()
	nv.updateRequestCount()

	if vuln.CVE == "" {
		return &ExternalValidationResult{
			ServiceName:     "NIST_NVD",
			IsValid:         false,
			ConfidenceScore: 0.0,
			Metadata: map[string]interface{}{
				"error": "No CVE identifier provided",
			},
			ResponseTime: time.Since(startTime),
		}, nil
	}

	// Query NIST NVD API
	nvdData, err := nv.queryNVDAPI(ctx, vuln.CVE)
	if err != nil {
		nv.updateFailedLookup()
		return nil, fmt.Errorf("NIST NVD query failed: %w", err)
	}

	nv.updateSuccessfulLookup()
	responseTime := time.Since(startTime)
	nv.updateResponseTime(responseTime)

	// Validate against NIST data
	result := nv.validateAgainstNVD(vuln, nvdData)
	result.ServiceName = "NIST_NVD"
	result.ResponseTime = responseTime

	return result, nil
}

func (nv *NISTNVDValidator) queryNVDAPI(ctx context.Context, cve string) (*NISTCVEResponse, error) {
	// Construct NVD API URL
	baseURL := "https://services.nvd.nist.gov/rest/json/cves/2.0"
	params := url.Values{}
	params.Add("cveId", cve)

	reqURL := fmt.Sprintf("%s?%s", baseURL, params.Encode())

	req, err := http.NewRequestWithContext(ctx, "GET", reqURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Add API key if provided
	if nv.config.APIKey != "" {
		req.Header.Set("apiKey", nv.config.APIKey)
	}

	req.Header.Set("User-Agent", "iSECTECH-VulnMgmt/1.0")
	req.Header.Set("Accept", "application/json")

	resp, err := nv.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("HTTP request failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("NVD API returned status %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	var nvdResponse NISTCVEResponse
	if err := json.Unmarshal(body, &nvdResponse); err != nil {
		return nil, fmt.Errorf("failed to parse NVD response: %w", err)
	}

	return &nvdResponse, nil
}

func (nv *NISTNVDValidator) validateAgainstNVD(vuln *Vulnerability, nvdData *NISTCVEResponse) *ExternalValidationResult {
	if len(nvdData.Vulnerabilities) == 0 {
		return &ExternalValidationResult{
			IsValid:         false,
			ConfidenceScore: 0.0,
			Metadata: map[string]interface{}{
				"error": "CVE not found in NIST NVD",
			},
		}
	}

	nvdVuln := nvdData.Vulnerabilities[0]
	confidence := 0.5 // Base confidence
	isValid := true
	metadata := make(map[string]interface{})

	// Validate CVSS score if available
	if len(nvdVuln.CVE.Metrics.CVSSMetricV31) > 0 {
		nvdCVSS := nvdVuln.CVE.Metrics.CVSSMetricV31[0].CVSSData.BaseScore
		metadata["nvd_cvss"] = nvdCVSS
		metadata["nvd_severity"] = nvdVuln.CVE.Metrics.CVSSMetricV31[0].CVSSData.BaseSeverity

		// Compare CVSS scores
		if math.Abs(vuln.CVSS-nvdCVSS) <= 1.0 {
			confidence += 0.3 // Good CVSS match
		} else if math.Abs(vuln.CVSS-nvdCVSS) <= 2.0 {
			confidence += 0.1 // Acceptable CVSS difference
		} else {
			confidence -= 0.2 // Significant CVSS difference
		}
	}

	// Validate description similarity
	if len(nvdVuln.CVE.Descriptions) > 0 {
		nvdDescription := nvdVuln.CVE.Descriptions[0].Value
		metadata["nvd_description"] = nvdDescription

		// Simple similarity check
		if nv.calculateDescriptionSimilarity(vuln.Description, nvdDescription) > 0.3 {
			confidence += 0.2
		}
	}

	// Check vulnerability status
	if nvdVuln.CVE.VulnStatus == "Analyzed" {
		confidence += 0.1
	}

	// Add publication and modification dates
	metadata["nvd_published"] = nvdVuln.CVE.Published
	metadata["nvd_modified"] = nvdVuln.CVE.LastModified
	metadata["nvd_status"] = nvdVuln.CVE.VulnStatus

	// Ensure confidence is within bounds
	if confidence > 1.0 {
		confidence = 1.0
	}
	if confidence < 0.0 {
		confidence = 0.0
		isValid = false
	}

	return &ExternalValidationResult{
		IsValid:         isValid,
		ConfidenceScore: confidence,
		Metadata:        metadata,
	}
}

func (nv *NISTNVDValidator) calculateDescriptionSimilarity(desc1, desc2 string) float64 {
	// Simple word-based similarity calculation
	words1 := strings.Fields(strings.ToLower(desc1))
	words2 := strings.Fields(strings.ToLower(desc2))

	if len(words1) == 0 || len(words2) == 0 {
		return 0.0
	}

	// Create word frequency maps
	freq1 := make(map[string]int)
	freq2 := make(map[string]int)

	for _, word := range words1 {
		freq1[word]++
	}
	for _, word := range words2 {
		freq2[word]++
	}

	// Calculate Jaccard similarity
	intersection := 0
	union := 0

	allWords := make(map[string]bool)
	for word := range freq1 {
		allWords[word] = true
	}
	for word := range freq2 {
		allWords[word] = true
	}

	for word := range allWords {
		c1, exists1 := freq1[word]
		c2, exists2 := freq2[word]

		if exists1 && exists2 {
			intersection += min(c1, c2)
		}
		
		max_count := 0
		if exists1 {
			max_count = c1
		}
		if exists2 && c2 > max_count {
			max_count = c2
		}
		union += max_count
	}

	if union == 0 {
		return 0.0
	}

	return float64(intersection) / float64(union)
}

func (nv *NISTNVDValidator) GetServiceInfo() ValidatorInfo {
	return ValidatorInfo{
		Name:        "NIST NVD Validator",
		Version:     "1.0",
		Description: "Validates vulnerabilities against NIST National Vulnerability Database",
		Capabilities: []string{
			"CVE validation",
			"CVSS verification",
			"Description matching",
			"Publication date verification",
		},
	}
}

func (nv *NISTNVDValidator) IsHealthy(ctx context.Context) bool {
	// Simple health check - try to query a known CVE
	testCVE := "CVE-2021-44228" // Log4Shell
	_, err := nv.queryNVDAPI(ctx, testCVE)
	return err == nil
}

func (nv *NISTNVDValidator) updateRequestCount() {
	nv.mutex.Lock()
	defer nv.mutex.Unlock()
	nv.statistics.TotalRequests++
}

func (nv *NISTNVDValidator) updateSuccessfulLookup() {
	nv.mutex.Lock()
	defer nv.mutex.Unlock()
	nv.statistics.SuccessfulLookups++
}

func (nv *NISTNVDValidator) updateFailedLookup() {
	nv.mutex.Lock()
	defer nv.mutex.Unlock()
	nv.statistics.FailedLookups++
}

func (nv *NISTNVDValidator) updateResponseTime(duration time.Duration) {
	nv.mutex.Lock()
	defer nv.mutex.Unlock()

	totalTime := nv.statistics.AverageResponseTime * float64(nv.statistics.SuccessfulLookups-1)
	totalTime += duration.Seconds()
	nv.statistics.AverageResponseTime = totalTime / float64(nv.statistics.SuccessfulLookups)
	nv.statistics.LastUpdate = time.Now()
}

// iSECTECH Custom Validator implementation

func (iv *ISECTECHCustomValidator) ValidateVulnerability(ctx context.Context, vuln *Vulnerability) (*ExternalValidationResult, error) {
	startTime := time.Now()
	iv.updateRequestCount()

	result := &ExternalValidationResult{
		ServiceName:     "iSECTECH_Custom",
		IsValid:         true,
		ConfidenceScore: 0.5,
		Metadata:        make(map[string]interface{}),
		ResponseTime:    0,
	}

	var confidence float64 = 0.5
	validationResults := make([]string, 0)

	// 1. Internal database validation
	if iv.internalDB != nil {
		internalRecord, err := iv.internalDB.LookupVulnerability(ctx, vuln.CVE, iv.generateFingerprint(vuln))
		if err != nil {
			iv.logger.Warn("Internal DB lookup failed", "error", err)
		} else if internalRecord != nil {
			iv.updateInternalDBHit()
			confidence += 0.2 * internalRecord.Confidence
			validationResults = append(validationResults, "internal_db_match")
			result.Metadata["internal_record"] = internalRecord
		}

		// Validate fingerprint
		fpValidation, err := iv.internalDB.ValidateFingerprint(ctx, vuln)
		if err != nil {
			iv.logger.Warn("Fingerprint validation failed", "error", err)
		} else if fpValidation.IsValid {
			confidence += 0.1 * fpValidation.Confidence
			validationResults = append(validationResults, "fingerprint_validated")
			result.Metadata["fingerprint_validation"] = fpValidation
		}
	}

	// 2. Threat intelligence validation
	if iv.threatFeedClient != nil {
		threatContext, err := iv.threatFeedClient.GetThreatContext(ctx, vuln.CVE)
		if err != nil {
			iv.logger.Warn("Threat feed query failed", "error", err)
		} else if threatContext != nil {
			iv.updateThreatFeedHit()
			confidence += 0.15 * threatContext.Confidence
			validationResults = append(validationResults, "threat_intel_available")
			result.Metadata["threat_context"] = threatContext
		}

		// Check for IOCs in vulnerability data
		iocs := iv.extractIOCs(vuln)
		if len(iocs) > 0 {
			for _, ioc := range iocs {
				isKnown, err := iv.threatFeedClient.IsIOCKnown(ctx, ioc)
				if err == nil && isKnown {
					confidence += 0.05
					validationResults = append(validationResults, fmt.Sprintf("known_ioc_%s", ioc))
				}
			}
		}
	}

	// 3. Custom validation rules
	if iv.internalDB != nil {
		vulnType := iv.determineVulnerabilityType(vuln)
		customRules, err := iv.internalDB.GetCustomRules(ctx, vulnType)
		if err != nil {
			iv.logger.Warn("Failed to get custom rules", "error", err)
		} else {
			ruleMatches := iv.applyCustomRules(vuln, customRules)
			for _, match := range ruleMatches {
				confidence += 0.05 * match.Confidence
				validationResults = append(validationResults, fmt.Sprintf("rule_match_%s", match.ID))
			}
			result.Metadata["custom_rule_matches"] = ruleMatches
		}
	}

	// 4. iSECTECH specific validations
	iv.performISECTECHValidations(vuln, result, &confidence, &validationResults)

	// Finalize result
	if confidence > 1.0 {
		confidence = 1.0
	}
	if confidence < 0.3 {
		result.IsValid = false
	}

	result.ConfidenceScore = confidence
	result.Metadata["validation_methods"] = validationResults
	result.ResponseTime = time.Since(startTime)

	iv.updateResponseTime(result.ResponseTime)
	if result.IsValid {
		iv.updateSuccessfulValidation()
	} else {
		iv.updateFailedValidation()
	}

	return result, nil
}

func (iv *ISECTECHCustomValidator) generateFingerprint(vuln *Vulnerability) string {
	// Generate a unique fingerprint for the vulnerability
	// This could include hash of key vulnerability attributes
	fingerprint := fmt.Sprintf("%s_%s_%s_%d_%s",
		vuln.CVE,
		vuln.ScannerID,
		vuln.AssetID,
		vuln.NetworkContext.Port,
		vuln.Severity)
	
	return fingerprint
}

func (iv *ISECTECHCustomValidator) extractIOCs(vuln *Vulnerability) []string {
	iocs := make([]string, 0)
	
	// Extract IPs from network context
	if vuln.NetworkContext.SourceIP != "" {
		iocs = append(iocs, vuln.NetworkContext.SourceIP)
	}
	if vuln.NetworkContext.DestinationIP != "" {
		iocs = append(iocs, vuln.NetworkContext.DestinationIP)
	}

	// Extract URLs, IPs, and domains from description and evidence
	text := vuln.Description
	for _, evidence := range vuln.Evidence {
		if str, ok := evidence.(string); ok {
			text += " " + str
		}
	}

	// IP address regex
	ipRegex := regexp.MustCompile(`\b(?:\d{1,3}\.){3}\d{1,3}\b`)
	ips := ipRegex.FindAllString(text, -1)
	iocs = append(iocs, ips...)

	// URL regex
	urlRegex := regexp.MustCompile(`https?://[^\s]+`)
	urls := urlRegex.FindAllString(text, -1)
	for _, url := range urls {
		// Extract domain from URL
		if u, err := url.Parse(url); err == nil {
			iocs = append(iocs, u.Hostname())
		}
	}

	// Domain regex
	domainRegex := regexp.MustCompile(`\b[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*\.[a-zA-Z]{2,}\b`)
	domains := domainRegex.FindAllString(text, -1)
	iocs = append(iocs, domains...)

	// Remove duplicates
	seen := make(map[string]bool)
	uniqueIOCs := make([]string, 0)
	for _, ioc := range iocs {
		if !seen[ioc] {
			seen[ioc] = true
			uniqueIOCs = append(uniqueIOCs, ioc)
		}
	}

	return uniqueIOCs
}

func (iv *ISECTECHCustomValidator) determineVulnerabilityType(vuln *Vulnerability) string {
	// Determine vulnerability type based on various factors
	desc := strings.ToLower(vuln.Description)
	
	if strings.Contains(desc, "sql injection") || strings.Contains(desc, "sqli") {
		return "sql_injection"
	}
	if strings.Contains(desc, "cross-site scripting") || strings.Contains(desc, "xss") {
		return "xss"
	}
	if strings.Contains(desc, "remote code execution") || strings.Contains(desc, "rce") {
		return "rce"
	}
	if strings.Contains(desc, "buffer overflow") {
		return "buffer_overflow"
	}
	if strings.Contains(desc, "path traversal") || strings.Contains(desc, "directory traversal") {
		return "path_traversal"
	}
	if strings.Contains(desc, "authentication bypass") || strings.Contains(desc, "auth bypass") {
		return "auth_bypass"
	}
	if strings.Contains(desc, "privilege escalation") {
		return "privilege_escalation"
	}
	if strings.Contains(desc, "denial of service") || strings.Contains(desc, "dos") {
		return "dos"
	}
	if strings.Contains(desc, "information disclosure") {
		return "info_disclosure"
	}

	// Check by port/service
	switch vuln.NetworkContext.Port {
	case 80, 443, 8080, 8443:
		return "web_application"
	case 22:
		return "ssh"
	case 21:
		return "ftp"
	case 25, 587, 465:
		return "email"
	case 53:
		return "dns"
	case 1433, 3306, 5432:
		return "database"
	}

	return "general"
}

func (iv *ISECTECHCustomValidator) applyCustomRules(vuln *Vulnerability, rules []CustomValidationRule) []CustomValidationRule {
	matches := make([]CustomValidationRule, 0)

	for _, rule := range rules {
		if !rule.Enabled {
			continue
		}

		if iv.ruleMatches(vuln, rule) {
			matches = append(matches, rule)
		}
	}

	return matches
}

func (iv *ISECTECHCustomValidator) ruleMatches(vuln *Vulnerability, rule CustomValidationRule) bool {
	switch rule.Type {
	case "regex":
		regex, err := regexp.Compile(rule.Pattern)
		if err != nil {
			return false
		}
		return regex.MatchString(vuln.Description) || regex.MatchString(vuln.Title)
	
	case "port":
		if portStr := rule.Pattern; portStr != "" {
			if port, err := strconv.Atoi(portStr); err == nil {
				return vuln.NetworkContext.Port == port
			}
		}
	
	case "scanner":
		return strings.ToLower(vuln.ScannerID) == strings.ToLower(rule.Pattern)
	
	case "severity":
		return strings.ToLower(vuln.Severity) == strings.ToLower(rule.Pattern)
	
	case "cvss_range":
		// Pattern should be like "7.0-9.0"
		parts := strings.Split(rule.Pattern, "-")
		if len(parts) == 2 {
			if min, err := strconv.ParseFloat(parts[0], 64); err == nil {
				if max, err := strconv.ParseFloat(parts[1], 64); err == nil {
					return vuln.CVSS >= min && vuln.CVSS <= max
				}
			}
		}
	}

	return false
}

func (iv *ISECTECHCustomValidator) performISECTECHValidations(vuln *Vulnerability, result *ExternalValidationResult, confidence *float64, validationResults *[]string) {
	// iSECTECH specific validation logic
	
	// 1. Asset context validation
	if vuln.AssetID != "" {
		// Check if asset is in critical asset list
		if iv.isBusinessCriticalAsset(vuln.AssetID) {
			*confidence += 0.1
			*validationResults = append(*validationResults, "business_critical_asset")
		}
	}

	// 2. Network segment validation
	if vuln.NetworkContext.NetworkSegment != "" {
		switch strings.ToLower(vuln.NetworkContext.NetworkSegment) {
		case "dmz", "public":
			*confidence += 0.05 // Higher confidence for exposed segments
		case "critical", "production":
			*confidence += 0.08
		}
	}

	// 3. Time-based validation
	age := time.Since(vuln.DiscoveryTime)
	if age < time.Hour*24 { // Very recent vulnerability
		*confidence += 0.05
		*validationResults = append(*validationResults, "recent_discovery")
	}

	// 4. Scanner-specific validation for iSECTECH trusted scanners
	trustedScanners := []string{"isectech_custom", "isectech_enhanced", "enterprise_scanner"}
	for _, trusted := range trustedScanners {
		if strings.Contains(strings.ToLower(vuln.ScannerID), trusted) {
			*confidence += 0.1
			*validationResults = append(*validationResults, "trusted_scanner")
			break
		}
	}

	// 5. Evidence quality assessment
	evidenceScore := iv.assessEvidenceQuality(vuln.Evidence)
	*confidence += evidenceScore * 0.1
	
	if evidenceScore > 0.8 {
		*validationResults = append(*validationResults, "high_quality_evidence")
	}

	// Add iSECTECH metadata
	result.Metadata["isectech_validation"] = map[string]interface{}{
		"asset_criticality":     iv.getAssetCriticality(vuln.AssetID),
		"network_segment":       vuln.NetworkContext.NetworkSegment,
		"discovery_age_hours":   age.Hours(),
		"evidence_quality":      evidenceScore,
		"scanner_trust_level":   iv.getScannerTrustLevel(vuln.ScannerID),
	}
}

func (iv *ISECTECHCustomValidator) isBusinessCriticalAsset(assetID string) bool {
	// This would query the asset management system
	// For now, return a simple heuristic
	criticalPrefixes := []string{"db-", "dc-", "fin-", "core-", "prod-"}
	for _, prefix := range criticalPrefixes {
		if strings.HasPrefix(strings.ToLower(assetID), prefix) {
			return true
		}
	}
	return false
}

func (iv *ISECTECHCustomValidator) getAssetCriticality(assetID string) string {
	// This would query the asset management system
	if iv.isBusinessCriticalAsset(assetID) {
		return "critical"
	}
	return "normal"
}

func (iv *ISECTECHCustomValidator) getScannerTrustLevel(scannerID string) string {
	trustedScanners := map[string]string{
		"isectech_custom":     "high",
		"isectech_enhanced":   "high",
		"enterprise_scanner":  "high",
		"nessus":             "medium",
		"openvas":            "medium",
		"nmap":               "high",
		"trivy":              "medium",
	}

	for scanner, trustLevel := range trustedScanners {
		if strings.Contains(strings.ToLower(scannerID), scanner) {
			return trustLevel
		}
	}
	return "low"
}

func (iv *ISECTECHCustomValidator) assessEvidenceQuality(evidence map[string]interface{}) float64 {
	if len(evidence) == 0 {
		return 0.0
	}

	score := 0.0
	maxScore := 0.0

	// Check for high-quality evidence types
	qualityFactors := map[string]float64{
		"request":         0.2,
		"response":        0.2,
		"payload":         0.15,
		"headers":         0.1,
		"screenshot":      0.1,
		"status_code":     0.05,
		"content_length":  0.05,
		"timing":         0.05,
		"hash":           0.1,
	}

	for factor, weight := range qualityFactors {
		maxScore += weight
		if _, exists := evidence[factor]; exists {
			score += weight
		}
	}

	if maxScore == 0 {
		return 0.5 // Default score
	}

	return score / maxScore
}

func (iv *ISECTECHCustomValidator) GetServiceInfo() ValidatorInfo {
	return ValidatorInfo{
		Name:        "iSECTECH Custom Validator",
		Version:     "1.0",
		Description: "Custom validation engine tailored for iSECTECH's specific requirements",
		Capabilities: []string{
			"Internal database validation",
			"Threat intelligence correlation",
			"Custom rule validation",
			"Asset context validation",
			"Evidence quality assessment",
			"Business criticality assessment",
		},
	}
}

func (iv *ISECTECHCustomValidator) IsHealthy(ctx context.Context) bool {
	// Check health of internal components
	healthy := true

	if iv.internalDB != nil {
		// Check internal DB health
		_, err := iv.internalDB.GetCustomRules(ctx, "test")
		if err != nil {
			healthy = false
		}
	}

	if iv.threatFeedClient != nil {
		// Check threat feed health
		_, err := iv.threatFeedClient.IsIOCKnown(ctx, "8.8.8.8")
		if err != nil {
			healthy = false
		}
	}

	return healthy
}

// Statistics update methods for iSECTECH validator
func (iv *ISECTECHCustomValidator) updateRequestCount() {
	iv.mutex.Lock()
	defer iv.mutex.Unlock()
	iv.statistics.TotalRequests++
}

func (iv *ISECTECHCustomValidator) updateSuccessfulValidation() {
	iv.mutex.Lock()
	defer iv.mutex.Unlock()
	iv.statistics.SuccessfulValidations++
}

func (iv *ISECTECHCustomValidator) updateFailedValidation() {
	iv.mutex.Lock()
	defer iv.mutex.Unlock()
	iv.statistics.FailedValidations++
}

func (iv *ISECTECHCustomValidator) updateInternalDBHit() {
	iv.mutex.Lock()
	defer iv.mutex.Unlock()
	iv.statistics.InternalDBHits++
}

func (iv *ISECTECHCustomValidator) updateThreatFeedHit() {
	iv.mutex.Lock()
	defer iv.mutex.Unlock()
	iv.statistics.ThreatFeedHits++
}

func (iv *ISECTECHCustomValidator) updateResponseTime(duration time.Duration) {
	iv.mutex.Lock()
	defer iv.mutex.Unlock()

	total := iv.statistics.SuccessfulValidations + iv.statistics.FailedValidations
	if total > 0 {
		totalTime := iv.statistics.AverageResponseTime * float64(total-1)
		totalTime += duration.Seconds()
		iv.statistics.AverageResponseTime = totalTime / float64(total)
	}
	iv.statistics.LastUpdate = time.Now()
}

// Placeholder implementations for MITRE and VulnDB validators
func (mv *MITRECVEValidator) ValidateVulnerability(ctx context.Context, vuln *Vulnerability) (*ExternalValidationResult, error) {
	// Placeholder implementation
	return &ExternalValidationResult{
		ServiceName:     "MITRE_CVE",
		IsValid:         true,
		ConfidenceScore: 0.8,
		Metadata: map[string]interface{}{
			"status": "placeholder_implementation",
		},
		ResponseTime: time.Millisecond * 100,
	}, nil
}

func (mv *MITRECVEValidator) GetServiceInfo() ValidatorInfo {
	return ValidatorInfo{
		Name:        "MITRE CVE Validator",
		Version:     "1.0",
		Description: "Validates vulnerabilities against MITRE CVE database",
		Capabilities: []string{"CVE validation", "CWE mapping"},
	}
}

func (mv *MITRECVEValidator) IsHealthy(ctx context.Context) bool {
	return true // Placeholder
}

func (vv *VulnDBValidator) ValidateVulnerability(ctx context.Context, vuln *Vulnerability) (*ExternalValidationResult, error) {
	// Placeholder implementation
	return &ExternalValidationResult{
		ServiceName:     "VulnDB",
		IsValid:         true,
		ConfidenceScore: 0.75,
		Metadata: map[string]interface{}{
			"status": "placeholder_implementation",
		},
		ResponseTime: time.Millisecond * 150,
	}, nil
}

func (vv *VulnDBValidator) GetServiceInfo() ValidatorInfo {
	return ValidatorInfo{
		Name:        "VulnDB Validator",
		Version:     "1.0",
		Description: "Validates vulnerabilities against commercial vulnerability database",
		Capabilities: []string{"Commercial vulnerability data", "Exploit information"},
	}
}

func (vv *VulnDBValidator) IsHealthy(ctx context.Context) bool {
	return true // Placeholder
}

// Helper functions and placeholder implementations
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func math.Abs(x float64) float64 {
	if x < 0 {
		return -x
	}
	return x
}

// Placeholder constructors for internal components
func NewInternalVulnDB(endpoint string) InternalVulnDatabase {
	// Placeholder implementation
	return &PlaceholderInternalDB{}
}

func NewThreatFeedClient(endpoint, apiKey string) ThreatFeedClient {
	// Placeholder implementation
	return &PlaceholderThreatFeed{}
}

// Placeholder implementations
type PlaceholderInternalDB struct{}

func (db *PlaceholderInternalDB) LookupVulnerability(ctx context.Context, cve string, fingerprint string) (*InternalVulnRecord, error) {
	// Placeholder - would query internal database
	return nil, nil
}

func (db *PlaceholderInternalDB) ValidateFingerprint(ctx context.Context, vuln *Vulnerability) (*FingerprintValidation, error) {
	// Placeholder - would validate vulnerability fingerprint
	return &FingerprintValidation{
		IsValid:    true,
		Confidence: 0.8,
	}, nil
}

func (db *PlaceholderInternalDB) GetCustomRules(ctx context.Context, vulnType string) ([]CustomValidationRule, error) {
	// Placeholder - would return custom validation rules
	return []CustomValidationRule{}, nil
}

type PlaceholderThreatFeed struct{}

func (tf *PlaceholderThreatFeed) QueryThreatFeed(ctx context.Context, indicators []string) (*ThreatFeedResponse, error) {
	return &ThreatFeedResponse{}, nil
}

func (tf *PlaceholderThreatFeed) IsIOCKnown(ctx context.Context, ioc string) (bool, error) {
	return false, nil
}

func (tf *PlaceholderThreatFeed) GetThreatContext(ctx context.Context, cve string) (*ThreatContext, error) {
	return nil, nil
}