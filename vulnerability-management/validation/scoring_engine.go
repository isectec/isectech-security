package validation

import (
	"context"
	"fmt"
	"log/slog"
	"math"
	"sort"
	"strings"
	"sync"
	"time"
)

// ScoringEngine calculates comprehensive vulnerability priority scores
type ScoringEngine struct {
	config            ScoringConfig
	weights           ScoringWeights
	logger            *slog.Logger
	assetCriticality  map[string]float64
	threatIntel       ThreatIntelligenceService
	exploitDB         ExploitDatabaseService
	patchDB           PatchDatabaseService
	businessContext   BusinessContextService
	complianceService ComplianceService
	statistics        ScoringStatistics
	cache             ScoringCache
	mutex             sync.RWMutex
}

// ScoringStatistics tracks scoring engine performance
type ScoringStatistics struct {
	TotalScored           int64     `json:"total_scored"`
	AverageScore          float64   `json:"average_score"`
	HighPriorityCount     int64     `json:"high_priority_count"`
	MediumPriorityCount   int64     `json:"medium_priority_count"`
	LowPriorityCount      int64     `json:"low_priority_count"`
	AverageScoringTime    float64   `json:"average_scoring_time"`
	ExternalServiceErrors int64     `json:"external_service_errors"`
	CacheHitRate          float64   `json:"cache_hit_rate"`
	LastUpdate            time.Time `json:"last_update"`
}

// ScoringCache provides caching for scoring results
type ScoringCache struct {
	cache     map[string]*ScoringResult
	ttl       map[string]time.Time
	mutex     sync.RWMutex
	maxSize   int
	enabled   bool
	hitCount  int64
	missCount int64
}

// ScoringResult contains comprehensive scoring information
type ScoringResult struct {
	VulnerabilityID  string               `json:"vulnerability_id"`
	OverallScore     float64              `json:"overall_score"`
	Priority         string               `json:"priority"`
	ComponentScores  ComponentScores      `json:"component_scores"`
	WeightedScores   map[string]float64   `json:"weighted_scores"`
	Justification    []string             `json:"justification"`
	ExternalData     ExternalScoringData  `json:"external_data"`
	BusinessImpact   BusinessImpactInfo   `json:"business_impact"`
	ComplianceImpact ComplianceImpactInfo `json:"compliance_impact"`
	Recommendations  []string             `json:"recommendations"`
	ProcessingTime   time.Duration        `json:"processing_time"`
	Timestamp        time.Time            `json:"timestamp"`
	CacheStatus      string               `json:"cache_status"`
}

// ComponentScores breaks down the overall score by component
type ComponentScores struct {
	CVSSScore           float64 `json:"cvss_score"`
	ExploitAvailability float64 `json:"exploit_availability"`
	AssetCriticality    float64 `json:"asset_criticality"`
	NetworkExposure     float64 `json:"network_exposure"`
	PatchAvailability   float64 `json:"patch_availability"`
	ThreatIntelligence  float64 `json:"threat_intelligence"`
	BusinessImpact      float64 `json:"business_impact"`
	ComplianceImpact    float64 `json:"compliance_impact"`
	TimeFactors         float64 `json:"time_factors"`
	ContextualFactors   float64 `json:"contextual_factors"`
}

// ExternalScoringData contains data from external services
type ExternalScoringData struct {
	ThreatIntelligence *ThreatIntelData `json:"threat_intelligence,omitempty"`
	ExploitInfo        *ExploitInfo     `json:"exploit_info,omitempty"`
	PatchInfo          *PatchInfo       `json:"patch_info,omitempty"`
	VendorAdvisory     *VendorAdvisory  `json:"vendor_advisory,omitempty"`
}

// ThreatIntelData contains threat intelligence information
type ThreatIntelData struct {
	ThreatScore       float64                `json:"threat_score"`
	IOCMatches        []string               `json:"ioc_matches"`
	CampaignTags      []string               `json:"campaign_tags"`
	ThreatActors      []string               `json:"threat_actors"`
	GeographicOrigin  string                 `json:"geographic_origin"`
	FirstSeen         time.Time              `json:"first_seen"`
	LastSeen          time.Time              `json:"last_seen"`
	Confidence        float64                `json:"confidence"`
	Sources           []string               `json:"sources"`
	AdditionalContext map[string]interface{} `json:"additional_context"`
}

// ExploitInfo contains exploit availability information
type ExploitInfo struct {
	HasPublicExploit   bool                   `json:"has_public_exploit"`
	ExploitMaturity    string                 `json:"exploit_maturity"`
	ExploitSources     []string               `json:"exploit_sources"`
	ExploitDifficulty  string                 `json:"exploit_difficulty"`
	RequiredPrivileges string                 `json:"required_privileges"`
	UserInteraction    bool                   `json:"user_interaction"`
	RemoteExploitable  bool                   `json:"remote_exploitable"`
	MetasploitModules  []string               `json:"metasploit_modules"`
	PublicPOCs         []string               `json:"public_pocs"`
	ExploitKits        []string               `json:"exploit_kits"`
	FirstExploitSeen   *time.Time             `json:"first_exploit_seen,omitempty"`
	RecentActivity     bool                   `json:"recent_activity"`
	ExploitScore       float64                `json:"exploit_score"`
	Metadata           map[string]interface{} `json:"metadata"`
}

// PatchInfo contains patch availability information
type PatchInfo struct {
	PatchAvailable      bool                   `json:"patch_available"`
	PatchDate           *time.Time             `json:"patch_date,omitempty"`
	PatchSources        []string               `json:"patch_sources"`
	PatchComplexity     string                 `json:"patch_complexity"`
	RequiresReboot      bool                   `json:"requires_reboot"`
	RequiresDowntime    bool                   `json:"requires_downtime"`
	PatchSize           int64                  `json:"patch_size"`
	DependentPatches    []string               `json:"dependent_patches"`
	WorkaroundAvailable bool                   `json:"workaround_available"`
	Workarounds         []string               `json:"workarounds"`
	VendorAcknowledged  bool                   `json:"vendor_acknowledged"`
	PatchScore          float64                `json:"patch_score"`
	Metadata            map[string]interface{} `json:"metadata"`
}

// VendorAdvisory contains vendor advisory information
type VendorAdvisory struct {
	AdvisoryID       string                 `json:"advisory_id"`
	VendorName       string                 `json:"vendor_name"`
	PublishDate      time.Time              `json:"publish_date"`
	UpdateDate       *time.Time             `json:"update_date,omitempty"`
	Severity         string                 `json:"severity"`
	Impact           string                 `json:"impact"`
	Solution         string                 `json:"solution"`
	References       []string               `json:"references"`
	AffectedVersions []string               `json:"affected_versions"`
	FixedVersions    []string               `json:"fixed_versions"`
	Metadata         map[string]interface{} `json:"metadata"`
}

// BusinessImpactInfo contains business impact assessment
type BusinessImpactInfo struct {
	BusinessScore         float64  `json:"business_score"`
	CriticalAssets        []string `json:"critical_assets"`
	ServiceImpact         string   `json:"service_impact"`
	DataSensitivity       string   `json:"data_sensitivity"`
	RevenueImpact         string   `json:"revenue_impact"`
	CustomerImpact        string   `json:"customer_impact"`
	ReputationImpact      string   `json:"reputation_impact"`
	OperationalImpact     string   `json:"operational_impact"`
	RecoveryComplexity    string   `json:"recovery_complexity"`
	EstimatedDowntime     string   `json:"estimated_downtime"`
	BusinessJustification []string `json:"business_justification"`
}

// ComplianceImpactInfo contains compliance impact assessment
type ComplianceImpactInfo struct {
	ComplianceScore         float64  `json:"compliance_score"`
	AffectedStandards       []string `json:"affected_standards"`
	ViolationType           string   `json:"violation_type"`
	RequiredTimeline        string   `json:"required_timeline"`
	PotentialFines          string   `json:"potential_fines"`
	AuditImplications       []string `json:"audit_implications"`
	ReportingRequired       bool     `json:"reporting_required"`
	RegulatoryAttention     bool     `json:"regulatory_attention"`
	ComplianceJustification []string `json:"compliance_justification"`
}

// Service interfaces for external data sources
type ThreatIntelligenceService interface {
	GetThreatIntelligence(ctx context.Context, cve string, vulnerability *Vulnerability) (*ThreatIntelData, error)
	IsHealthy(ctx context.Context) bool
}

type ExploitDatabaseService interface {
	GetExploitInfo(ctx context.Context, cve string, vulnerability *Vulnerability) (*ExploitInfo, error)
	IsHealthy(ctx context.Context) bool
}

type PatchDatabaseService interface {
	GetPatchInfo(ctx context.Context, cve string, vulnerability *Vulnerability) (*PatchInfo, error)
	IsHealthy(ctx context.Context) bool
}

type BusinessContextService interface {
	AssessBusinessImpact(ctx context.Context, vulnerability *Vulnerability, asset *AssetInfo) (*BusinessImpactInfo, error)
	GetAssetCriticality(ctx context.Context, assetID string) (float64, error)
	IsHealthy(ctx context.Context) bool
}

type ComplianceService interface {
	AssessComplianceImpact(ctx context.Context, vulnerability *Vulnerability, asset *AssetInfo) (*ComplianceImpactInfo, error)
	GetComplianceRequirements(ctx context.Context, assetID string) ([]string, error)
	IsHealthy(ctx context.Context) bool
}

// AssetInfo represents asset information for scoring
type AssetInfo struct {
	ID                 string                 `json:"id"`
	Name               string                 `json:"name"`
	Type               string                 `json:"type"`
	Criticality        string                 `json:"criticality"`
	Owner              string                 `json:"owner"`
	Environment        string                 `json:"environment"`
	NetworkSegment     string                 `json:"network_segment"`
	DataClassification string                 `json:"data_classification"`
	BusinessFunction   string                 `json:"business_function"`
	ComplianceScope    []string               `json:"compliance_scope"`
	Dependencies       []string               `json:"dependencies"`
	Metadata           map[string]interface{} `json:"metadata"`
}

// NewScoringEngine creates a new vulnerability scoring engine
func NewScoringEngine(config ScoringConfig, logger *slog.Logger) *ScoringEngine {
	if logger == nil {
		logger = slog.Default()
	}

	// Initialize cache
	cache := ScoringCache{
		cache:   make(map[string]*ScoringResult),
		ttl:     make(map[string]time.Time),
		maxSize: 1000,
		enabled: true,
	}

	engine := &ScoringEngine{
		config:           config,
		weights:          config.DefaultWeights,
		logger:           logger,
		assetCriticality: config.AssetCriticalityMap,
		cache:            cache,
		statistics: ScoringStatistics{
			LastUpdate: time.Now(),
		},
	}

	return engine
}

// CalculatePriorityScore calculates comprehensive priority score for a vulnerability
func (se *ScoringEngine) CalculatePriorityScore(ctx context.Context, vuln *Vulnerability, validationResult *ValidationResult) (float64, error) {
	startTime := time.Now()

	// Check cache first
	cacheKey := se.generateCacheKey(vuln.ID, validationResult)
	if cached := se.getCachedResult(cacheKey); cached != nil {
		cached.CacheStatus = "hit"
		se.updateCacheHitStats(true)
		return cached.OverallScore, nil
	}
	se.updateCacheHitStats(false)

	result := &ScoringResult{
		VulnerabilityID: vuln.ID,
		WeightedScores:  make(map[string]float64),
		Justification:   make([]string, 0),
		Recommendations: make([]string, 0),
		Timestamp:       time.Now(),
		CacheStatus:     "miss",
	}

	// Get asset information
	asset, err := se.getAssetInfo(ctx, vuln.AssetID)
	if err != nil {
		se.logger.Warn("Failed to get asset info",
			"asset_id", vuln.AssetID,
			"error", err)
		// Use default asset info
		asset = &AssetInfo{
			ID:          vuln.AssetID,
			Criticality: "medium",
			Type:        "unknown",
		}
	}

	// Calculate component scores
	componentScores, err := se.calculateComponentScores(ctx, vuln, asset, validationResult)
	if err != nil {
		return 0.0, fmt.Errorf("failed to calculate component scores: %w", err)
	}
	result.ComponentScores = *componentScores

	// Get external data
	externalData, err := se.gatherExternalData(ctx, vuln)
	if err != nil {
		se.logger.Warn("Failed to gather external data",
			"vulnerability_id", vuln.ID,
			"error", err)
		externalData = &ExternalScoringData{} // Use empty data
	}
	result.ExternalData = *externalData

	// Calculate business impact
	if se.businessContext != nil {
		businessImpact, err := se.businessContext.AssessBusinessImpact(ctx, vuln, asset)
		if err != nil {
			se.logger.Warn("Failed to assess business impact",
				"vulnerability_id", vuln.ID,
				"error", err)
			businessImpact = &BusinessImpactInfo{BusinessScore: 5.0} // Default medium impact
		}
		result.BusinessImpact = *businessImpact
	}

	// Calculate compliance impact
	if se.complianceService != nil {
		complianceImpact, err := se.complianceService.AssessComplianceImpact(ctx, vuln, asset)
		if err != nil {
			se.logger.Warn("Failed to assess compliance impact",
				"vulnerability_id", vuln.ID,
				"error", err)
			complianceImpact = &ComplianceImpactInfo{ComplianceScore: 5.0} // Default medium impact
		}
		result.ComplianceImpact = *complianceImpact
	}

	// Calculate weighted scores
	se.calculateWeightedScores(result, componentScores)

	// Calculate overall score
	result.OverallScore = se.calculateOverallScore(result)

	// Normalize score to configured range
	if se.config.NormalizationEnabled {
		result.OverallScore = se.normalizeScore(result.OverallScore)
	}

	// Determine priority level
	result.Priority = se.determinePriority(result.OverallScore)

	// Generate justification and recommendations
	se.generateJustification(result, vuln, asset)
	se.generateRecommendations(result, vuln, asset)

	result.ProcessingTime = time.Since(startTime)

	// Cache result
	se.cacheResult(cacheKey, result)

	// Update statistics
	se.updateStatistics(result)

	return result.OverallScore, nil
}

// calculateComponentScores calculates individual component scores
func (se *ScoringEngine) calculateComponentScores(ctx context.Context, vuln *Vulnerability, asset *AssetInfo, validationResult *ValidationResult) (*ComponentScores, error) {
	scores := &ComponentScores{}

	// CVSS Score (0-10)
	scores.CVSSScore = vuln.CVSS

	// Asset Criticality (0-10)
	assetCrit, err := se.getAssetCriticalityScore(asset)
	if err != nil {
		se.logger.Warn("Failed to get asset criticality",
			"asset_id", asset.ID,
			"error", err)
		assetCrit = 5.0 // Default medium criticality
	}
	scores.AssetCriticality = assetCrit

	// Network Exposure (0-10)
	scores.NetworkExposure = se.calculateNetworkExposure(vuln, asset)

	// Time Factors (0-10)
	scores.TimeFactors = se.calculateTimeFactors(vuln)

	// Contextual Factors (0-10)
	scores.ContextualFactors = se.calculateContextualFactors(vuln, asset, validationResult)

	// External service dependent scores will be set later
	scores.ExploitAvailability = 5.0 // Default
	scores.PatchAvailability = 5.0   // Default
	scores.ThreatIntelligence = 5.0  // Default
	scores.BusinessImpact = 5.0      // Default
	scores.ComplianceImpact = 5.0    // Default

	return scores, nil
}

// getAssetCriticalityScore gets asset criticality score
func (se *ScoringEngine) getAssetCriticalityScore(asset *AssetInfo) (float64, error) {
	// Check explicit mapping first
	if score, exists := se.assetCriticality[asset.ID]; exists {
		return score, nil
	}

	// Map criticality string to score
	criticalityMap := map[string]float64{
		"critical": 10.0,
		"high":     8.0,
		"medium":   5.0,
		"low":      2.0,
		"minimal":  1.0,
	}

	if score, exists := criticalityMap[strings.ToLower(asset.Criticality)]; exists {
		return score, nil
	}

	// Calculate based on asset type and function
	score := 5.0 // Default medium

	// Adjust based on asset type
	switch strings.ToLower(asset.Type) {
	case "database", "domain_controller", "financial_system":
		score += 3.0
	case "web_server", "application_server", "api_gateway":
		score += 2.0
	case "workstation", "printer", "iot_device":
		score -= 1.0
	}

	// Adjust based on environment
	switch strings.ToLower(asset.Environment) {
	case "production":
		score += 2.0
	case "staging":
		score += 1.0
	case "development", "test":
		score -= 1.0
	}

	// Adjust based on data classification
	switch strings.ToLower(asset.DataClassification) {
	case "confidential", "restricted":
		score += 2.0
	case "internal":
		score += 1.0
	case "public":
		score -= 1.0
	}

	// Ensure score is within bounds
	if score > 10.0 {
		score = 10.0
	}
	if score < 0.0 {
		score = 0.0
	}

	return score, nil
}

// calculateNetworkExposure calculates network exposure score
func (se *ScoringEngine) calculateNetworkExposure(vuln *Vulnerability, asset *AssetInfo) float64 {
	score := 0.0

	// External facing assets get higher score
	if vuln.NetworkContext.IsExternalFacing {
		score += 5.0
	} else {
		score += 2.0
	}

	// Common ports increase exposure
	commonPorts := map[int]float64{
		80:   2.0, // HTTP
		443:  2.0, // HTTPS
		22:   1.5, // SSH
		21:   1.5, // FTP
		23:   1.5, // Telnet
		3389: 1.5, // RDP
		1433: 1.0, // SQL Server
		3306: 1.0, // MySQL
		5432: 1.0, // PostgreSQL
	}

	if portScore, exists := commonPorts[vuln.NetworkContext.Port]; exists {
		score += portScore
	}

	// Network segment considerations
	switch strings.ToLower(asset.NetworkSegment) {
	case "dmz", "public":
		score += 2.0
	case "internal":
		score += 1.0
	case "isolated", "air_gapped":
		score -= 1.0
	}

	// Protocol considerations
	switch strings.ToLower(vuln.NetworkContext.Protocol) {
	case "tcp":
		score += 1.0
	case "udp":
		score += 0.5
	}

	return math.Min(score, 10.0)
}

// calculateTimeFactors calculates time-based scoring factors
func (se *ScoringEngine) calculateTimeFactors(vuln *Vulnerability) float64 {
	now := time.Now()
	daysSinceDiscovery := now.Sub(vuln.DiscoveryTime).Hours() / 24.0

	// Newer vulnerabilities get higher urgency
	if daysSinceDiscovery < 1 {
		return 8.0 // Very recent
	} else if daysSinceDiscovery < 7 {
		return 6.0 // Recent
	} else if daysSinceDiscovery < 30 {
		return 4.0 // Moderate age
	} else if daysSinceDiscovery < 90 {
		return 2.0 // Older
	} else {
		return 1.0 // Very old
	}
}

// calculateContextualFactors calculates contextual scoring factors
func (se *ScoringEngine) calculateContextualFactors(vuln *Vulnerability, asset *AssetInfo, validationResult *ValidationResult) float64 {
	score := 5.0 // Base score

	// Validation confidence affects contextual score
	if validationResult != nil {
		score *= validationResult.ConfidenceScore
	}

	// Scanner reliability
	scannerReliability := map[string]float64{
		"nessus":    1.2,
		"openvas":   1.1,
		"nmap":      1.3,
		"trivy":     1.2,
		"semgrep":   1.1,
		"zap":       1.0,
		"bandit":    1.0,
		"sonarqube": 1.1,
	}

	if reliability, exists := scannerReliability[strings.ToLower(vuln.ScannerID)]; exists {
		score *= reliability
	}

	// Evidence quality
	evidenceQuality := se.assessEvidenceQuality(vuln.Evidence)
	score *= evidenceQuality

	return math.Min(score, 10.0)
}

// assessEvidenceQuality assesses the quality of vulnerability evidence
func (se *ScoringEngine) assessEvidenceQuality(evidence map[string]interface{}) float64 {
	if len(evidence) == 0 {
		return 0.5 // Low quality with no evidence
	}

	qualityScore := 0.5 // Base score
	qualityFactors := []string{
		"request", "response", "payload", "headers", "screenshot",
		"status_code", "content_length", "timing", "hash",
	}

	for _, factor := range qualityFactors {
		if _, exists := evidence[factor]; exists {
			qualityScore += 0.05 // Each factor adds 5%
		}
	}

	return math.Min(qualityScore, 1.0)
}

// gatherExternalData gathers data from external services
func (se *ScoringEngine) gatherExternalData(ctx context.Context, vuln *Vulnerability) (*ExternalScoringData, error) {
	data := &ExternalScoringData{}

	// Gather threat intelligence
	if se.threatIntel != nil && vuln.CVE != "" {
		threatData, err := se.threatIntel.GetThreatIntelligence(ctx, vuln.CVE, vuln)
		if err != nil {
			se.logger.Warn("Failed to get threat intelligence",
				"cve", vuln.CVE,
				"error", err)
		} else {
			data.ThreatIntelligence = threatData
		}
	}

	// Gather exploit information
	if se.exploitDB != nil && vuln.CVE != "" {
		exploitInfo, err := se.exploitDB.GetExploitInfo(ctx, vuln.CVE, vuln)
		if err != nil {
			se.logger.Warn("Failed to get exploit info",
				"cve", vuln.CVE,
				"error", err)
		} else {
			data.ExploitInfo = exploitInfo
		}
	}

	// Gather patch information
	if se.patchDB != nil && vuln.CVE != "" {
		patchInfo, err := se.patchDB.GetPatchInfo(ctx, vuln.CVE, vuln)
		if err != nil {
			se.logger.Warn("Failed to get patch info",
				"cve", vuln.CVE,
				"error", err)
		} else {
			data.PatchInfo = patchInfo
		}
	}

	return data, nil
}

// calculateWeightedScores calculates weighted component scores
func (se *ScoringEngine) calculateWeightedScores(result *ScoringResult, scores *ComponentScores) {
	result.WeightedScores["cvss"] = scores.CVSSScore * se.weights.CVSSScore
	result.WeightedScores["exploit"] = scores.ExploitAvailability * se.weights.ExploitAvailability
	result.WeightedScores["asset"] = scores.AssetCriticality * se.weights.AssetCriticality
	result.WeightedScores["network"] = scores.NetworkExposure * se.weights.NetworkExposure
	result.WeightedScores["patch"] = scores.PatchAvailability * se.weights.PatchAvailability
	result.WeightedScores["threat"] = scores.ThreatIntelligence * se.weights.ThreatIntelligence
	result.WeightedScores["business"] = scores.BusinessImpact * se.weights.BusinessImpact
	result.WeightedScores["compliance"] = scores.ComplianceImpact * se.weights.ComplianceImpact

	// Update component scores with external data
	if result.ExternalData.ExploitInfo != nil {
		scores.ExploitAvailability = result.ExternalData.ExploitInfo.ExploitScore
		result.WeightedScores["exploit"] = scores.ExploitAvailability * se.weights.ExploitAvailability
	}

	if result.ExternalData.PatchInfo != nil {
		scores.PatchAvailability = result.ExternalData.PatchInfo.PatchScore
		result.WeightedScores["patch"] = scores.PatchAvailability * se.weights.PatchAvailability
	}

	if result.ExternalData.ThreatIntelligence != nil {
		scores.ThreatIntelligence = result.ExternalData.ThreatIntelligence.ThreatScore
		result.WeightedScores["threat"] = scores.ThreatIntelligence * se.weights.ThreatIntelligence
	}

	if result.BusinessImpact.BusinessScore > 0 {
		scores.BusinessImpact = result.BusinessImpact.BusinessScore
		result.WeightedScores["business"] = scores.BusinessImpact * se.weights.BusinessImpact
	}

	if result.ComplianceImpact.ComplianceScore > 0 {
		scores.ComplianceImpact = result.ComplianceImpact.ComplianceScore
		result.WeightedScores["compliance"] = scores.ComplianceImpact * se.weights.ComplianceImpact
	}
}

// calculateOverallScore calculates the final overall score
func (se *ScoringEngine) calculateOverallScore(result *ScoringResult) float64 {
	totalScore := 0.0
	totalWeight := 0.0

	weightMap := map[string]float64{
		"cvss":       se.weights.CVSSScore,
		"exploit":    se.weights.ExploitAvailability,
		"asset":      se.weights.AssetCriticality,
		"network":    se.weights.NetworkExposure,
		"patch":      se.weights.PatchAvailability,
		"threat":     se.weights.ThreatIntelligence,
		"business":   se.weights.BusinessImpact,
		"compliance": se.weights.ComplianceImpact,
	}

	for component, score := range result.WeightedScores {
		if weight, exists := weightMap[component]; exists {
			totalScore += score
			totalWeight += weight
		}
	}

	if totalWeight == 0 {
		return 5.0 // Default medium score
	}

	return totalScore / totalWeight
}

// normalizeScore normalizes score to configured range
func (se *ScoringEngine) normalizeScore(score float64) float64 {
	// Ensure score is within min/max bounds
	if score > se.config.MaxScore {
		score = se.config.MaxScore
	}
	if score < se.config.MinScore {
		score = se.config.MinScore
	}

	// Normalize to 0-10 range if different range is configured
	if se.config.MaxScore != 10.0 || se.config.MinScore != 0.0 {
		normalizedScore := (score - se.config.MinScore) / (se.config.MaxScore - se.config.MinScore) * 10.0
		return normalizedScore
	}

	return score
}

// determinePriority determines priority level based on score
func (se *ScoringEngine) determinePriority(score float64) string {
	if score >= 8.0 {
		return "critical"
	} else if score >= 6.0 {
		return "high"
	} else if score >= 4.0 {
		return "medium"
	} else if score >= 2.0 {
		return "low"
	} else {
		return "informational"
	}
}

// generateJustification generates justification for the score
func (se *ScoringEngine) generateJustification(result *ScoringResult, vuln *Vulnerability, asset *AssetInfo) {
	justifications := make([]string, 0)

	// CVSS justification
	if result.ComponentScores.CVSSScore >= 8.0 {
		justifications = append(justifications, fmt.Sprintf("High CVSS score of %.1f indicates severe vulnerability", result.ComponentScores.CVSSScore))
	} else if result.ComponentScores.CVSSScore >= 6.0 {
		justifications = append(justifications, fmt.Sprintf("Moderate CVSS score of %.1f indicates significant vulnerability", result.ComponentScores.CVSSScore))
	}

	// Asset criticality justification
	if result.ComponentScores.AssetCriticality >= 8.0 {
		justifications = append(justifications, fmt.Sprintf("Asset '%s' is business-critical", asset.Name))
	} else if result.ComponentScores.AssetCriticality >= 6.0 {
		justifications = append(justifications, fmt.Sprintf("Asset '%s' has high business importance", asset.Name))
	}

	// Network exposure justification
	if result.ComponentScores.NetworkExposure >= 7.0 {
		justifications = append(justifications, "High network exposure increases attack surface")
	}

	// Exploit availability justification
	if result.ExternalData.ExploitInfo != nil && result.ExternalData.ExploitInfo.HasPublicExploit {
		justifications = append(justifications, "Public exploits available, increasing risk")
	}

	// Patch availability justification
	if result.ExternalData.PatchInfo != nil && !result.ExternalData.PatchInfo.PatchAvailable {
		justifications = append(justifications, "No patch available, remediation options limited")
	}

	// Compliance justification
	if len(result.ComplianceImpact.AffectedStandards) > 0 {
		justifications = append(justifications, fmt.Sprintf("Affects compliance standards: %s", strings.Join(result.ComplianceImpact.AffectedStandards, ", ")))
	}

	result.Justification = justifications
}

// generateRecommendations generates remediation recommendations
func (se *ScoringEngine) generateRecommendations(result *ScoringResult, vuln *Vulnerability, asset *AssetInfo) {
	recommendations := make([]string, 0)

	// Patch recommendations
	if result.ExternalData.PatchInfo != nil {
		if result.ExternalData.PatchInfo.PatchAvailable {
			recommendations = append(recommendations, "Apply available security patch immediately")
			if result.ExternalData.PatchInfo.RequiresReboot {
				recommendations = append(recommendations, "Schedule maintenance window for required reboot")
			}
		} else if result.ExternalData.PatchInfo.WorkaroundAvailable {
			recommendations = append(recommendations, "Implement available workarounds until patch is released")
		}
	}

	// Network security recommendations
	if result.ComponentScores.NetworkExposure >= 7.0 {
		recommendations = append(recommendations, "Implement network segmentation to reduce exposure")
		if vuln.NetworkContext.IsExternalFacing {
			recommendations = append(recommendations, "Consider removing from external access or implementing additional access controls")
		}
	}

	// Monitoring recommendations
	if result.OverallScore >= 7.0 {
		recommendations = append(recommendations, "Implement enhanced monitoring for this asset")
		recommendations = append(recommendations, "Set up alerts for suspicious activity")
	}

	// Compliance recommendations
	if len(result.ComplianceImpact.AffectedStandards) > 0 {
		recommendations = append(recommendations, "Document remediation actions for compliance audit trail")
		if result.ComplianceImpact.ReportingRequired {
			recommendations = append(recommendations, "Report to relevant compliance authorities as required")
		}
	}

	// Business continuity recommendations
	if result.BusinessImpact.BusinessScore >= 8.0 {
		recommendations = append(recommendations, "Activate incident response procedures")
		recommendations = append(recommendations, "Assess business continuity plans")
	}

	result.Recommendations = recommendations
}

// Cache management methods
func (se *ScoringEngine) generateCacheKey(vulnID string, validationResult *ValidationResult) string {
	if validationResult != nil {
		return fmt.Sprintf("%s_%f_%d", vulnID, validationResult.ConfidenceScore, validationResult.Timestamp.Unix())
	}
	return vulnID
}

func (se *ScoringEngine) getCachedResult(key string) *ScoringResult {
	se.cache.mutex.RLock()
	defer se.cache.mutex.RUnlock()

	if !se.cache.enabled {
		return nil
	}

	result, exists := se.cache.cache[key]
	if !exists {
		return nil
	}

	// Check TTL
	if ttl, exists := se.cache.ttl[key]; exists {
		if time.Now().After(ttl) {
			delete(se.cache.cache, key)
			delete(se.cache.ttl, key)
			return nil
		}
	}

	return result
}

func (se *ScoringEngine) cacheResult(key string, result *ScoringResult) {
	se.cache.mutex.Lock()
	defer se.cache.mutex.Unlock()

	if !se.cache.enabled {
		return
	}

	// Check cache size limit
	if len(se.cache.cache) >= se.cache.maxSize {
		se.evictOldestCacheEntries(se.cache.maxSize / 4)
	}

	se.cache.cache[key] = result
	se.cache.ttl[key] = time.Now().Add(time.Hour) // 1 hour TTL
}

func (se *ScoringEngine) evictOldestCacheEntries(count int) {
	type cacheEntry struct {
		key string
		ttl time.Time
	}

	entries := make([]cacheEntry, 0, len(se.cache.ttl))
	for key, ttl := range se.cache.ttl {
		entries = append(entries, cacheEntry{key: key, ttl: ttl})
	}

	sort.Slice(entries, func(i, j int) bool {
		return entries[i].ttl.Before(entries[j].ttl)
	})

	for i := 0; i < count && i < len(entries); i++ {
		key := entries[i].key
		delete(se.cache.cache, key)
		delete(se.cache.ttl, key)
	}
}

func (se *ScoringEngine) updateCacheHitStats(hit bool) {
	se.cache.mutex.Lock()
	defer se.cache.mutex.Unlock()

	if hit {
		se.cache.hitCount++
	} else {
		se.cache.missCount++
	}
}

// updateStatistics updates scoring statistics
func (se *ScoringEngine) updateStatistics(result *ScoringResult) {
	se.mutex.Lock()
	defer se.mutex.Unlock()

	se.statistics.TotalScored++

	// Update average score
	totalScore := se.statistics.AverageScore * float64(se.statistics.TotalScored-1)
	totalScore += result.OverallScore
	se.statistics.AverageScore = totalScore / float64(se.statistics.TotalScored)

	// Update priority counts
	switch result.Priority {
	case "critical", "high":
		se.statistics.HighPriorityCount++
	case "medium":
		se.statistics.MediumPriorityCount++
	case "low", "informational":
		se.statistics.LowPriorityCount++
	}

	// Update average scoring time
	totalTime := se.statistics.AverageScoringTime * float64(se.statistics.TotalScored-1)
	totalTime += result.ProcessingTime.Seconds()
	se.statistics.AverageScoringTime = totalTime / float64(se.statistics.TotalScored)

	// Update cache hit rate
	total := se.cache.hitCount + se.cache.missCount
	if total > 0 {
		se.statistics.CacheHitRate = float64(se.cache.hitCount) / float64(total)
	}

	se.statistics.LastUpdate = time.Now()
}

// GetStatistics returns current scoring statistics
func (se *ScoringEngine) GetStatistics() ScoringStatistics {
	se.mutex.RLock()
	defer se.mutex.RUnlock()
	return se.statistics
}

// getAssetInfo retrieves asset information
func (se *ScoringEngine) getAssetInfo(ctx context.Context, assetID string) (*AssetInfo, error) {
	// This would typically query an asset repository
	// For now, return a placeholder
	return &AssetInfo{
		ID:          assetID,
		Name:        fmt.Sprintf("Asset_%s", assetID),
		Type:        "server",
		Criticality: "medium",
		Environment: "production",
	}, nil
}

// SetExternalServices sets external service dependencies
func (se *ScoringEngine) SetExternalServices(threatIntel ThreatIntelligenceService, exploitDB ExploitDatabaseService, patchDB PatchDatabaseService, businessContext BusinessContextService, compliance ComplianceService) {
	se.threatIntel = threatIntel
	se.exploitDB = exploitDB
	se.patchDB = patchDB
	se.businessContext = businessContext
	se.complianceService = compliance
}

// Close gracefully shuts down the scoring engine
func (se *ScoringEngine) Close() error {
	se.logger.Info("Shutting down scoring engine")

	// Clear cache
	se.cache.mutex.Lock()
	se.cache.cache = make(map[string]*ScoringResult)
	se.cache.ttl = make(map[string]time.Time)
	se.cache.mutex.Unlock()

	return nil
}
