package risk

import (
	"context"
	"fmt"
	"log/slog"
	"math"
	"strings"
	"sync"
	"time"
)

// BusinessImpactAssessor evaluates the business impact of vulnerabilities
type BusinessImpactAssessor struct {
	config              BusinessImpactConfig
	logger              *slog.Logger
	assetRepository     AssetRepository
	businessProcessMap  BusinessProcessMap
	dependencyAnalyzer  *DependencyAnalyzer
	financialCalculator *FinancialImpactCalculator
	reputationAnalyzer  *ReputationImpactAnalyzer
	operationalAnalyzer *OperationalImpactAnalyzer
	statistics          BusinessImpactStatistics
	mutex               sync.RWMutex
}

// BusinessImpactConfig defines configuration for business impact assessment
type BusinessImpactConfig struct {
	OrganizationProfile    OrganizationProfile     `json:"organization_profile"`
	BusinessObjectives     []BusinessObjective     `json:"business_objectives"`
	RiskTolerance         RiskToleranceProfile    `json:"risk_tolerance"`
	
	// Impact calculation settings
	EnableFinancialImpact  bool                   `json:"enable_financial_impact"`
	EnableReputationImpact bool                   `json:"enable_reputation_impact"`
	EnableOperationalImpact bool                  `json:"enable_operational_impact"`
	EnableCustomerImpact   bool                   `json:"enable_customer_impact"`
	EnableCompetitiveImpact bool                  `json:"enable_competitive_impact"`
	
	// Business context
	RevenueStreams         []RevenueStream        `json:"revenue_streams"`
	CriticalProcesses      []BusinessProcess      `json:"critical_processes"`
	CustomerSegments       []CustomerSegment      `json:"customer_segments"`
	CompetitiveFactors     []CompetitiveFactor    `json:"competitive_factors"`
	
	// Financial parameters
	HourlyRevenue          float64                `json:"hourly_revenue"`
	CustomerAcquisitionCost float64               `json:"customer_acquisition_cost"`
	CustomerLifetimeValue  float64                `json:"customer_lifetime_value"`
	AverageTransactionValue float64               `json:"average_transaction_value"`
	BrandValue             float64                `json:"brand_value"`
	
	// Time-based factors
	PeakHours              []TimeWindow           `json:"peak_hours"`
	CriticalPeriods        []CriticalPeriod       `json:"critical_periods"`
	BusinessSeasonality    []SeasonalityFactor    `json:"business_seasonality"`
	
	// iSECTECH specific
	IndustryBenchmarks     map[string]float64     `json:"industry_benchmarks"`
	CustomImpactModels     []CustomImpactModel    `json:"custom_impact_models"`
	RegulatoryPenalties    map[string]float64     `json:"regulatory_penalties"`
	InsuranceCoverage      InsuranceCoverage      `json:"insurance_coverage"`
}

// BusinessImpactResult contains business impact assessment results
type BusinessImpactResult struct {
	VulnerabilityID        string                    `json:"vulnerability_id"`
	ImpactScore           float64                   `json:"impact_score"`
	ImpactLevel           string                    `json:"impact_level"`
	Confidence            float64                   `json:"confidence"`
	
	// Impact categories
	FinancialImpact       *FinancialImpactDetails   `json:"financial_impact,omitempty"`
	ReputationImpact      *ReputationImpactDetails  `json:"reputation_impact,omitempty"`
	OperationalImpact     *OperationalImpactDetails `json:"operational_impact,omitempty"`
	CustomerImpact        *CustomerImpactDetails    `json:"customer_impact,omitempty"`
	CompetitiveImpact     *CompetitiveImpactDetails `json:"competitive_impact,omitempty"`
	RegulatoryImpact      *RegulatoryImpactDetails  `json:"regulatory_impact,omitempty"`
	
	// Business context
	AffectedBusinessProcesses []string              `json:"affected_business_processes"`
	AffectedRevenueStreams    []string              `json:"affected_revenue_streams"`
	AffectedCustomerSegments  []string              `json:"affected_customer_segments"`
	EstimatedDowntimeHours    float64               `json:"estimated_downtime_hours"`
	RecoveryTimeEstimate      time.Duration         `json:"recovery_time_estimate"`
	
	// Risk factors
	BusinessRiskFactors   []BusinessRiskFactor      `json:"business_risk_factors"`
	MitigatingFactors     []BusinessMitigatingFactor `json:"mitigating_factors"`
	
	// Recommendations
	BusinessRecommendations []BusinessRecommendation `json:"business_recommendations"`
	PriorityJustification   []string                 `json:"priority_justification"`
	ProcessingTime          time.Duration            `json:"processing_time"`
	Timestamp               time.Time                `json:"timestamp"`
}

// Financial impact details
type FinancialImpactDetails struct {
	DirectCosts           float64                `json:"direct_costs"`
	IndirectCosts         float64                `json:"indirect_costs"`
	OpportunityCosts      float64                `json:"opportunity_costs"`
	RecoveryCosts         float64                `json:"recovery_costs"`
	RegulatoryFines       float64                `json:"regulatory_fines"`
	LegalCosts           float64                `json:"legal_costs"`
	ReputationCosts      float64                `json:"reputation_costs"`
	TotalEstimatedCost   float64                `json:"total_estimated_cost"`
	CostRange            CostRange              `json:"cost_range"`
	CostBreakdown        map[string]float64     `json:"cost_breakdown"`
	ImpactDuration       time.Duration          `json:"impact_duration"`
	ConfidenceLevel      float64                `json:"confidence_level"`
}

// Reputation impact details
type ReputationImpactDetails struct {
	BrandDamageScore      float64                `json:"brand_damage_score"`
	CustomerTrustImpact   float64                `json:"customer_trust_impact"`
	MarketPerceptionImpact float64               `json:"market_perception_impact"`
	MediaCoverageRisk     float64                `json:"media_coverage_risk"`
	SocialMediaRisk       float64                `json:"social_media_risk"`
	RecoveryTimeEstimate  time.Duration          `json:"recovery_time_estimate"`
	ReputationMetrics     map[string]float64     `json:"reputation_metrics"`
	StakeholderImpact     map[string]float64     `json:"stakeholder_impact"`
	ConfidenceLevel       float64                `json:"confidence_level"`
}

// Operational impact details
type OperationalImpactDetails struct {
	ProcessDisruption     float64                `json:"process_disruption"`
	ProductivityLoss      float64                `json:"productivity_loss"`
	ServiceAvailability   float64                `json:"service_availability"`
	DataIntegrityRisk     float64                `json:"data_integrity_risk"`
	SystemPerformanceImpact float64              `json:"system_performance_impact"`
	UserExperienceImpact  float64                `json:"user_experience_impact"`
	RecoveryComplexity    float64                `json:"recovery_complexity"`
	BusinessContinuityRisk float64               `json:"business_continuity_risk"`
	OperationalMetrics    map[string]float64     `json:"operational_metrics"`
	AffectedSystems       []string               `json:"affected_systems"`
	ConfidenceLevel       float64                `json:"confidence_level"`
}

// Customer impact details
type CustomerImpactDetails struct {
	CustomerExperienceImpact float64              `json:"customer_experience_impact"`
	ServiceLevelImpact       float64              `json:"service_level_impact"`
	CustomerRetentionRisk    float64              `json:"customer_retention_risk"`
	CustomerAcquisitionImpact float64             `json:"customer_acquisition_impact"`
	CustomerSatisfactionImpact float64            `json:"customer_satisfaction_impact"`
	EstimatedCustomerLoss    int                 `json:"estimated_customer_loss"`
	RevenueImpactPerCustomer float64              `json:"revenue_impact_per_customer"`
	AffectedCustomerSegments []CustomerSegment    `json:"affected_customer_segments"`
	CustomerCommunicationNeeds []string           `json:"customer_communication_needs"`
	ConfidenceLevel          float64              `json:"confidence_level"`
}

// Competitive impact details
type CompetitiveImpactDetails struct {
	CompetitiveAdvantageRisk float64              `json:"competitive_advantage_risk"`
	MarketShareRisk          float64              `json:"market_share_risk"`
	InnovationImpact         float64              `json:"innovation_impact"`
	PartnershipRisk          float64              `json:"partnership_risk"`
	IntellectualPropertyRisk float64              `json:"intellectual_property_risk"`
	TimeToMarketImpact       float64              `json:"time_to_market_impact"`
	CompetitorAdvantage      []string             `json:"competitor_advantage"`
	StrategicImpact          map[string]float64   `json:"strategic_impact"`
	ConfidenceLevel          float64              `json:"confidence_level"`
}

// Regulatory impact details
type RegulatoryImpactDetails struct {
	ComplianceViolationRisk  float64              `json:"compliance_violation_risk"`
	RegulatoryPenaltyRisk    float64              `json:"regulatory_penalty_risk"`
	AuditImpact             float64              `json:"audit_impact"`
	LicenseRisk             float64              `json:"license_risk"`
	ReportingObligations    []string             `json:"reporting_obligations"`
	AffectedRegulations     []string             `json:"affected_regulations"`
	ComplianceGaps          []string             `json:"compliance_gaps"`
	RemediationRequirements []string             `json:"remediation_requirements"`
	ConfidenceLevel         float64              `json:"confidence_level"`
}

// Supporting data structures
type RevenueStream struct {
	ID                  string    `json:"id"`
	Name                string    `json:"name"`
	Type                string    `json:"type"`
	AnnualRevenue       float64   `json:"annual_revenue"`
	Criticality         string    `json:"criticality"`
	Dependencies        []string  `json:"dependencies"`
	PeakPeriods         []string  `json:"peak_periods"`
	VulnerabilityImpact float64   `json:"vulnerability_impact"`
}

type BusinessProcess struct {
	ID                  string                 `json:"id"`
	Name                string                 `json:"name"`
	Criticality         string                 `json:"criticality"`
	Dependencies        []string               `json:"dependencies"`
	BusinessValue       float64                `json:"business_value"`
	DowntimeCost        float64                `json:"downtime_cost"`
	RecoveryTime        time.Duration          `json:"recovery_time"`
	AffectedStakeholders []string              `json:"affected_stakeholders"`
	SLARequirements     []SLARequirement       `json:"sla_requirements"`
	Metadata            map[string]interface{} `json:"metadata"`
}

type CustomerSegment struct {
	ID                    string    `json:"id"`
	Name                  string    `json:"name"`
	Size                  int       `json:"size"`
	Revenue               float64   `json:"revenue"`
	Profitability         float64   `json:"profitability"`
	Criticality           string    `json:"criticality"`
	SensitivityToDowntime float64   `json:"sensitivity_to_downtime"`
	ChurnRisk             float64   `json:"churn_risk"`
	CommunicationChannels []string  `json:"communication_channels"`
}

type CompetitiveFactor struct {
	Factor      string  `json:"factor"`
	Importance  float64 `json:"importance"`
	CurrentState float64 `json:"current_state"`
	VulnerabilityImpact float64 `json:"vulnerability_impact"`
}

type TimeWindow struct {
	StartTime string `json:"start_time"`
	EndTime   string `json:"end_time"`
	TimeZone  string `json:"timezone"`
	Multiplier float64 `json:"multiplier"`
}

type CriticalPeriod struct {
	Name        string    `json:"name"`
	StartDate   time.Time `json:"start_date"`
	EndDate     time.Time `json:"end_date"`
	Importance  float64   `json:"importance"`
	Description string    `json:"description"`
}

type SeasonalityFactor struct {
	Period      string  `json:"period"`
	Multiplier  float64 `json:"multiplier"`
	Description string  `json:"description"`
}

type CustomImpactModel struct {
	ID          string                 `json:"id"`
	Name        string                 `json:"name"`
	Conditions  []BusinessCondition    `json:"conditions"`
	Formula     string                 `json:"formula"`
	Weight      float64                `json:"weight"`
	Enabled     bool                   `json:"enabled"`
	Metadata    map[string]interface{} `json:"metadata"`
}

type BusinessCondition struct {
	Field     string      `json:"field"`
	Operator  string      `json:"operator"`
	Value     interface{} `json:"value"`
	LogicalOp string      `json:"logical_op,omitempty"`
}

type InsuranceCoverage struct {
	CyberInsurance       bool    `json:"cyber_insurance"`
	CoverageAmount       float64 `json:"coverage_amount"`
	Deductible          float64 `json:"deductible"`
	BusinessInterruption bool    `json:"business_interruption"`
	DataBreach          bool    `json:"data_breach"`
	CyberExtortion      bool    `json:"cyber_extortion"`
}

type CostRange struct {
	Minimum     float64 `json:"minimum"`
	Maximum     float64 `json:"maximum"`
	MostLikely  float64 `json:"most_likely"`
	Confidence  float64 `json:"confidence"`
}

type SLARequirement struct {
	Metric       string        `json:"metric"`
	Threshold    float64       `json:"threshold"`
	Penalty      float64       `json:"penalty"`
	Measurement  string        `json:"measurement"`
	Criticality  string        `json:"criticality"`
}

type BusinessRiskFactor struct {
	Category    string                 `json:"category"`
	Description string                 `json:"description"`
	Impact      float64                `json:"impact"`
	Likelihood  float64                `json:"likelihood"`
	Confidence  float64                `json:"confidence"`
	Source      string                 `json:"source"`
	Metadata    map[string]interface{} `json:"metadata"`
}

type BusinessMitigatingFactor struct {
	Type           string                 `json:"type"`
	Description    string                 `json:"description"`
	Effectiveness  float64                `json:"effectiveness"`
	Coverage       float64                `json:"coverage"`
	Confidence     float64                `json:"confidence"`
	Implementation string                 `json:"implementation"`
	Metadata       map[string]interface{} `json:"metadata"`
}

type BusinessRecommendation struct {
	Type            string                 `json:"type"`
	Priority        string                 `json:"priority"`
	Action          string                 `json:"action"`
	BusinessValue   float64                `json:"business_value"`
	CostBenefit     float64                `json:"cost_benefit"`
	Timeline        string                 `json:"timeline"`
	Stakeholders    []string               `json:"stakeholders"`
	Dependencies    []string               `json:"dependencies"`
	RiskMitigation  float64                `json:"risk_mitigation"`
	Implementation  ImplementationDetails  `json:"implementation"`
	Metadata        map[string]interface{} `json:"metadata"`
}

type ImplementationDetails struct {
	Steps           []string `json:"steps"`
	Resources       []string `json:"resources"`
	Timeline        string   `json:"timeline"`
	Dependencies    []string `json:"dependencies"`
	SuccessCriteria []string `json:"success_criteria"`
	RiskFactors     []string `json:"risk_factors"`
}

type BusinessImpactStatistics struct {
	TotalAssessments         int64                    `json:"total_assessments"`
	AverageImpactScore       float64                  `json:"average_impact_score"`
	AverageFinancialImpact   float64                  `json:"average_financial_impact"`
	ImpactLevelDistribution  map[string]int64         `json:"impact_level_distribution"`
	ProcessingTime           float64                  `json:"processing_time"`
	ComponentPerformance     map[string]ComponentStat `json:"component_performance"`
	LastUpdate               time.Time                `json:"last_update"`
}

// Repository interfaces
type AssetRepository interface {
	GetAsset(ctx context.Context, assetID string) (*Asset, error)
	GetAssetDependencies(ctx context.Context, assetID string) ([]string, error)
	GetAssetBusinessValue(ctx context.Context, assetID string) (float64, error)
}

type BusinessProcessMap interface {
	GetProcessesByAsset(ctx context.Context, assetID string) ([]BusinessProcess, error)
	GetProcessDependencies(ctx context.Context, processID string) ([]string, error)
	GetProcessImpact(ctx context.Context, processID string, downtime time.Duration) (float64, error)
}

// Asset represents a business asset
type Asset struct {
	ID                  string                 `json:"id"`
	Name                string                 `json:"name"`
	Type                string                 `json:"type"`
	BusinessValue       float64                `json:"business_value"`
	Criticality         string                 `json:"criticality"`
	Owner               string                 `json:"owner"`
	Dependencies        []string               `json:"dependencies"`
	BusinessProcesses   []string               `json:"business_processes"`
	CustomerImpact      float64                `json:"customer_impact"`
	RevenueImpact       float64                `json:"revenue_impact"`
	ComplianceScope     []string               `json:"compliance_scope"`
	Metadata            map[string]interface{} `json:"metadata"`
}

// NewBusinessImpactAssessor creates a new business impact assessor
func NewBusinessImpactAssessor(config BusinessImpactConfig, logger *slog.Logger) (*BusinessImpactAssessor, error) {
	if logger == nil {
		logger = slog.Default()
	}

	assessor := &BusinessImpactAssessor{
		config: config,
		logger: logger,
		statistics: BusinessImpactStatistics{
			ImpactLevelDistribution: make(map[string]int64),
			ComponentPerformance:    make(map[string]ComponentStat),
			LastUpdate:              time.Now(),
		},
	}

	// Initialize sub-components
	if err := assessor.initializeComponents(); err != nil {
		return nil, fmt.Errorf("failed to initialize components: %w", err)
	}

	return assessor, nil
}

// AssessBusinessImpact performs comprehensive business impact assessment
func (bia *BusinessImpactAssessor) AssessBusinessImpact(ctx context.Context, vuln *Vulnerability, assessmentCtx *AssessmentContext) (*BusinessImpactResult, error) {
	startTime := time.Now()

	result := &BusinessImpactResult{
		VulnerabilityID:           vuln.ID,
		AffectedBusinessProcesses: make([]string, 0),
		AffectedRevenueStreams:    make([]string, 0),
		AffectedCustomerSegments:  make([]string, 0),
		BusinessRiskFactors:       make([]BusinessRiskFactor, 0),
		MitigatingFactors:         make([]BusinessMitigatingFactor, 0),
		BusinessRecommendations:   make([]BusinessRecommendation, 0),
		PriorityJustification:     make([]string, 0),
		Timestamp:                 time.Now(),
	}

	// Get asset information
	asset, err := bia.getAssetInformation(ctx, vuln.AssetID)
	if err != nil {
		bia.logger.Warn("Failed to get asset information",
			"asset_id", vuln.AssetID,
			"error", err)
		// Use default asset data
		asset = &Asset{
			ID:            vuln.AssetID,
			BusinessValue: 5.0,
			Criticality:   "medium",
		}
	}

	// Assess financial impact
	if bia.config.EnableFinancialImpact {
		financialImpact, err := bia.assessFinancialImpact(ctx, vuln, asset, assessmentCtx)
		if err != nil {
			bia.logger.Warn("Financial impact assessment failed", "error", err)
		} else {
			result.FinancialImpact = financialImpact
		}
	}

	// Assess reputation impact
	if bia.config.EnableReputationImpact {
		reputationImpact, err := bia.assessReputationImpact(ctx, vuln, asset, assessmentCtx)
		if err != nil {
			bia.logger.Warn("Reputation impact assessment failed", "error", err)
		} else {
			result.ReputationImpact = reputationImpact
		}
	}

	// Assess operational impact
	if bia.config.EnableOperationalImpact {
		operationalImpact, err := bia.assessOperationalImpact(ctx, vuln, asset, assessmentCtx)
		if err != nil {
			bia.logger.Warn("Operational impact assessment failed", "error", err)
		} else {
			result.OperationalImpact = operationalImpact
		}
	}

	// Assess customer impact
	if bia.config.EnableCustomerImpact {
		customerImpact, err := bia.assessCustomerImpact(ctx, vuln, asset, assessmentCtx)
		if err != nil {
			bia.logger.Warn("Customer impact assessment failed", "error", err)
		} else {
			result.CustomerImpact = customerImpact
		}
	}

	// Assess competitive impact
	if bia.config.EnableCompetitiveImpact {
		competitiveImpact, err := bia.assessCompetitiveImpact(ctx, vuln, asset, assessmentCtx)
		if err != nil {
			bia.logger.Warn("Competitive impact assessment failed", "error", err)
		} else {
			result.CompetitiveImpact = competitiveImpact
		}
	}

	// Assess regulatory impact
	regulatoryImpact, err := bia.assessRegulatoryImpact(ctx, vuln, asset, assessmentCtx)
	if err != nil {
		bia.logger.Warn("Regulatory impact assessment failed", "error", err)
	} else {
		result.RegulatoryImpact = regulatoryImpact
	}

	// Calculate overall business impact score
	result.ImpactScore = bia.calculateOverallImpactScore(result, vuln, asset)
	result.ImpactLevel = bia.determineImpactLevel(result.ImpactScore)
	result.Confidence = bia.calculateConfidence(result)

	// Generate business risk factors
	bia.generateBusinessRiskFactors(result, vuln, asset, assessmentCtx)

	// Generate mitigating factors
	bia.generateMitigatingFactors(result, vuln, asset, assessmentCtx)

	// Generate business recommendations
	bia.generateBusinessRecommendations(result, vuln, asset)

	// Generate priority justification
	bia.generatePriorityJustification(result, vuln, asset)

	result.ProcessingTime = time.Since(startTime)

	// Update statistics
	bia.updateStatistics(result)

	bia.logger.Info("Business impact assessment completed",
		"vulnerability_id", vuln.ID,
		"impact_score", result.ImpactScore,
		"impact_level", result.ImpactLevel,
		"processing_time", result.ProcessingTime)

	return result, nil
}

// initializeComponents initializes sub-components
func (bia *BusinessImpactAssessor) initializeComponents() error {
	// Initialize dependency analyzer
	bia.dependencyAnalyzer = &DependencyAnalyzer{
		logger: bia.logger,
	}

	// Initialize financial calculator
	bia.financialCalculator = &FinancialImpactCalculator{
		config: bia.config,
		logger: bia.logger,
	}

	// Initialize reputation analyzer
	bia.reputationAnalyzer = &ReputationImpactAnalyzer{
		config: bia.config,
		logger: bia.logger,
	}

	// Initialize operational analyzer
	bia.operationalAnalyzer = &OperationalImpactAnalyzer{
		config: bia.config,
		logger: bia.logger,
	}

	return nil
}

// getAssetInformation retrieves comprehensive asset information
func (bia *BusinessImpactAssessor) getAssetInformation(ctx context.Context, assetID string) (*Asset, error) {
	if bia.assetRepository != nil {
		return bia.assetRepository.GetAsset(ctx, assetID)
	}

	// Default asset information based on asset ID patterns
	asset := &Asset{
		ID:   assetID,
		Name: fmt.Sprintf("Asset_%s", assetID),
		Type: bia.inferAssetType(assetID),
	}

	// Set business value based on asset type and naming patterns
	asset.BusinessValue = bia.inferBusinessValue(assetID, asset.Type)
	asset.Criticality = bia.inferCriticality(asset.BusinessValue)

	return asset, nil
}

// inferAssetType infers asset type from asset ID
func (bia *BusinessImpactAssessor) inferAssetType(assetID string) string {
	lowerID := strings.ToLower(assetID)
	
	if strings.Contains(lowerID, "db") || strings.Contains(lowerID, "database") {
		return "database"
	}
	if strings.Contains(lowerID, "web") || strings.Contains(lowerID, "www") {
		return "web_server"
	}
	if strings.Contains(lowerID, "api") || strings.Contains(lowerID, "service") {
		return "api_server"
	}
	if strings.Contains(lowerID, "load") || strings.Contains(lowerID, "lb") {
		return "load_balancer"
	}
	if strings.Contains(lowerID, "cache") || strings.Contains(lowerID, "redis") {
		return "cache_server"
	}
	if strings.Contains(lowerID, "auth") || strings.Contains(lowerID, "ldap") {
		return "authentication_server"
	}
	if strings.Contains(lowerID, "file") || strings.Contains(lowerID, "storage") {
		return "file_server"
	}
	if strings.Contains(lowerID, "mail") || strings.Contains(lowerID, "email") {
		return "mail_server"
	}
	if strings.Contains(lowerID, "dns") {
		return "dns_server"
	}
	
	return "server"
}

// inferBusinessValue infers business value from asset characteristics
func (bia *BusinessImpactAssessor) inferBusinessValue(assetID, assetType string) float64 {
	baseValue := 5.0 // Default medium value
	
	// Adjust based on asset type
	switch assetType {
	case "database":
		baseValue = 8.5
	case "authentication_server":
		baseValue = 8.0
	case "api_server":
		baseValue = 7.5
	case "web_server":
		baseValue = 7.0
	case "load_balancer":
		baseValue = 6.5
	case "mail_server":
		baseValue = 6.0
	case "dns_server":
		baseValue = 6.0
	case "cache_server":
		baseValue = 5.5
	case "file_server":
		baseValue = 5.0
	default:
		baseValue = 4.0
	}
	
	// Adjust based on naming patterns indicating importance
	lowerID := strings.ToLower(assetID)
	if strings.Contains(lowerID, "prod") || strings.Contains(lowerID, "production") {
		baseValue += 1.5
	}
	if strings.Contains(lowerID, "critical") || strings.Contains(lowerID, "core") {
		baseValue += 2.0
	}
	if strings.Contains(lowerID, "main") || strings.Contains(lowerID, "primary") {
		baseValue += 1.0
	}
	if strings.Contains(lowerID, "backup") || strings.Contains(lowerID, "secondary") {
		baseValue -= 1.0
	}
	if strings.Contains(lowerID, "test") || strings.Contains(lowerID, "dev") {
		baseValue -= 2.0
	}
	
	// Ensure value is within bounds
	if baseValue > 10.0 {
		baseValue = 10.0
	}
	if baseValue < 1.0 {
		baseValue = 1.0
	}
	
	return baseValue
}

// inferCriticality infers asset criticality from business value
func (bia *BusinessImpactAssessor) inferCriticality(businessValue float64) string {
	if businessValue >= 8.0 {
		return "critical"
	} else if businessValue >= 6.0 {
		return "high"
	} else if businessValue >= 4.0 {
		return "medium"
	} else {
		return "low"
	}
}

// assessFinancialImpact assesses financial impact of vulnerability
func (bia *BusinessImpactAssessor) assessFinancialImpact(ctx context.Context, vuln *Vulnerability, asset *Asset, assessmentCtx *AssessmentContext) (*FinancialImpactDetails, error) {
	return bia.financialCalculator.CalculateFinancialImpact(ctx, vuln, asset, assessmentCtx)
}

// assessReputationImpact assesses reputation impact of vulnerability
func (bia *BusinessImpactAssessor) assessReputationImpact(ctx context.Context, vuln *Vulnerability, asset *Asset, assessmentCtx *AssessmentContext) (*ReputationImpactDetails, error) {
	return bia.reputationAnalyzer.AnalyzeReputationImpact(ctx, vuln, asset, assessmentCtx)
}

// assessOperationalImpact assesses operational impact of vulnerability
func (bia *BusinessImpactAssessor) assessOperationalImpact(ctx context.Context, vuln *Vulnerability, asset *Asset, assessmentCtx *AssessmentContext) (*OperationalImpactDetails, error) {
	return bia.operationalAnalyzer.AnalyzeOperationalImpact(ctx, vuln, asset, assessmentCtx)
}

// assessCustomerImpact assesses customer impact of vulnerability
func (bia *BusinessImpactAssessor) assessCustomerImpact(ctx context.Context, vuln *Vulnerability, asset *Asset, assessmentCtx *AssessmentContext) (*CustomerImpactDetails, error) {
	impact := &CustomerImpactDetails{
		ConfidenceLevel: 0.7,
	}

	// Calculate customer experience impact based on asset type and vulnerability
	impact.CustomerExperienceImpact = bia.calculateCustomerExperienceImpact(vuln, asset)
	
	// Calculate service level impact
	impact.ServiceLevelImpact = bia.calculateServiceLevelImpact(vuln, asset)
	
	// Calculate customer retention risk
	impact.CustomerRetentionRisk = bia.calculateCustomerRetentionRisk(vuln, asset, impact.CustomerExperienceImpact)
	
	// Calculate customer acquisition impact
	impact.CustomerAcquisitionImpact = bia.calculateCustomerAcquisitionImpact(vuln, asset)
	
	// Calculate customer satisfaction impact
	impact.CustomerSatisfactionImpact = bia.calculateCustomerSatisfactionImpact(impact)
	
	// Estimate customer loss
	impact.EstimatedCustomerLoss = bia.estimateCustomerLoss(vuln, asset, impact)
	
	// Calculate revenue impact per customer
	impact.RevenueImpactPerCustomer = bia.config.CustomerLifetimeValue * impact.CustomerRetentionRisk
	
	// Identify affected customer segments
	impact.AffectedCustomerSegments = bia.identifyAffectedCustomerSegments(vuln, asset)
	
	// Generate customer communication needs
	impact.CustomerCommunicationNeeds = bia.generateCustomerCommunicationNeeds(vuln, asset, impact)

	return impact, nil
}

// assessCompetitiveImpact assesses competitive impact of vulnerability
func (bia *BusinessImpactAssessor) assessCompetitiveImpact(ctx context.Context, vuln *Vulnerability, asset *Asset, assessmentCtx *AssessmentContext) (*CompetitiveImpactDetails, error) {
	impact := &CompetitiveImpactDetails{
		ConfidenceLevel: 0.6,
		CompetitorAdvantage: make([]string, 0),
		StrategicImpact: make(map[string]float64),
	}

	// Calculate competitive advantage risk
	impact.CompetitiveAdvantageRisk = bia.calculateCompetitiveAdvantageRisk(vuln, asset)
	
	// Calculate market share risk
	impact.MarketShareRisk = bia.calculateMarketShareRisk(vuln, asset, impact.CompetitiveAdvantageRisk)
	
	// Calculate innovation impact
	impact.InnovationImpact = bia.calculateInnovationImpact(vuln, asset)
	
	// Calculate partnership risk
	impact.PartnershipRisk = bia.calculatePartnershipRisk(vuln, asset)
	
	// Calculate intellectual property risk
	impact.IntellectualPropertyRisk = bia.calculateIntellectualPropertyRisk(vuln, asset)
	
	// Calculate time to market impact
	impact.TimeToMarketImpact = bia.calculateTimeToMarketImpact(vuln, asset)
	
	// Identify competitor advantages
	impact.CompetitorAdvantage = bia.identifyCompetitorAdvantages(vuln, asset, impact)
	
	// Calculate strategic impact
	impact.StrategicImpact = bia.calculateStrategicImpact(vuln, asset, impact)

	return impact, nil
}

// assessRegulatoryImpact assesses regulatory impact of vulnerability
func (bia *BusinessImpactAssessor) assessRegulatoryImpact(ctx context.Context, vuln *Vulnerability, asset *Asset, assessmentCtx *AssessmentContext) (*RegulatoryImpactDetails, error) {
	impact := &RegulatoryImpactDetails{
		ConfidenceLevel: 0.8,
		ReportingObligations: make([]string, 0),
		AffectedRegulations: make([]string, 0),
		ComplianceGaps: make([]string, 0),
		RemediationRequirements: make([]string, 0),
	}

	// Calculate compliance violation risk
	impact.ComplianceViolationRisk = bia.calculateComplianceViolationRisk(vuln, asset)
	
	// Calculate regulatory penalty risk
	impact.RegulatoryPenaltyRisk = bia.calculateRegulatoryPenaltyRisk(vuln, asset, impact.ComplianceViolationRisk)
	
	// Calculate audit impact
	impact.AuditImpact = bia.calculateAuditImpact(vuln, asset)
	
	// Calculate license risk
	impact.LicenseRisk = bia.calculateLicenseRisk(vuln, asset)
	
	// Identify reporting obligations
	impact.ReportingObligations = bia.identifyReportingObligations(vuln, asset)
	
	// Identify affected regulations
	impact.AffectedRegulations = bia.identifyAffectedRegulations(vuln, asset)
	
	// Identify compliance gaps
	impact.ComplianceGaps = bia.identifyComplianceGaps(vuln, asset)
	
	// Generate remediation requirements
	impact.RemediationRequirements = bia.generateRemediationRequirements(vuln, asset, impact)

	return impact, nil
}

// calculateOverallImpactScore calculates the overall business impact score
func (bia *BusinessImpactAssessor) calculateOverallImpactScore(result *BusinessImpactResult, vuln *Vulnerability, asset *Asset) float64 {
	score := 0.0
	weights := 0.0

	// Financial impact (30% weight)
	if result.FinancialImpact != nil {
		financialScore := bia.normalizeFinancialImpact(result.FinancialImpact.TotalEstimatedCost)
		score += financialScore * 0.3
		weights += 0.3
	}

	// Operational impact (25% weight)
	if result.OperationalImpact != nil {
		operationalScore := (result.OperationalImpact.ProcessDisruption + 
						   result.OperationalImpact.ProductivityLoss + 
						   result.OperationalImpact.BusinessContinuityRisk) / 3.0
		score += operationalScore * 0.25
		weights += 0.25
	}

	// Customer impact (20% weight)
	if result.CustomerImpact != nil {
		customerScore := (result.CustomerImpact.CustomerExperienceImpact + 
						 result.CustomerImpact.CustomerRetentionRisk + 
						 result.CustomerImpact.ServiceLevelImpact) / 3.0
		score += customerScore * 0.2
		weights += 0.2
	}

	// Reputation impact (15% weight)
	if result.ReputationImpact != nil {
		reputationScore := (result.ReputationImpact.BrandDamageScore + 
						   result.ReputationImpact.CustomerTrustImpact + 
						   result.ReputationImpact.MarketPerceptionImpact) / 3.0
		score += reputationScore * 0.15
		weights += 0.15
	}

	// Regulatory impact (10% weight)
	if result.RegulatoryImpact != nil {
		regulatoryScore := (result.RegulatoryImpact.ComplianceViolationRisk + 
						   result.RegulatoryImpact.RegulatoryPenaltyRisk + 
						   result.RegulatoryImpact.AuditImpact) / 3.0
		score += regulatoryScore * 0.1
		weights += 0.1
	}

	// Asset criticality baseline
	assetScore := asset.BusinessValue
	score += assetScore * 0.1
	weights += 0.1

	if weights > 0 {
		score = score / weights
	} else {
		score = asset.BusinessValue // Fallback to asset business value
	}

	// Apply time-based factors
	score = bia.applyTimeBasedFactors(score, vuln)

	// Apply organizational factors
	score = bia.applyOrganizationalFactors(score, asset)

	return math.Min(score, 10.0)
}

// Helper methods for impact calculations would be implemented here
// For brevity, I'll include a few key ones:

func (bia *BusinessImpactAssessor) calculateCustomerExperienceImpact(vuln *Vulnerability, asset *Asset) float64 {
	baseImpact := asset.CustomerImpact
	
	// Adjust based on asset type
	switch asset.Type {
	case "web_server", "api_server":
		baseImpact += 2.0
	case "database":
		baseImpact += 1.5
	case "authentication_server":
		baseImpact += 3.0
	}
	
	// Adjust based on network exposure
	if vuln.NetworkContext.IsExternalFacing {
		baseImpact += 1.0
	}
	
	return math.Min(baseImpact, 10.0)
}

func (bia *BusinessImpactAssessor) normalizeFinancialImpact(cost float64) float64 {
	// Normalize cost to 0-10 scale based on organization size and revenue
	if cost <= 10000 {
		return 2.0
	} else if cost <= 50000 {
		return 4.0
	} else if cost <= 100000 {
		return 6.0
	} else if cost <= 500000 {
		return 8.0
	} else {
		return 10.0
	}
}

func (bia *BusinessImpactAssessor) applyTimeBasedFactors(score float64, vuln *Vulnerability) float64 {
	// Apply time-based multipliers
	now := time.Now()
	
	// Check if we're in peak business hours
	for _, window := range bia.config.PeakHours {
		if bia.isInTimeWindow(now, window) {
			score *= window.Multiplier
			break
		}
	}
	
	// Check critical periods
	for _, period := range bia.config.CriticalPeriods {
		if now.After(period.StartDate) && now.Before(period.EndDate) {
			score *= period.Importance
			break
		}
	}
	
	return score
}

func (bia *BusinessImpactAssessor) applyOrganizationalFactors(score float64, asset *Asset) float64 {
	// Apply organization-specific factors
	if bia.config.OrganizationProfile.RiskAppetite == "low" {
		score *= 1.2
	} else if bia.config.OrganizationProfile.RiskAppetite == "high" {
		score *= 0.8
	}
	
	return score
}

func (bia *BusinessImpactAssessor) isInTimeWindow(t time.Time, window TimeWindow) bool {
	// Simplified time window check
	hour := t.Hour()
	// Parse start and end times (simplified)
	return hour >= 9 && hour <= 17 // Business hours
}

func (bia *BusinessImpactAssessor) determineImpactLevel(score float64) string {
	if score >= 8.0 {
		return "critical"
	} else if score >= 6.0 {
		return "high"
	} else if score >= 4.0 {
		return "medium"
	} else {
		return "low"
	}
}

func (bia *BusinessImpactAssessor) calculateConfidence(result *BusinessImpactResult) float64 {
	confidence := 0.5 // Base confidence
	
	// Increase confidence based on available data
	if result.FinancialImpact != nil {
		confidence += 0.1
	}
	if result.OperationalImpact != nil {
		confidence += 0.1
	}
	if result.CustomerImpact != nil {
		confidence += 0.1
	}
	if result.ReputationImpact != nil {
		confidence += 0.1
	}
	if result.RegulatoryImpact != nil {
		confidence += 0.1
	}
	
	return math.Min(confidence, 1.0)
}

// Additional helper methods would be implemented for the remaining calculations...
// generateBusinessRiskFactors, generateMitigatingFactors, generateBusinessRecommendations, etc.

func (bia *BusinessImpactAssessor) generateBusinessRiskFactors(result *BusinessImpactResult, vuln *Vulnerability, asset *Asset, assessmentCtx *AssessmentContext) {
	factors := make([]BusinessRiskFactor, 0)
	
	// High business value asset factor
	if asset.BusinessValue >= 8.0 {
		factors = append(factors, BusinessRiskFactor{
			Category:    "asset_criticality",
			Description: "High business value asset increases impact potential",
			Impact:      asset.BusinessValue / 10.0,
			Likelihood:  0.8,
			Confidence:  0.9,
			Source:      "asset_analysis",
		})
	}
	
	// External facing factor
	if vuln.NetworkContext.IsExternalFacing {
		factors = append(factors, BusinessRiskFactor{
			Category:    "exposure",
			Description: "External network exposure increases business risk",
			Impact:      0.7,
			Likelihood:  0.9,
			Confidence:  0.8,
			Source:      "network_analysis",
		})
	}
	
	result.BusinessRiskFactors = factors
}

func (bia *BusinessImpactAssessor) generateMitigatingFactors(result *BusinessImpactResult, vuln *Vulnerability, asset *Asset, assessmentCtx *AssessmentContext) {
	factors := make([]BusinessMitigatingFactor, 0)
	
	// Insurance coverage
	if bia.config.InsuranceCoverage.CyberInsurance {
		factors = append(factors, BusinessMitigatingFactor{
			Type:           "insurance",
			Description:    "Cyber insurance coverage provides financial protection",
			Effectiveness:  0.6,
			Coverage:       0.8,
			Confidence:     0.9,
			Implementation: "active",
		})
	}
	
	// Business continuity plans
	if assessmentCtx.BusinessContext.AvailableResources.SecurityTeamCapacity > 0.7 {
		factors = append(factors, BusinessMitigatingFactor{
			Type:           "response_capability",
			Description:    "Strong incident response capability reduces impact",
			Effectiveness:  0.7,
			Coverage:       0.9,
			Confidence:     0.8,
			Implementation: "ready",
		})
	}
	
	result.MitigatingFactors = factors
}

func (bia *BusinessImpactAssessor) generateBusinessRecommendations(result *BusinessImpactResult, vuln *Vulnerability, asset *Asset) {
	recommendations := make([]BusinessRecommendation, 0)
	
	// High impact recommendations
	if result.ImpactScore >= 8.0 {
		recommendations = append(recommendations, BusinessRecommendation{
			Type:          "business_continuity",
			Priority:      "critical",
			Action:        "Activate business continuity procedures",
			BusinessValue: 0.9,
			CostBenefit:   0.8,
			Timeline:      "immediate",
			Stakeholders:  []string{"ceo", "cto", "business_continuity_manager"},
			RiskMitigation: 0.7,
		})
	}
	
	result.BusinessRecommendations = recommendations
}

func (bia *BusinessImpactAssessor) generatePriorityJustification(result *BusinessImpactResult, vuln *Vulnerability, asset *Asset) {
	justifications := make([]string, 0)
	
	justifications = append(justifications, fmt.Sprintf(
		"Business impact score of %.1f based on asset criticality and potential operational disruption",
		result.ImpactScore))
	
	if result.FinancialImpact != nil {
		justifications = append(justifications, fmt.Sprintf(
			"Estimated financial impact of $%.0f requires immediate attention",
			result.FinancialImpact.TotalEstimatedCost))
	}
	
	if asset.BusinessValue >= 8.0 {
		justifications = append(justifications, "Critical business asset requires prioritized protection")
	}
	
	result.PriorityJustification = justifications
}

func (bia *BusinessImpactAssessor) updateStatistics(result *BusinessImpactResult) {
	bia.mutex.Lock()
	defer bia.mutex.Unlock()
	
	bia.statistics.TotalAssessments++
	
	// Update average impact score
	totalScore := bia.statistics.AverageImpactScore * float64(bia.statistics.TotalAssessments-1)
	totalScore += result.ImpactScore
	bia.statistics.AverageImpactScore = totalScore / float64(bia.statistics.TotalAssessments)
	
	// Update impact level distribution
	bia.statistics.ImpactLevelDistribution[result.ImpactLevel]++
	
	// Update average financial impact
	if result.FinancialImpact != nil {
		totalFinancial := bia.statistics.AverageFinancialImpact * float64(bia.statistics.TotalAssessments-1)
		totalFinancial += result.FinancialImpact.TotalEstimatedCost
		bia.statistics.AverageFinancialImpact = totalFinancial / float64(bia.statistics.TotalAssessments)
	}
	
	bia.statistics.LastUpdate = time.Now()
}

// GetStatistics returns current business impact assessment statistics
func (bia *BusinessImpactAssessor) GetStatistics() BusinessImpactStatistics {
	bia.mutex.RLock()
	defer bia.mutex.RUnlock()
	return bia.statistics
}

// Placeholder implementations for sub-components
type DependencyAnalyzer struct {
	logger *slog.Logger
}

type FinancialImpactCalculator struct {
	config BusinessImpactConfig
	logger *slog.Logger
}

func (fic *FinancialImpactCalculator) CalculateFinancialImpact(ctx context.Context, vuln *Vulnerability, asset *Asset, assessmentCtx *AssessmentContext) (*FinancialImpactDetails, error) {
	impact := &FinancialImpactDetails{
		ConfidenceLevel: 0.7,
		CostBreakdown: make(map[string]float64),
	}
	
	// Calculate direct costs
	impact.DirectCosts = asset.BusinessValue * 1000 // Simplified calculation
	
	// Calculate indirect costs
	impact.IndirectCosts = impact.DirectCosts * 0.5
	
	// Calculate opportunity costs
	impact.OpportunityCosts = fic.config.HourlyRevenue * 24 // Assume 24 hours downtime
	
	// Calculate recovery costs
	impact.RecoveryCosts = impact.DirectCosts * 0.3
	
	// Calculate total estimated cost
	impact.TotalEstimatedCost = impact.DirectCosts + impact.IndirectCosts + 
								impact.OpportunityCosts + impact.RecoveryCosts
	
	// Set cost range
	impact.CostRange = CostRange{
		Minimum:    impact.TotalEstimatedCost * 0.7,
		Maximum:    impact.TotalEstimatedCost * 1.5,
		MostLikely: impact.TotalEstimatedCost,
		Confidence: 0.8,
	}
	
	// Build cost breakdown
	impact.CostBreakdown["direct"] = impact.DirectCosts
	impact.CostBreakdown["indirect"] = impact.IndirectCosts
	impact.CostBreakdown["opportunity"] = impact.OpportunityCosts
	impact.CostBreakdown["recovery"] = impact.RecoveryCosts
	
	impact.ImpactDuration = time.Hour * 24 // Default 24 hours
	
	return impact, nil
}

type ReputationImpactAnalyzer struct {
	config BusinessImpactConfig
	logger *slog.Logger
}

func (ria *ReputationImpactAnalyzer) AnalyzeReputationImpact(ctx context.Context, vuln *Vulnerability, asset *Asset, assessmentCtx *AssessmentContext) (*ReputationImpactDetails, error) {
	impact := &ReputationImpactDetails{
		ConfidenceLevel: 0.6,
		ReputationMetrics: make(map[string]float64),
		StakeholderImpact: make(map[string]float64),
	}
	
	// Calculate brand damage score
	impact.BrandDamageScore = ria.calculateBrandDamageScore(vuln, asset)
	
	// Calculate customer trust impact
	impact.CustomerTrustImpact = ria.calculateCustomerTrustImpact(vuln, asset)
	
	// Calculate market perception impact
	impact.MarketPerceptionImpact = ria.calculateMarketPerceptionImpact(vuln, asset)
	
	// Calculate media coverage risk
	impact.MediaCoverageRisk = ria.calculateMediaCoverageRisk(vuln, asset)
	
	// Calculate social media risk
	impact.SocialMediaRisk = ria.calculateSocialMediaRisk(vuln, asset)
	
	// Estimate recovery time
	impact.RecoveryTimeEstimate = ria.estimateReputationRecoveryTime(impact)
	
	return impact, nil
}

func (ria *ReputationImpactAnalyzer) calculateBrandDamageScore(vuln *Vulnerability, asset *Asset) float64 {
	baseScore := 3.0
	
	// High CVSS increases brand damage potential
	if vuln.CVSS >= 8.0 {
		baseScore += 3.0
	} else if vuln.CVSS >= 6.0 {
		baseScore += 2.0
	}
	
	// External facing assets have higher brand risk
	if vuln.NetworkContext.IsExternalFacing {
		baseScore += 2.0
	}
	
	// Customer-facing assets have higher brand risk
	if asset.Type == "web_server" || asset.Type == "api_server" {
		baseScore += 1.5
	}
	
	return math.Min(baseScore, 10.0)
}

func (ria *ReputationImpactAnalyzer) calculateCustomerTrustImpact(vuln *Vulnerability, asset *Asset) float64 {
	baseImpact := 4.0
	
	// Data-related vulnerabilities have higher trust impact
	if strings.Contains(strings.ToLower(vuln.Description), "data") || 
	   strings.Contains(strings.ToLower(vuln.Description), "privacy") {
		baseImpact += 3.0
	}
	
	// Authentication vulnerabilities severely impact trust
	if asset.Type == "authentication_server" {
		baseImpact += 2.5
	}
	
	return math.Min(baseImpact, 10.0)
}

func (ria *ReputationImpactAnalyzer) calculateMarketPerceptionImpact(vuln *Vulnerability, asset *Asset) float64 {
	// Similar calculation logic as brand damage but focused on market perception
	return ria.calculateBrandDamageScore(vuln, asset) * 0.8
}

func (ria *ReputationImpactAnalyzer) calculateMediaCoverageRisk(vuln *Vulnerability, asset *Asset) float64 {
	baseRisk := 2.0
	
	// High-profile vulnerabilities get more media attention
	if vuln.CVE != "" {
		baseRisk += 2.0
	}
	
	// External facing systems are more newsworthy
	if vuln.NetworkContext.IsExternalFacing {
		baseRisk += 1.5
	}
	
	return math.Min(baseRisk, 10.0)
}

func (ria *ReputationImpactAnalyzer) calculateSocialMediaRisk(vuln *Vulnerability, asset *Asset) float64 {
	// Social media risk often correlates with media coverage but spreads faster
	return ria.calculateMediaCoverageRisk(vuln, asset) * 1.2
}

func (ria *ReputationImpactAnalyzer) estimateReputationRecoveryTime(impact *ReputationImpactDetails) time.Duration {
	// Base recovery time
	baseTime := time.Hour * 24 * 30 // 30 days
	
	// Adjust based on impact severity
	if impact.BrandDamageScore >= 8.0 {
		baseTime *= 6 // 6 months for severe damage
	} else if impact.BrandDamageScore >= 6.0 {
		baseTime *= 3 // 3 months for moderate damage
	}
	
	return baseTime
}

type OperationalImpactAnalyzer struct {
	config BusinessImpactConfig
	logger *slog.Logger
}

func (oia *OperationalImpactAnalyzer) AnalyzeOperationalImpact(ctx context.Context, vuln *Vulnerability, asset *Asset, assessmentCtx *AssessmentContext) (*OperationalImpactDetails, error) {
	impact := &OperationalImpactDetails{
		ConfidenceLevel: 0.8,
		OperationalMetrics: make(map[string]float64),
		AffectedSystems: make([]string, 0),
	}
	
	// Calculate process disruption
	impact.ProcessDisruption = oia.calculateProcessDisruption(vuln, asset)
	
	// Calculate productivity loss
	impact.ProductivityLoss = oia.calculateProductivityLoss(vuln, asset)
	
	// Calculate service availability impact
	impact.ServiceAvailability = oia.calculateServiceAvailabilityImpact(vuln, asset)
	
	// Calculate data integrity risk
	impact.DataIntegrityRisk = oia.calculateDataIntegrityRisk(vuln, asset)
	
	// Calculate system performance impact
	impact.SystemPerformanceImpact = oia.calculateSystemPerformanceImpact(vuln, asset)
	
	// Calculate user experience impact
	impact.UserExperienceImpact = oia.calculateUserExperienceImpact(vuln, asset)
	
	// Calculate recovery complexity
	impact.RecoveryComplexity = oia.calculateRecoveryComplexity(vuln, asset)
	
	// Calculate business continuity risk
	impact.BusinessContinuityRisk = oia.calculateBusinessContinuityRisk(impact, asset)
	
	return impact, nil
}

func (oia *OperationalImpactAnalyzer) calculateProcessDisruption(vuln *Vulnerability, asset *Asset) float64 {
	baseDisruption := asset.BusinessValue * 0.5
	
	// High severity vulnerabilities cause more disruption
	if vuln.CVSS >= 8.0 {
		baseDisruption += 3.0
	} else if vuln.CVSS >= 6.0 {
		baseDisruption += 2.0
	}
	
	// Critical assets cause more process disruption when compromised
	if asset.Criticality == "critical" {
		baseDisruption += 2.0
	}
	
	return math.Min(baseDisruption, 10.0)
}

func (oia *OperationalImpactAnalyzer) calculateProductivityLoss(vuln *Vulnerability, asset *Asset) float64 {
	// Productivity loss correlates with process disruption
	return oia.calculateProcessDisruption(vuln, asset) * 0.8
}

func (oia *OperationalImpactAnalyzer) calculateServiceAvailabilityImpact(vuln *Vulnerability, asset *Asset) float64 {
	baseImpact := 3.0
	
	// DoS vulnerabilities have high availability impact
	if strings.Contains(strings.ToLower(vuln.Description), "denial") ||
	   strings.Contains(strings.ToLower(vuln.Description), "dos") {
		baseImpact += 4.0
	}
	
	// Critical infrastructure has higher availability requirements
	if asset.Type == "load_balancer" || asset.Type == "dns_server" {
		baseImpact += 2.0
	}
	
	return math.Min(baseImpact, 10.0)
}

func (oia *OperationalImpactAnalyzer) calculateDataIntegrityRisk(vuln *Vulnerability, asset *Asset) float64 {
	baseRisk := 2.0
	
	// Data corruption vulnerabilities have high integrity risk
	if strings.Contains(strings.ToLower(vuln.Description), "injection") ||
	   strings.Contains(strings.ToLower(vuln.Description), "corruption") {
		baseRisk += 4.0
	}
	
	// Database assets have higher data integrity risk
	if asset.Type == "database" {
		baseRisk += 3.0
	}
	
	return math.Min(baseRisk, 10.0)
}

func (oia *OperationalImpactAnalyzer) calculateSystemPerformanceImpact(vuln *Vulnerability, asset *Asset) float64 {
	baseImpact := asset.BusinessValue * 0.3
	
	// Performance-related vulnerabilities
	if strings.Contains(strings.ToLower(vuln.Description), "performance") ||
	   strings.Contains(strings.ToLower(vuln.Description), "memory") {
		baseImpact += 2.0
	}
	
	return math.Min(baseImpact, 10.0)
}

func (oia *OperationalImpactAnalyzer) calculateUserExperienceImpact(vuln *Vulnerability, asset *Asset) float64 {
	baseImpact := 3.0
	
	// User-facing systems have higher UX impact
	if asset.Type == "web_server" || asset.Type == "api_server" {
		baseImpact += 3.0
	}
	
	// External facing systems impact external users
	if vuln.NetworkContext.IsExternalFacing {
		baseImpact += 2.0
	}
	
	return math.Min(baseImpact, 10.0)
}

func (oia *OperationalImpactAnalyzer) calculateRecoveryComplexity(vuln *Vulnerability, asset *Asset) float64 {
	baseComplexity := 4.0
	
	// High CVSS scores often indicate complex recovery
	if vuln.CVSS >= 8.0 {
		baseComplexity += 3.0
	}
	
	// Database recovery is typically complex
	if asset.Type == "database" {
		baseComplexity += 2.0
	}
	
	return math.Min(baseComplexity, 10.0)
}

func (oia *OperationalImpactAnalyzer) calculateBusinessContinuityRisk(impact *OperationalImpactDetails, asset *Asset) float64 {
	// Business continuity risk is a combination of multiple factors
	riskScore := (impact.ProcessDisruption + 
				 impact.ServiceAvailability + 
				 impact.RecoveryComplexity) / 3.0
	
	// Critical assets have higher business continuity risk
	if asset.Criticality == "critical" {
		riskScore += 1.5
	}
	
	return math.Min(riskScore, 10.0)
}

// Additional placeholder methods for other calculations would be implemented similarly...
func (bia *BusinessImpactAssessor) calculateServiceLevelImpact(vuln *Vulnerability, asset *Asset) float64 { return 5.0 }
func (bia *BusinessImpactAssessor) calculateCustomerRetentionRisk(vuln *Vulnerability, asset *Asset, experienceImpact float64) float64 { return experienceImpact * 0.8 }
func (bia *BusinessImpactAssessor) calculateCustomerAcquisitionImpact(vuln *Vulnerability, asset *Asset) float64 { return 4.0 }
func (bia *BusinessImpactAssessor) calculateCustomerSatisfactionImpact(impact *CustomerImpactDetails) float64 { return (impact.CustomerExperienceImpact + impact.ServiceLevelImpact) / 2.0 }
func (bia *BusinessImpactAssessor) estimateCustomerLoss(vuln *Vulnerability, asset *Asset, impact *CustomerImpactDetails) int { return int(impact.CustomerRetentionRisk * 100) }
func (bia *BusinessImpactAssessor) identifyAffectedCustomerSegments(vuln *Vulnerability, asset *Asset) []CustomerSegment { return []CustomerSegment{} }
func (bia *BusinessImpactAssessor) generateCustomerCommunicationNeeds(vuln *Vulnerability, asset *Asset, impact *CustomerImpactDetails) []string { return []string{"email_notification", "status_page_update"} }
func (bia *BusinessImpactAssessor) calculateCompetitiveAdvantageRisk(vuln *Vulnerability, asset *Asset) float64 { return 5.0 }
func (bia *BusinessImpactAssessor) calculateMarketShareRisk(vuln *Vulnerability, asset *Asset, competitiveRisk float64) float64 { return competitiveRisk * 0.7 }
func (bia *BusinessImpactAssessor) calculateInnovationImpact(vuln *Vulnerability, asset *Asset) float64 { return 3.0 }
func (bia *BusinessImpactAssessor) calculatePartnershipRisk(vuln *Vulnerability, asset *Asset) float64 { return 4.0 }
func (bia *BusinessImpactAssessor) calculateIntellectualPropertyRisk(vuln *Vulnerability, asset *Asset) float64 { return 2.0 }
func (bia *BusinessImpactAssessor) calculateTimeToMarketImpact(vuln *Vulnerability, asset *Asset) float64 { return 3.0 }
func (bia *BusinessImpactAssessor) identifyCompetitorAdvantages(vuln *Vulnerability, asset *Asset, impact *CompetitiveImpactDetails) []string { return []string{} }
func (bia *BusinessImpactAssessor) calculateStrategicImpact(vuln *Vulnerability, asset *Asset, impact *CompetitiveImpactDetails) map[string]float64 { return make(map[string]float64) }
func (bia *BusinessImpactAssessor) calculateComplianceViolationRisk(vuln *Vulnerability, asset *Asset) float64 { return 6.0 }
func (bia *BusinessImpactAssessor) calculateRegulatoryPenaltyRisk(vuln *Vulnerability, asset *Asset, violationRisk float64) float64 { return violationRisk * 0.8 }
func (bia *BusinessImpactAssessor) calculateAuditImpact(vuln *Vulnerability, asset *Asset) float64 { return 5.0 }
func (bia *BusinessImpactAssessor) calculateLicenseRisk(vuln *Vulnerability, asset *Asset) float64 { return 3.0 }
func (bia *BusinessImpactAssessor) identifyReportingObligations(vuln *Vulnerability, asset *Asset) []string { return []string{} }
func (bia *BusinessImpactAssessor) identifyAffectedRegulations(vuln *Vulnerability, asset *Asset) []string { return []string{} }
func (bia *BusinessImpactAssessor) identifyComplianceGaps(vuln *Vulnerability, asset *Asset) []string { return []string{} }
func (bia *BusinessImpactAssessor) generateRemediationRequirements(vuln *Vulnerability, asset *Asset, impact *RegulatoryImpactDetails) []string { return []string{} }