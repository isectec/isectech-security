package risk

import (
	"context"
	"fmt"
	"log/slog"
	"math"
	"sync"
	"time"
)

// RiskAssessmentEngine coordinates comprehensive risk assessment for vulnerabilities
type RiskAssessmentEngine struct {
	config                   RiskAssessmentConfig
	logger                   *slog.Logger
	businessImpactAssessor   *BusinessImpactAssessor
	assetCriticalityEngine   *AssetCriticalityEngine
	threatIntelligenceEngine *ThreatIntelligenceEngine
	exploitabilityAssessor   *ExploitabilityAssessor
	prioritizationEngine     *PrioritizationEngine
	impactModelingEngine     *ImpactModelingEngine
	complianceAssessor       *ComplianceImpactAssessor
	statistics               RiskAssessmentStatistics
	cache                    RiskAssessmentCache
	mutex                    sync.RWMutex
}

// RiskAssessmentConfig defines configuration for risk assessment
type RiskAssessmentConfig struct {
	// Assessment settings
	EnableBusinessImpact     bool `json:"enable_business_impact"`
	EnableAssetCriticality   bool `json:"enable_asset_criticality"`
	EnableThreatIntelligence bool `json:"enable_threat_intelligence"`
	EnableExploitability     bool `json:"enable_exploitability"`
	EnableComplianceImpact   bool `json:"enable_compliance_impact"`
	EnableImpactModeling     bool `json:"enable_impact_modeling"`

	// Calculation settings
	RiskCalculationMethod string  `json:"risk_calculation_method"`
	WeightingStrategy     string  `json:"weighting_strategy"`
	NormalizationMethod   string  `json:"normalization_method"`
	TimeDecayFactor       float64 `json:"time_decay_factor"`
	ConfidenceThreshold   float64 `json:"confidence_threshold"`

	// Performance settings
	MaxConcurrentAssessments int           `json:"max_concurrent_assessments"`
	AssessmentTimeout        time.Duration `json:"assessment_timeout"`
	CacheEnabled             bool          `json:"cache_enabled"`
	CacheExpiration          time.Duration `json:"cache_expiration"`
	CacheMaxSize             int           `json:"cache_max_size"`

	// Business context
	OrganizationProfile    OrganizationProfile     `json:"organization_profile"`
	RiskTolerance          RiskToleranceProfile    `json:"risk_tolerance"`
	BusinessObjectives     []BusinessObjective     `json:"business_objectives"`
	ComplianceRequirements []ComplianceRequirement `json:"compliance_requirements"`

	// iSECTECH specific settings
	TenantIsolation          bool              `json:"tenant_isolation"`
	CustomRiskModels         []CustomRiskModel `json:"custom_risk_models"`
	IndustrySpecificFactors  bool              `json:"industry_specific_factors"`
	RegulatoryRequirements   []string          `json:"regulatory_requirements"`
	BusinessContinuityWeight float64           `json:"business_continuity_weight"`
}

// OrganizationProfile defines organizational characteristics affecting risk
type OrganizationProfile struct {
	Industry              string                 `json:"industry"`
	Size                  string                 `json:"size"`
	GeographicPresence    []string               `json:"geographic_presence"`
	BusinessModel         string                 `json:"business_model"`
	TechnologyStack       []string               `json:"technology_stack"`
	SecurityMaturity      string                 `json:"security_maturity"`
	RiskAppetite          string                 `json:"risk_appetite"`
	CriticalBusinessHours []BusinessHourWindow   `json:"critical_business_hours"`
	SeasonalFactors       []SeasonalRiskFactor   `json:"seasonal_factors"`
	CustomAttributes      map[string]interface{} `json:"custom_attributes"`
}

// BusinessHourWindow defines critical business operation windows
type BusinessHourWindow struct {
	TimeZone    string   `json:"timezone"`
	StartTime   string   `json:"start_time"`
	EndTime     string   `json:"end_time"`
	DaysOfWeek  []string `json:"days_of_week"`
	Criticality string   `json:"criticality"`
}

// SeasonalRiskFactor defines time-based risk variations
type SeasonalRiskFactor struct {
	Name           string  `json:"name"`
	StartDate      string  `json:"start_date"`
	EndDate        string  `json:"end_date"`
	RiskMultiplier float64 `json:"risk_multiplier"`
	Description    string  `json:"description"`
}

// RiskToleranceProfile defines organizational risk tolerance
type RiskToleranceProfile struct {
	OverallTolerance     string                 `json:"overall_tolerance"`
	CategoryTolerances   map[string]float64     `json:"category_tolerances"`
	AssetTypeTolerances  map[string]float64     `json:"asset_type_tolerances"`
	ImpactThresholds     map[string]float64     `json:"impact_thresholds"`
	MaxAcceptableRisk    float64                `json:"max_acceptable_risk"`
	RiskAppetiteMatrix   [][]float64            `json:"risk_appetite_matrix"`
	EscalationThresholds map[string]float64     `json:"escalation_thresholds"`
	CustomTolerances     map[string]interface{} `json:"custom_tolerances"`
}

// BusinessObjective defines strategic business objectives affecting risk priority
type BusinessObjective struct {
	ID            string                 `json:"id"`
	Name          string                 `json:"name"`
	Description   string                 `json:"description"`
	Priority      string                 `json:"priority"`
	Weight        float64                `json:"weight"`
	Timeline      string                 `json:"timeline"`
	KPIs          []string               `json:"kpis"`
	RelatedAssets []string               `json:"related_assets"`
	RiskImpact    float64                `json:"risk_impact"`
	Metadata      map[string]interface{} `json:"metadata"`
}

// ComplianceRequirement defines compliance requirements affecting risk
type ComplianceRequirement struct {
	Standard       string                 `json:"standard"`
	Control        string                 `json:"control"`
	Requirement    string                 `json:"requirement"`
	Criticality    string                 `json:"criticality"`
	Timeline       string                 `json:"timeline"`
	PenaltyRisk    float64                `json:"penalty_risk"`
	AuditFrequency string                 `json:"audit_frequency"`
	RelatedAssets  []string               `json:"related_assets"`
	Metadata       map[string]interface{} `json:"metadata"`
}

// CustomRiskModel defines custom risk calculation models
type CustomRiskModel struct {
	ID          string                 `json:"id"`
	Name        string                 `json:"name"`
	Description string                 `json:"description"`
	Conditions  []RiskModelCondition   `json:"conditions"`
	Formula     string                 `json:"formula"`
	Weight      float64                `json:"weight"`
	Enabled     bool                   `json:"enabled"`
	Metadata    map[string]interface{} `json:"metadata"`
}

// RiskModelCondition defines conditions for applying custom risk models
type RiskModelCondition struct {
	Field     string      `json:"field"`
	Operator  string      `json:"operator"`
	Value     interface{} `json:"value"`
	LogicalOp string      `json:"logical_op,omitempty"`
}

// RiskAssessmentResult contains comprehensive risk assessment results
type RiskAssessmentResult struct {
	VulnerabilityID  string  `json:"vulnerability_id"`
	OverallRiskScore float64 `json:"overall_risk_score"`
	RiskLevel        string  `json:"risk_level"`
	Priority         string  `json:"priority"`
	Confidence       float64 `json:"confidence"`

	// Component assessments
	BusinessImpact     *BusinessImpactResult     `json:"business_impact,omitempty"`
	AssetCriticality   *AssetCriticalityResult   `json:"asset_criticality,omitempty"`
	ThreatIntelligence *ThreatIntelligenceResult `json:"threat_intelligence,omitempty"`
	Exploitability     *ExploitabilityResult     `json:"exploitability,omitempty"`
	ComplianceImpact   *ComplianceImpactResult   `json:"compliance_impact,omitempty"`
	ImpactModeling     *ImpactModelingResult     `json:"impact_modeling,omitempty"`

	// Risk factors
	RiskFactors        []RiskFactor        `json:"risk_factors"`
	MitigatingFactors  []MitigatingFactor  `json:"mitigating_factors"`
	AggravatingFactors []AggravatingFactor `json:"aggravating_factors"`

	// Context and metadata
	AssessmentContext AssessmentContext    `json:"assessment_context"`
	Recommendations   []RiskRecommendation `json:"recommendations"`
	Justification     []string             `json:"justification"`
	ProcessingTime    time.Duration        `json:"processing_time"`
	Timestamp         time.Time            `json:"timestamp"`
	TenantID          string               `json:"tenant_id,omitempty"`
}

// RiskFactor represents an individual risk factor
type RiskFactor struct {
	Type        string                 `json:"type"`
	Category    string                 `json:"category"`
	Description string                 `json:"description"`
	Impact      float64                `json:"impact"`
	Likelihood  float64                `json:"likelihood"`
	Confidence  float64                `json:"confidence"`
	Source      string                 `json:"source"`
	Metadata    map[string]interface{} `json:"metadata"`
}

// MitigatingFactor represents factors that reduce risk
type MitigatingFactor struct {
	Type           string                 `json:"type"`
	Description    string                 `json:"description"`
	Effectiveness  float64                `json:"effectiveness"`
	Coverage       float64                `json:"coverage"`
	Confidence     float64                `json:"confidence"`
	Implementation string                 `json:"implementation"`
	Metadata       map[string]interface{} `json:"metadata"`
}

// AggravatingFactor represents factors that increase risk
type AggravatingFactor struct {
	Type        string                 `json:"type"`
	Description string                 `json:"description"`
	Multiplier  float64                `json:"multiplier"`
	Confidence  float64                `json:"confidence"`
	Urgency     string                 `json:"urgency"`
	Metadata    map[string]interface{} `json:"metadata"`
}

// AssessmentContext provides context for risk assessment
type AssessmentContext struct {
	Timestamp           time.Time              `json:"timestamp"`
	AssessmentVersion   string                 `json:"assessment_version"`
	OrganizationContext OrganizationProfile    `json:"organization_context"`
	ThreatLandscape     ThreatLandscapeContext `json:"threat_landscape"`
	BusinessContext     BusinessContext        `json:"business_context"`
	TechnicalContext    TechnicalContext       `json:"technical_context"`
	RegulatoryContext   RegulatoryContext      `json:"regulatory_context"`
}

// ThreatLandscapeContext provides current threat landscape information
type ThreatLandscapeContext struct {
	CurrentThreatLevel      string                 `json:"current_threat_level"`
	ActiveCampaigns         []string               `json:"active_campaigns"`
	TrendingVulnerabilities []string               `json:"trending_vulnerabilities"`
	IndustryTargeting       bool                   `json:"industry_targeting"`
	GeographicThreats       []string               `json:"geographic_threats"`
	ThreatActorActivity     map[string]interface{} `json:"threat_actor_activity"`
}

// BusinessContext provides current business context
type BusinessContext struct {
	CurrentBusinessCycle string               `json:"current_business_cycle"`
	CriticalProjects     []string             `json:"critical_projects"`
	UpcomingEvents       []string             `json:"upcoming_events"`
	SeasonalFactors      []string             `json:"seasonal_factors"`
	BusinessPressure     string               `json:"business_pressure"`
	AvailableResources   ResourceAvailability `json:"available_resources"`
}

// ResourceAvailability defines available resources for remediation
type ResourceAvailability struct {
	SecurityTeamCapacity float64  `json:"security_team_capacity"`
	ITOpsCapacity        float64  `json:"itops_capacity"`
	DevelopmentCapacity  float64  `json:"development_capacity"`
	BudgetAvailable      float64  `json:"budget_available"`
	VendorSupport        bool     `json:"vendor_support"`
	MaintenanceWindows   []string `json:"maintenance_windows"`
}

// TechnicalContext provides technical environment context
type TechnicalContext struct {
	InfrastructureState string  `json:"infrastructure_state"`
	SecurityPosture     string  `json:"security_posture"`
	MonitoringCoverage  float64 `json:"monitoring_coverage"`
	IncidentResponse    string  `json:"incident_response"`
	PatchManagement     string  `json:"patch_management"`
	BackupStatus        string  `json:"backup_status"`
	TechnicalDebt       float64 `json:"technical_debt"`
}

// RegulatoryContext provides regulatory environment context
type RegulatoryContext struct {
	ApplicableRegulations []string `json:"applicable_regulations"`
	ComplianceStatus      string   `json:"compliance_status"`
	UpcomingAudits        []string `json:"upcoming_audits"`
	RecentViolations      []string `json:"recent_violations"`
	RegulatoryChanges     []string `json:"regulatory_changes"`
	EnforcementClimate    string   `json:"enforcement_climate"`
}

// RiskRecommendation provides actionable recommendations
type RiskRecommendation struct {
	Type           string                 `json:"type"`
	Priority       string                 `json:"priority"`
	Action         string                 `json:"action"`
	Timeline       string                 `json:"timeline"`
	Resources      []string               `json:"resources"`
	Dependencies   []string               `json:"dependencies"`
	CostEstimate   float64                `json:"cost_estimate"`
	RiskReduction  float64                `json:"risk_reduction"`
	BusinessValue  float64                `json:"business_value"`
	Implementation ImplementationGuidance `json:"implementation"`
	Metadata       map[string]interface{} `json:"metadata"`
}

// ImplementationGuidance provides detailed implementation guidance
type ImplementationGuidance struct {
	Steps           []string `json:"steps"`
	Tools           []string `json:"tools"`
	Skills          []string `json:"skills"`
	Risks           []string `json:"risks"`
	SuccessCriteria []string `json:"success_criteria"`
	Verification    []string `json:"verification"`
	Rollback        []string `json:"rollback"`
	Documentation   []string `json:"documentation"`
}

// RiskAssessmentStatistics tracks risk assessment performance
type RiskAssessmentStatistics struct {
	TotalAssessments      int64                    `json:"total_assessments"`
	SuccessfulAssessments int64                    `json:"successful_assessments"`
	FailedAssessments     int64                    `json:"failed_assessments"`
	AverageAssessmentTime float64                  `json:"average_assessment_time"`
	AverageRiskScore      float64                  `json:"average_risk_score"`
	RiskLevelDistribution map[string]int64         `json:"risk_level_distribution"`
	ComponentPerformance  map[string]ComponentStat `json:"component_performance"`
	CacheHitRate          float64                  `json:"cache_hit_rate"`
	LastUpdate            time.Time                `json:"last_update"`
}

// ComponentStat tracks individual component performance
type ComponentStat struct {
	Executions    int64     `json:"executions"`
	SuccessRate   float64   `json:"success_rate"`
	AverageTime   float64   `json:"average_time"`
	LastExecution time.Time `json:"last_execution"`
}

// RiskAssessmentCache provides caching for risk assessments
type RiskAssessmentCache struct {
	cache     map[string]*RiskAssessmentResult
	ttl       map[string]time.Time
	mutex     sync.RWMutex
	maxSize   int
	enabled   bool
	hitCount  int64
	missCount int64
}

// Vulnerability represents a vulnerability for risk assessment
type Vulnerability struct {
	ID               string                 `json:"id"`
	Title            string                 `json:"title"`
	Description      string                 `json:"description"`
	CVE              string                 `json:"cve,omitempty"`
	CVSS             float64                `json:"cvss"`
	Severity         string                 `json:"severity"`
	AssetID          string                 `json:"asset_id"`
	ScannerID        string                 `json:"scanner_id"`
	DiscoveryTime    time.Time              `json:"discovery_time"`
	Evidence         map[string]interface{} `json:"evidence"`
	TechnicalDetails map[string]interface{} `json:"technical_details"`
	NetworkContext   NetworkContext         `json:"network_context"`
}

// NetworkContext provides network-related vulnerability context
type NetworkContext struct {
	SourceIP         string `json:"source_ip"`
	DestinationIP    string `json:"destination_ip"`
	Port             int    `json:"port"`
	Protocol         string `json:"protocol"`
	IsExternalFacing bool   `json:"is_external_facing"`
	NetworkSegment   string `json:"network_segment"`
}

// NewRiskAssessmentEngine creates a new risk assessment engine
func NewRiskAssessmentEngine(config RiskAssessmentConfig, logger *slog.Logger) (*RiskAssessmentEngine, error) {
	if logger == nil {
		logger = slog.Default()
	}

	// Initialize cache
	cache := RiskAssessmentCache{
		cache:   make(map[string]*RiskAssessmentResult),
		ttl:     make(map[string]time.Time),
		maxSize: config.CacheMaxSize,
		enabled: config.CacheEnabled,
	}

	engine := &RiskAssessmentEngine{
		config: config,
		logger: logger,
		cache:  cache,
		statistics: RiskAssessmentStatistics{
			RiskLevelDistribution: make(map[string]int64),
			ComponentPerformance:  make(map[string]ComponentStat),
			LastUpdate:            time.Now(),
		},
	}

	// Initialize sub-engines
	if err := engine.initializeSubEngines(); err != nil {
		return nil, fmt.Errorf("failed to initialize sub-engines: %w", err)
	}

	return engine, nil
}

// AssessRisk performs comprehensive risk assessment for a vulnerability
func (rae *RiskAssessmentEngine) AssessRisk(ctx context.Context, vuln *Vulnerability) (*RiskAssessmentResult, error) {
	startTime := time.Now()

	// Check cache first
	if rae.config.CacheEnabled {
		if cached := rae.getCachedResult(vuln.ID); cached != nil {
			rae.updateCacheHitStats(true)
			return cached, nil
		}
		rae.updateCacheHitStats(false)
	}

	// Create assessment context
	assessmentCtx, cancel := context.WithTimeout(ctx, rae.config.AssessmentTimeout)
	defer cancel()

	// Initialize result
	result := &RiskAssessmentResult{
		VulnerabilityID:    vuln.ID,
		RiskFactors:        make([]RiskFactor, 0),
		MitigatingFactors:  make([]MitigatingFactor, 0),
		AggravatingFactors: make([]AggravatingFactor, 0),
		Recommendations:    make([]RiskRecommendation, 0),
		Justification:      make([]string, 0),
		Timestamp:          time.Now(),
	}

	// Add tenant ID if tenant isolation is enabled
	if rae.config.TenantIsolation {
		if tenantID, exists := vuln.TechnicalDetails["tenant_id"]; exists {
			result.TenantID = tenantID.(string)
		}
	}

	// Build assessment context
	result.AssessmentContext = rae.buildAssessmentContext(assessmentCtx)

	// Perform component assessments in parallel
	assessmentResults := make(chan ComponentAssessmentResult, 6)
	var wg sync.WaitGroup

	// Business Impact Assessment
	if rae.config.EnableBusinessImpact && rae.businessImpactAssessor != nil {
		wg.Add(1)
		go func() {
			defer wg.Done()
			bizResult, err := rae.businessImpactAssessor.AssessBusinessImpact(assessmentCtx, vuln, &result.AssessmentContext)
			assessmentResults <- ComponentAssessmentResult{
				Type:   "business_impact",
				Result: bizResult,
				Error:  err,
			}
		}()
	}

	// Asset Criticality Assessment
	if rae.config.EnableAssetCriticality && rae.assetCriticalityEngine != nil {
		wg.Add(1)
		go func() {
			defer wg.Done()
			assetResult, err := rae.assetCriticalityEngine.AssessAssetCriticality(assessmentCtx, vuln)
			assessmentResults <- ComponentAssessmentResult{
				Type:   "asset_criticality",
				Result: assetResult,
				Error:  err,
			}
		}()
	}

	// Threat Intelligence Assessment
	if rae.config.EnableThreatIntelligence && rae.threatIntelligenceEngine != nil {
		wg.Add(1)
		go func() {
			defer wg.Done()
			threatResult, err := rae.threatIntelligenceEngine.AssessThreatIntelligence(assessmentCtx, vuln)
			assessmentResults <- ComponentAssessmentResult{
				Type:   "threat_intelligence",
				Result: threatResult,
				Error:  err,
			}
		}()
	}

	// Exploitability Assessment
	if rae.config.EnableExploitability && rae.exploitabilityAssessor != nil {
		wg.Add(1)
		go func() {
			defer wg.Done()
			exploitResult, err := rae.exploitabilityAssessor.AssessExploitability(assessmentCtx, vuln)
			assessmentResults <- ComponentAssessmentResult{
				Type:   "exploitability",
				Result: exploitResult,
				Error:  err,
			}
		}()
	}

	// Compliance Impact Assessment
	if rae.config.EnableComplianceImpact && rae.complianceAssessor != nil {
		wg.Add(1)
		go func() {
			defer wg.Done()
			complianceResult, err := rae.complianceAssessor.AssessComplianceImpact(assessmentCtx, vuln)
			assessmentResults <- ComponentAssessmentResult{
				Type:   "compliance_impact",
				Result: complianceResult,
				Error:  err,
			}
		}()
	}

	// Impact Modeling
	if rae.config.EnableImpactModeling && rae.impactModelingEngine != nil {
		wg.Add(1)
		go func() {
			defer wg.Done()
			modelingResult, err := rae.impactModelingEngine.ModelImpact(assessmentCtx, vuln, result)
			assessmentResults <- ComponentAssessmentResult{
				Type:   "impact_modeling",
				Result: modelingResult,
				Error:  err,
			}
		}()
	}

	// Wait for all assessments to complete
	go func() {
		wg.Wait()
		close(assessmentResults)
	}()

	// Collect assessment results
	componentErrors := make([]error, 0)
	for assessmentResult := range assessmentResults {
		if assessmentResult.Error != nil {
			componentErrors = append(componentErrors, assessmentResult.Error)
			rae.logger.Warn("Component assessment failed",
				"component", assessmentResult.Type,
				"vulnerability_id", vuln.ID,
				"error", assessmentResult.Error)
			continue
		}

		// Store component results
		switch assessmentResult.Type {
		case "business_impact":
			result.BusinessImpact = assessmentResult.Result.(*BusinessImpactResult)
		case "asset_criticality":
			result.AssetCriticality = assessmentResult.Result.(*AssetCriticalityResult)
		case "threat_intelligence":
			result.ThreatIntelligence = assessmentResult.Result.(*ThreatIntelligenceResult)
		case "exploitability":
			result.Exploitability = assessmentResult.Result.(*ExploitabilityResult)
		case "compliance_impact":
			result.ComplianceImpact = assessmentResult.Result.(*ComplianceImpactResult)
		case "impact_modeling":
			result.ImpactModeling = assessmentResult.Result.(*ImpactModelingResult)
		}
	}

	// Apply custom risk models
	rae.applyCustomRiskModels(result, vuln)

	// Calculate overall risk score using prioritization engine
	if rae.prioritizationEngine != nil {
		overallRisk, err := rae.prioritizationEngine.CalculateOverallRisk(assessmentCtx, result, vuln)
		if err != nil {
			return nil, fmt.Errorf("failed to calculate overall risk: %w", err)
		}
		result.OverallRiskScore = overallRisk.RiskScore
		result.RiskLevel = overallRisk.RiskLevel
		result.Priority = overallRisk.Priority
		result.Confidence = overallRisk.Confidence
		result.RiskFactors = append(result.RiskFactors, overallRisk.RiskFactors...)
		result.MitigatingFactors = append(result.MitigatingFactors, overallRisk.MitigatingFactors...)
		result.AggravatingFactors = append(result.AggravatingFactors, overallRisk.AggravatingFactors...)
	}

	// Generate recommendations
	rae.generateRecommendations(result, vuln)

	// Generate justification
	rae.generateJustification(result, vuln)

	// Calculate processing time
	result.ProcessingTime = time.Since(startTime)

	// Cache result
	if rae.config.CacheEnabled {
		rae.cacheResult(vuln.ID, result)
	}

	// Update statistics
	rae.updateStatistics(result, componentErrors)

	rae.logger.Info("Risk assessment completed",
		"vulnerability_id", vuln.ID,
		"overall_risk_score", result.OverallRiskScore,
		"risk_level", result.RiskLevel,
		"priority", result.Priority,
		"processing_time", result.ProcessingTime,
		"component_errors", len(componentErrors))

	return result, nil
}

// ComponentAssessmentResult represents the result of a component assessment
type ComponentAssessmentResult struct {
	Type   string
	Result interface{}
	Error  error
}

// initializeSubEngines initializes all sub-assessment engines
func (rae *RiskAssessmentEngine) initializeSubEngines() error {
	var err error

	// Initialize Business Impact Assessor
	if rae.config.EnableBusinessImpact {
		rae.businessImpactAssessor, err = NewBusinessImpactAssessor(BusinessImpactConfig{
			OrganizationProfile: rae.config.OrganizationProfile,
			BusinessObjectives:  rae.config.BusinessObjectives,
			RiskTolerance:       rae.config.RiskTolerance,
		}, rae.logger)
		if err != nil {
			return fmt.Errorf("failed to initialize business impact assessor: %w", err)
		}
	}

	// Initialize Asset Criticality Engine
	if rae.config.EnableAssetCriticality {
		rae.assetCriticalityEngine, err = NewAssetCriticalityEngine(AssetCriticalityConfig{
			OrganizationProfile: rae.config.OrganizationProfile,
			BusinessObjectives:  rae.config.BusinessObjectives,
		}, rae.logger)
		if err != nil {
			return fmt.Errorf("failed to initialize asset criticality engine: %w", err)
		}
	}

	// Initialize Threat Intelligence Engine
	if rae.config.EnableThreatIntelligence {
		rae.threatIntelligenceEngine, err = NewThreatIntelligenceEngine(ThreatIntelligenceConfig{
			OrganizationProfile: rae.config.OrganizationProfile,
		}, rae.logger)
		if err != nil {
			return fmt.Errorf("failed to initialize threat intelligence engine: %w", err)
		}
	}

	// Initialize Exploitability Assessor
	if rae.config.EnableExploitability {
		rae.exploitabilityAssessor, err = NewExploitabilityAssessor(ExploitabilityConfig{
			OrganizationProfile: rae.config.OrganizationProfile,
		}, rae.logger)
		if err != nil {
			return fmt.Errorf("failed to initialize exploitability assessor: %w", err)
		}
	}

	// Initialize Compliance Assessor
	if rae.config.EnableComplianceImpact {
		rae.complianceAssessor, err = NewComplianceImpactAssessor(ComplianceConfig{
			ComplianceRequirements: rae.config.ComplianceRequirements,
			OrganizationProfile:    rae.config.OrganizationProfile,
		}, rae.logger)
		if err != nil {
			return fmt.Errorf("failed to initialize compliance assessor: %w", err)
		}
	}

	// Initialize Impact Modeling Engine
	if rae.config.EnableImpactModeling {
		rae.impactModelingEngine, err = NewImpactModelingEngine(ImpactModelingConfig{
			OrganizationProfile: rae.config.OrganizationProfile,
			BusinessObjectives:  rae.config.BusinessObjectives,
		}, rae.logger)
		if err != nil {
			return fmt.Errorf("failed to initialize impact modeling engine: %w", err)
		}
	}

	// Initialize Prioritization Engine
	rae.prioritizationEngine, err = NewPrioritizationEngine(PrioritizationConfig{
		CalculationMethod:   rae.config.RiskCalculationMethod,
		WeightingStrategy:   rae.config.WeightingStrategy,
		NormalizationMethod: rae.config.NormalizationMethod,
		RiskTolerance:       rae.config.RiskTolerance,
		OrganizationProfile: rae.config.OrganizationProfile,
	}, rae.logger)
	if err != nil {
		return fmt.Errorf("failed to initialize prioritization engine: %w", err)
	}

	return nil
}

// buildAssessmentContext creates comprehensive assessment context
func (rae *RiskAssessmentEngine) buildAssessmentContext(ctx context.Context) AssessmentContext {
	// This would typically gather real-time context from various sources
	// For now, we'll create a comprehensive but static context
	return AssessmentContext{
		Timestamp:           time.Now(),
		AssessmentVersion:   "1.0",
		OrganizationContext: rae.config.OrganizationProfile,
		ThreatLandscape: ThreatLandscapeContext{
			CurrentThreatLevel:      "elevated",
			ActiveCampaigns:         []string{"apt29", "lazarus"},
			TrendingVulnerabilities: []string{"CVE-2024-1234", "CVE-2024-5678"},
			IndustryTargeting:       true,
			GeographicThreats:       []string{"state-sponsored", "cybercriminal"},
		},
		BusinessContext: BusinessContext{
			CurrentBusinessCycle: "peak",
			CriticalProjects:     []string{"digital_transformation", "cloud_migration"},
			UpcomingEvents:       []string{"earnings_call", "product_launch"},
			SeasonalFactors:      []string{"holiday_shopping", "tax_season"},
			BusinessPressure:     "high",
			AvailableResources: ResourceAvailability{
				SecurityTeamCapacity: 0.7,
				ITOpsCapacity:        0.6,
				DevelopmentCapacity:  0.8,
				BudgetAvailable:      100000.0,
				VendorSupport:        true,
				MaintenanceWindows:   []string{"saturday_night", "sunday_morning"},
			},
		},
		TechnicalContext: TechnicalContext{
			InfrastructureState: "stable",
			SecurityPosture:     "good",
			MonitoringCoverage:  0.85,
			IncidentResponse:    "ready",
			PatchManagement:     "automated",
			BackupStatus:        "current",
			TechnicalDebt:       0.3,
		},
		RegulatoryContext: RegulatoryContext{
			ApplicableRegulations: rae.config.RegulatoryRequirements,
			ComplianceStatus:      "compliant",
			UpcomingAudits:        []string{"sox_audit", "iso27001_audit"},
			RecentViolations:      []string{},
			RegulatoryChanges:     []string{"gdpr_update", "ccpa_amendment"},
			EnforcementClimate:    "strict",
		},
	}
}

// applyCustomRiskModels applies organization-specific custom risk models
func (rae *RiskAssessmentEngine) applyCustomRiskModels(result *RiskAssessmentResult, vuln *Vulnerability) {
	for _, model := range rae.config.CustomRiskModels {
		if !model.Enabled {
			continue
		}

		// Check if model conditions are met
		if rae.evaluateCustomModelConditions(model.Conditions, vuln, result) {
			// Apply custom risk calculation
			customRisk := rae.calculateCustomRiskScore(model, vuln, result)

			// Add as risk factor
			result.RiskFactors = append(result.RiskFactors, RiskFactor{
				Type:        "custom_model",
				Category:    "organizational",
				Description: fmt.Sprintf("Custom risk model: %s", model.Name),
				Impact:      customRisk,
				Likelihood:  0.8, // Default likelihood for custom models
				Confidence:  0.9, // High confidence in custom models
				Source:      fmt.Sprintf("custom_model_%s", model.ID),
				Metadata: map[string]interface{}{
					"model_id":   model.ID,
					"model_name": model.Name,
					"formula":    model.Formula,
				},
			})

			rae.logger.Debug("Applied custom risk model",
				"model_id", model.ID,
				"model_name", model.Name,
				"vulnerability_id", vuln.ID,
				"custom_risk", customRisk)
		}
	}
}

// evaluateCustomModelConditions evaluates conditions for custom risk models
func (rae *RiskAssessmentEngine) evaluateCustomModelConditions(conditions []RiskModelCondition, vuln *Vulnerability, result *RiskAssessmentResult) bool {
	if len(conditions) == 0 {
		return true
	}

	for _, condition := range conditions {
		if !rae.evaluateCondition(condition, vuln, result) {
			return false
		}
	}

	return true
}

// evaluateCondition evaluates a single condition
func (rae *RiskAssessmentEngine) evaluateCondition(condition RiskModelCondition, vuln *Vulnerability, result *RiskAssessmentResult) bool {
	fieldValue := rae.getFieldValue(condition.Field, vuln, result)

	switch condition.Operator {
	case "equals":
		return fmt.Sprintf("%v", fieldValue) == fmt.Sprintf("%v", condition.Value)
	case "greater_than":
		return rae.compareNumeric(fieldValue, condition.Value, ">")
	case "less_than":
		return rae.compareNumeric(fieldValue, condition.Value, "<")
	case "contains":
		return rae.containsValue(fieldValue, condition.Value)
	case "in":
		return rae.valueInList(fieldValue, condition.Value)
	default:
		return false
	}
}

// getFieldValue extracts field value for condition evaluation
func (rae *RiskAssessmentEngine) getFieldValue(field string, vuln *Vulnerability, result *RiskAssessmentResult) interface{} {
	switch field {
	case "cvss":
		return vuln.CVSS
	case "severity":
		return vuln.Severity
	case "asset_id":
		return vuln.AssetID
	case "scanner_id":
		return vuln.ScannerID
	case "is_external_facing":
		return vuln.NetworkContext.IsExternalFacing
	case "port":
		return vuln.NetworkContext.Port
	case "overall_risk_score":
		return result.OverallRiskScore
	case "business_impact_score":
		if result.BusinessImpact != nil {
			return result.BusinessImpact.ImpactScore
		}
		return 0.0
	case "asset_criticality_score":
		if result.AssetCriticality != nil {
			return result.AssetCriticality.CriticalityScore
		}
		return 0.0
	default:
		// Check technical details
		if val, exists := vuln.TechnicalDetails[field]; exists {
			return val
		}
		return nil
	}
}

// Helper methods for condition evaluation
func (rae *RiskAssessmentEngine) compareNumeric(a, b interface{}, operator string) bool {
	aVal, aOk := a.(float64)
	bVal, bOk := b.(float64)

	if !aOk || !bOk {
		return false
	}

	switch operator {
	case ">":
		return aVal > bVal
	case "<":
		return aVal < bVal
	case ">=":
		return aVal >= bVal
	case "<=":
		return aVal <= bVal
	default:
		return false
	}
}

func (rae *RiskAssessmentEngine) containsValue(value, expected interface{}) bool {
	valueStr := fmt.Sprintf("%v", value)
	expectedStr := fmt.Sprintf("%v", expected)
	return len(valueStr) >= len(expectedStr) && valueStr[:len(expectedStr)] == expectedStr
}

func (rae *RiskAssessmentEngine) valueInList(value, expected interface{}) bool {
	valueStr := fmt.Sprintf("%v", value)
	expectedStr := fmt.Sprintf("%v", expected)
	return valueStr == expectedStr
}

// calculateCustomRiskScore calculates risk score using custom formula
func (rae *RiskAssessmentEngine) calculateCustomRiskScore(model CustomRiskModel, vuln *Vulnerability, result *RiskAssessmentResult) float64 {
	// This is a simplified implementation
	// In a real system, you'd parse and evaluate the formula
	baseScore := vuln.CVSS * model.Weight

	// Apply organization-specific factors
	if vuln.NetworkContext.IsExternalFacing {
		baseScore *= 1.2
	}

	if vuln.NetworkContext.Port == 443 || vuln.NetworkContext.Port == 80 {
		baseScore *= 1.1
	}

	return math.Min(baseScore, 10.0)
}

// generateRecommendations generates actionable recommendations based on risk assessment
func (rae *RiskAssessmentEngine) generateRecommendations(result *RiskAssessmentResult, vuln *Vulnerability) {
	recommendations := make([]RiskRecommendation, 0)

	// High-risk recommendations
	if result.OverallRiskScore >= 8.0 {
		recommendations = append(recommendations, RiskRecommendation{
			Type:          "immediate_action",
			Priority:      "critical",
			Action:        "Implement emergency response procedures",
			Timeline:      "immediate",
			Resources:     []string{"security_team", "incident_response"},
			CostEstimate:  5000.0,
			RiskReduction: 0.7,
			BusinessValue: 0.9,
			Implementation: ImplementationGuidance{
				Steps: []string{
					"Activate incident response team",
					"Assess immediate exposure",
					"Implement temporary containment",
					"Develop remediation plan",
				},
				Tools:           []string{"SIEM", "vulnerability_scanner", "patch_management"},
				Skills:          []string{"incident_response", "vulnerability_assessment"},
				Risks:           []string{"service_disruption", "data_exposure"},
				SuccessCriteria: []string{"vulnerability_patched", "systems_secure"},
				Verification:    []string{"rescan_systems", "penetration_test"},
			},
		})
	}

	// Business impact recommendations
	if result.BusinessImpact != nil && result.BusinessImpact.ImpactScore >= 7.0 {
		recommendations = append(recommendations, RiskRecommendation{
			Type:          "business_continuity",
			Priority:      "high",
			Action:        "Activate business continuity measures",
			Timeline:      "within_24_hours",
			Resources:     []string{"business_continuity_team", "it_operations"},
			CostEstimate:  10000.0,
			RiskReduction: 0.5,
			BusinessValue: 0.8,
			Implementation: ImplementationGuidance{
				Steps: []string{
					"Assess business impact",
					"Activate backup systems",
					"Implement workarounds",
					"Communicate with stakeholders",
				},
			},
		})
	}

	// Compliance recommendations
	if result.ComplianceImpact != nil && len(result.ComplianceImpact.AffectedStandards) > 0 {
		recommendations = append(recommendations, RiskRecommendation{
			Type:          "compliance",
			Priority:      "high",
			Action:        "Address compliance violations",
			Timeline:      "within_72_hours",
			Resources:     []string{"compliance_team", "legal"},
			CostEstimate:  15000.0,
			RiskReduction: 0.4,
			BusinessValue: 0.7,
			Implementation: ImplementationGuidance{
				Steps: []string{
					"Document compliance impact",
					"Notify relevant authorities if required",
					"Implement corrective measures",
					"Update compliance documentation",
				},
			},
		})
	}

	// Exploitability recommendations
	if result.Exploitability != nil && result.Exploitability.ExploitabilityScore >= 7.0 {
		recommendations = append(recommendations, RiskRecommendation{
			Type:          "technical_mitigation",
			Priority:      "high",
			Action:        "Implement technical controls to reduce exploitability",
			Timeline:      "within_48_hours",
			Resources:     []string{"security_engineers", "network_team"},
			CostEstimate:  8000.0,
			RiskReduction: 0.6,
			BusinessValue: 0.6,
			Implementation: ImplementationGuidance{
				Steps: []string{
					"Implement network segmentation",
					"Deploy additional monitoring",
					"Configure access controls",
					"Update security policies",
				},
			},
		})
	}

	result.Recommendations = recommendations
}

// generateJustification generates risk assessment justification
func (rae *RiskAssessmentEngine) generateJustification(result *RiskAssessmentResult, vuln *Vulnerability) {
	justifications := make([]string, 0)

	// Overall risk justification
	justifications = append(justifications, fmt.Sprintf(
		"Overall risk score of %.1f determined based on comprehensive multi-factor analysis",
		result.OverallRiskScore))

	// Business impact justification
	if result.BusinessImpact != nil {
		justifications = append(justifications, fmt.Sprintf(
			"Business impact score of %.1f reflects potential disruption to critical business functions",
			result.BusinessImpact.ImpactScore))
	}

	// Asset criticality justification
	if result.AssetCriticality != nil {
		justifications = append(justifications, fmt.Sprintf(
			"Asset criticality score of %.1f indicates %s importance to business operations",
			result.AssetCriticality.CriticalityScore,
			result.AssetCriticality.CriticalityLevel))
	}

	// Threat intelligence justification
	if result.ThreatIntelligence != nil && result.ThreatIntelligence.ThreatScore >= 7.0 {
		justifications = append(justifications, "High threat intelligence score indicates active targeting")
	}

	// Exploitability justification
	if result.Exploitability != nil && result.Exploitability.ExploitabilityScore >= 7.0 {
		justifications = append(justifications, "High exploitability score due to available public exploits")
	}

	// Compliance justification
	if result.ComplianceImpact != nil && len(result.ComplianceImpact.AffectedStandards) > 0 {
		justifications = append(justifications, fmt.Sprintf(
			"Compliance impact affects %d regulatory standards",
			len(result.ComplianceImpact.AffectedStandards)))
	}

	// Time-based justification
	age := time.Since(vuln.DiscoveryTime)
	if age > time.Hour*24*7 {
		justifications = append(justifications, "Vulnerability age increases urgency for remediation")
	}

	// Network exposure justification
	if vuln.NetworkContext.IsExternalFacing {
		justifications = append(justifications, "External network exposure increases attack surface")
	}

	result.Justification = justifications
}

// Cache management methods
func (rae *RiskAssessmentEngine) getCachedResult(vulnerabilityID string) *RiskAssessmentResult {
	rae.cache.mutex.RLock()
	defer rae.cache.mutex.RUnlock()

	if !rae.cache.enabled {
		return nil
	}

	result, exists := rae.cache.cache[vulnerabilityID]
	if !exists {
		return nil
	}

	// Check TTL
	if ttl, exists := rae.cache.ttl[vulnerabilityID]; exists {
		if time.Now().After(ttl) {
			delete(rae.cache.cache, vulnerabilityID)
			delete(rae.cache.ttl, vulnerabilityID)
			return nil
		}
	}

	return result
}

func (rae *RiskAssessmentEngine) cacheResult(vulnerabilityID string, result *RiskAssessmentResult) {
	rae.cache.mutex.Lock()
	defer rae.cache.mutex.Unlock()

	if !rae.cache.enabled {
		return
	}

	// Check cache size limit
	if len(rae.cache.cache) >= rae.cache.maxSize {
		rae.evictOldestCacheEntries(rae.cache.maxSize / 4)
	}

	rae.cache.cache[vulnerabilityID] = result
	rae.cache.ttl[vulnerabilityID] = time.Now().Add(rae.config.CacheExpiration)
}

func (rae *RiskAssessmentEngine) evictOldestCacheEntries(count int) {
	// Simple LRU eviction based on TTL
	type cacheEntry struct {
		id  string
		ttl time.Time
	}

	entries := make([]cacheEntry, 0, len(rae.cache.ttl))
	for id, ttl := range rae.cache.ttl {
		entries = append(entries, cacheEntry{id: id, ttl: ttl})
	}

	// Sort by TTL (oldest first)
	for i := 0; i < len(entries); i++ {
		for j := i + 1; j < len(entries); j++ {
			if entries[i].ttl.After(entries[j].ttl) {
				entries[i], entries[j] = entries[j], entries[i]
			}
		}
	}

	// Remove oldest entries
	for i := 0; i < count && i < len(entries); i++ {
		id := entries[i].id
		delete(rae.cache.cache, id)
		delete(rae.cache.ttl, id)
	}
}

func (rae *RiskAssessmentEngine) updateCacheHitStats(hit bool) {
	rae.cache.mutex.Lock()
	defer rae.cache.mutex.Unlock()

	if hit {
		rae.cache.hitCount++
	} else {
		rae.cache.missCount++
	}
}

// updateStatistics updates risk assessment statistics
func (rae *RiskAssessmentEngine) updateStatistics(result *RiskAssessmentResult, componentErrors []error) {
	rae.mutex.Lock()
	defer rae.mutex.Unlock()

	rae.statistics.TotalAssessments++

	if len(componentErrors) == 0 {
		rae.statistics.SuccessfulAssessments++
	} else {
		rae.statistics.FailedAssessments++
	}

	// Update average assessment time
	totalTime := rae.statistics.AverageAssessmentTime * float64(rae.statistics.TotalAssessments-1)
	totalTime += result.ProcessingTime.Seconds()
	rae.statistics.AverageAssessmentTime = totalTime / float64(rae.statistics.TotalAssessments)

	// Update average risk score
	totalRisk := rae.statistics.AverageRiskScore * float64(rae.statistics.TotalAssessments-1)
	totalRisk += result.OverallRiskScore
	rae.statistics.AverageRiskScore = totalRisk / float64(rae.statistics.TotalAssessments)

	// Update risk level distribution
	rae.statistics.RiskLevelDistribution[result.RiskLevel]++

	// Update cache hit rate
	total := rae.cache.hitCount + rae.cache.missCount
	if total > 0 {
		rae.statistics.CacheHitRate = float64(rae.cache.hitCount) / float64(total)
	}

	rae.statistics.LastUpdate = time.Now()
}

// GetStatistics returns current risk assessment statistics
func (rae *RiskAssessmentEngine) GetStatistics() RiskAssessmentStatistics {
	rae.mutex.RLock()
	defer rae.mutex.RUnlock()
	return rae.statistics
}

// Close gracefully shuts down the risk assessment engine
func (rae *RiskAssessmentEngine) Close() error {
	rae.logger.Info("Shutting down risk assessment engine")

	// Clear cache
	rae.cache.mutex.Lock()
	rae.cache.cache = make(map[string]*RiskAssessmentResult)
	rae.cache.ttl = make(map[string]time.Time)
	rae.cache.mutex.Unlock()

	return nil
}
