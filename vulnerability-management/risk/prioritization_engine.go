package risk

import (
	"context"
	"fmt"
	"log/slog"
	"math"
	"sort"
	"strings"
	"sync"
	"time"
)

// PrioritizationEngine combines all risk assessment components to calculate final priority scores
type PrioritizationEngine struct {
	config          PrioritizationConfig
	logger          *slog.Logger
	riskCalculator  *RiskCalculator
	priorityMapper  *PriorityMapper
	contextAnalyzer *ContextAnalyzer
	weightingEngine *WeightingEngine
	decisionEngine  *DecisionEngine
	statistics      PrioritizationStatistics
	mutex           sync.RWMutex
}

// PrioritizationConfig defines configuration for the prioritization engine
type PrioritizationConfig struct {
	CalculationMethod     string                 `json:"calculation_method"`
	WeightingStrategy     string                 `json:"weighting_strategy"`
	NormalizationMethod   string                 `json:"normalization_method"`
	RiskTolerance        RiskToleranceProfile   `json:"risk_tolerance"`
	OrganizationProfile  OrganizationProfile    `json:"organization_profile"`
	
	// Calculation settings
	EnableContextualAdjustment bool               `json:"enable_contextual_adjustment"`
	EnableTemporalFactors      bool               `json:"enable_temporal_factors"`
	EnableBusinessAlignment    bool               `json:"enable_business_alignment"`
	EnableThreatLandscape      bool               `json:"enable_threat_landscape"`
	EnableResourceOptimization bool               `json:"enable_resource_optimization"`
	
	// Weighting configurations
	StaticWeights             ComponentWeights    `json:"static_weights"`
	DynamicWeightingEnabled   bool               `json:"dynamic_weighting_enabled"`
	ContextualWeights         map[string]ComponentWeights `json:"contextual_weights"`
	ThreatBasedWeights        map[string]float64  `json:"threat_based_weights"`
	
	// Priority mapping
	PriorityThresholds        PriorityThresholds  `json:"priority_thresholds"`
	CustomPriorityLevels     []CustomPriorityLevel `json:"custom_priority_levels"`
	PriorityEscalationRules  []EscalationRule    `json:"priority_escalation_rules"`
	
	// Temporal factors
	TimeDecayFactors         TimeDecayFactors    `json:"time_decay_factors"`
	SeasonalAdjustments      []SeasonalAdjustment `json:"seasonal_adjustments"`
	BusinessCycleFactors     []BusinessCycleFactor `json:"business_cycle_factors"`
	
	// Resource optimization
	ResourceConstraints      ResourceConstraints  `json:"resource_constraints"`
	CapacityPlanning        CapacityPlanning     `json:"capacity_planning"`
	CostBenefitThresholds   CostBenefitThresholds `json:"cost_benefit_thresholds"`
	
	// iSECTECH specific
	CustomRiskModels         []CustomRiskModel    `json:"custom_risk_models"`
	IndustryBenchmarks       map[string]float64   `json:"industry_benchmarks"`
	RegulatoryPriorities     map[string]float64   `json:"regulatory_priorities"`
	BusinessPriorities       []BusinessPriority   `json:"business_priorities"`
}

// PrioritizationResult contains the final prioritization results
type PrioritizationResult struct {
	VulnerabilityID          string                    `json:"vulnerability_id"`
	RiskScore               float64                   `json:"risk_score"`
	RiskLevel               string                    `json:"risk_level"`
	Priority                string                    `json:"priority"`
	PriorityScore           float64                   `json:"priority_score"`
	Confidence              float64                   `json:"confidence"`
	
	// Component contributions
	ComponentContributions   map[string]float64        `json:"component_contributions"`
	WeightedScores          map[string]float64        `json:"weighted_scores"`
	NormalizedScores        map[string]float64        `json:"normalized_scores"`
	
	// Contextual factors
	ContextualFactors       []ContextualFactor        `json:"contextual_factors"`
	TemporalFactors         []TemporalFactor          `json:"temporal_factors"`
	BusinessAlignmentFactors []BusinessAlignmentFactor `json:"business_alignment_factors"`
	ThreatLandscapeFactors  []ThreatLandscapeFactor   `json:"threat_landscape_factors"`
	
	// Risk assessment details
	RiskFactors             []RiskFactor              `json:"risk_factors"`
	MitigatingFactors       []MitigatingFactor        `json:"mitigating_factors"`
	AggravatingFactors      []AggravatingFactor       `json:"aggravating_factors"`
	
	// Prioritization justification
	PriorityJustification   []string                  `json:"priority_justification"`
	DecisionRationale       []string                  `json:"decision_rationale"`
	AlternativeActions      []AlternativeAction       `json:"alternative_actions"`
	
	// Resource and timeline
	ResourceRequirements    ResourceRequirements      `json:"resource_requirements"`
	TimelineRecommendation  TimelineRecommendation    `json:"timeline_recommendation"`
	CostBenefitAnalysis     CostBenefitAnalysis       `json:"cost_benefit_analysis"`
	
	// Metadata
	CalculationMethod       string                    `json:"calculation_method"`
	WeightingStrategy       string                    `json:"weighting_strategy"`
	ProcessingTime          time.Duration             `json:"processing_time"`
	Timestamp               time.Time                 `json:"timestamp"`
}

// Supporting data structures
type ComponentWeights struct {
	CVSSScore               float64 `json:"cvss_score"`
	BusinessImpact          float64 `json:"business_impact"`
	AssetCriticality        float64 `json:"asset_criticality"`
	ThreatIntelligence      float64 `json:"threat_intelligence"`
	Exploitability          float64 `json:"exploitability"`
	NetworkExposure         float64 `json:"network_exposure"`
	DataSensitivity         float64 `json:"data_sensitivity"`
	ComplianceImpact        float64 `json:"compliance_impact"`
	TemporalContext         float64 `json:"temporal_context"`
	BusinessContext         float64 `json:"business_context"`
}

type PriorityThresholds struct {
	Critical    float64 `json:"critical"`
	High        float64 `json:"high"`
	Medium      float64 `json:"medium"`
	Low         float64 `json:"low"`
	Minimal     float64 `json:"minimal"`
}

type CustomPriorityLevel struct {
	Level       string                 `json:"level"`
	Name        string                 `json:"name"`
	MinScore    float64                `json:"min_score"`
	MaxScore    float64                `json:"max_score"`
	Color       string                 `json:"color"`
	SLA         time.Duration          `json:"sla"`
	Actions     []string               `json:"actions"`
	Metadata    map[string]interface{} `json:"metadata"`
}

type EscalationRule struct {
	ID                string                 `json:"id"`
	Name              string                 `json:"name"`
	Conditions        []EscalationCondition  `json:"conditions"`
	PriorityAdjustment float64               `json:"priority_adjustment"`
	Notification       []string               `json:"notification"`
	Actions           []string               `json:"actions"`
	Enabled           bool                   `json:"enabled"`
	Metadata          map[string]interface{} `json:"metadata"`
}

type EscalationCondition struct {
	Field     string      `json:"field"`
	Operator  string      `json:"operator"`
	Value     interface{} `json:"value"`
	LogicalOp string      `json:"logical_op,omitempty"`
}

type TimeDecayFactors struct {
	VulnerabilityAge       float64 `json:"vulnerability_age"`
	ExploitAge             float64 `json:"exploit_age"`
	ThreatIntelligenceAge  float64 `json:"threat_intelligence_age"`
	PatchAvailabilityAge   float64 `json:"patch_availability_age"`
	DisclosureAge          float64 `json:"disclosure_age"`
}

type SeasonalAdjustment struct {
	Period      string    `json:"period"`
	StartDate   time.Time `json:"start_date"`
	EndDate     time.Time `json:"end_date"`
	Multiplier  float64   `json:"multiplier"`
	Components  []string  `json:"components"`
	Description string    `json:"description"`
}

type BusinessCycleFactor struct {
	Phase       string    `json:"phase"`
	Multiplier  float64   `json:"multiplier"`
	Duration    time.Duration `json:"duration"`
	Description string    `json:"description"`
}

type ResourceConstraints struct {
	SecurityTeamCapacity   float64 `json:"security_team_capacity"`
	ITOpsCapacity         float64 `json:"itops_capacity"`
	DevelopmentCapacity   float64 `json:"development_capacity"`
	BudgetConstraints     float64 `json:"budget_constraints"`
	MaintenanceWindows    []string `json:"maintenance_windows"`
	VendorAvailability    map[string]float64 `json:"vendor_availability"`
}

type CapacityPlanning struct {
	MaxConcurrentRemediation int               `json:"max_concurrent_remediation"`
	AverageRemediationTime   time.Duration     `json:"average_remediation_time"`
	ResourceAllocation       map[string]float64 `json:"resource_allocation"`
	PriorityQueues          map[string]int     `json:"priority_queues"`
}

type CostBenefitThresholds struct {
	MinROI              float64 `json:"min_roi"`
	MaxCost             float64 `json:"max_cost"`
	PaybackPeriod       time.Duration `json:"payback_period"`
	RiskReductionMin    float64 `json:"risk_reduction_min"`
}

type BusinessPriority struct {
	Name        string                 `json:"name"`
	Weight      float64                `json:"weight"`
	Duration    time.Duration          `json:"duration"`
	Components  []string               `json:"components"`
	Conditions  []BusinessCondition    `json:"conditions"`
	Metadata    map[string]interface{} `json:"metadata"`
}

type ContextualFactor struct {
	Type        string                 `json:"type"`
	Description string                 `json:"description"`
	Impact      float64                `json:"impact"`
	Confidence  float64                `json:"confidence"`
	Source      string                 `json:"source"`
	Metadata    map[string]interface{} `json:"metadata"`
}

type TemporalFactor struct {
	Type           string                 `json:"type"`
	Description    string                 `json:"description"`
	TimeMultiplier float64                `json:"time_multiplier"`
	Duration       time.Duration          `json:"duration"`
	Urgency        string                 `json:"urgency"`
	Metadata       map[string]interface{} `json:"metadata"`
}

type BusinessAlignmentFactor struct {
	Objective   string                 `json:"objective"`
	Alignment   float64                `json:"alignment"`
	Impact      float64                `json:"impact"`
	Priority    string                 `json:"priority"`
	Metadata    map[string]interface{} `json:"metadata"`
}

type ThreatLandscapeFactor struct {
	ThreatType     string                 `json:"threat_type"`
	Activity       string                 `json:"activity"`
	Relevance      float64                `json:"relevance"`
	Intelligence   string                 `json:"intelligence"`
	Confidence     float64                `json:"confidence"`
	Metadata       map[string]interface{} `json:"metadata"`
}

type AlternativeAction struct {
	Action         string                 `json:"action"`
	Priority       string                 `json:"priority"`
	Effort         string                 `json:"effort"`
	RiskReduction  float64                `json:"risk_reduction"`
	Cost           float64                `json:"cost"`
	Timeline       time.Duration          `json:"timeline"`
	Trade          []string               `json:"tradeoffs"`
	Metadata       map[string]interface{} `json:"metadata"`
}

type ResourceRequirements struct {
	SecurityAnalyst   float64       `json:"security_analyst"`
	ITOperations     float64       `json:"it_operations"`
	Development      float64       `json:"development"`
	ProjectManager   float64       `json:"project_manager"`
	Budget           float64       `json:"budget"`
	Tools            []string      `json:"tools"`
	Skills           []string      `json:"skills"`
	ExternalSupport  []string      `json:"external_support"`
	Timeline         time.Duration `json:"timeline"`
}

type TimelineRecommendation struct {
	ImmediateActions  []string      `json:"immediate_actions"`
	ShortTerm         []string      `json:"short_term"`
	MediumTerm        []string      `json:"medium_term"`
	LongTerm          []string      `json:"long_term"`
	Milestones        []Milestone   `json:"milestones"`
	Dependencies      []string      `json:"dependencies"`
	CriticalPath      []string      `json:"critical_path"`
}

type Milestone struct {
	Name        string        `json:"name"`
	Deadline    time.Time     `json:"deadline"`
	Deliverable string        `json:"deliverable"`
	Success     []string      `json:"success_criteria"`
	Risks       []string      `json:"risks"`
}

type CostBenefitAnalysis struct {
	InitialCost         float64       `json:"initial_cost"`
	OngoingCost         float64       `json:"ongoing_cost"`
	RiskReduction       float64       `json:"risk_reduction"`
	BusinessValue       float64       `json:"business_value"`
	ROI                 float64       `json:"roi"`
	PaybackPeriod       time.Duration `json:"payback_period"`
	NetPresentValue     float64       `json:"net_present_value"`
	BreakEvenPoint      time.Duration `json:"break_even_point"`
	SensitivityAnalysis map[string]float64 `json:"sensitivity_analysis"`
}

type PrioritizationStatistics struct {
	TotalPrioritizations    int64                    `json:"total_prioritizations"`
	PriorityDistribution    map[string]int64         `json:"priority_distribution"`
	AverageRiskScore        float64                  `json:"average_risk_score"`
	AveragePriorityScore    float64                  `json:"average_priority_score"`
	AverageProcessingTime   float64                  `json:"average_processing_time"`
	ComponentContributions  map[string]float64       `json:"component_contributions"`
	MethodPerformance       map[string]MethodStat    `json:"method_performance"`
	WeightingEffectiveness  map[string]float64       `json:"weighting_effectiveness"`
	LastUpdate              time.Time                `json:"last_update"`
}

type MethodStat struct {
	Usage       int64   `json:"usage"`
	SuccessRate float64 `json:"success_rate"`
	AvgTime     float64 `json:"avg_time"`
	AvgScore    float64 `json:"avg_score"`
}

// Sub-engines
type RiskCalculator struct {
	config PrioritizationConfig
	logger *slog.Logger
}

type PriorityMapper struct {
	config PrioritizationConfig
	logger *slog.Logger
}

type ContextAnalyzer struct {
	config PrioritizationConfig
	logger *slog.Logger
}

type WeightingEngine struct {
	config PrioritizationConfig
	logger *slog.Logger
}

type DecisionEngine struct {
	config PrioritizationConfig
	logger *slog.Logger
}

// NewPrioritizationEngine creates a new prioritization engine
func NewPrioritizationEngine(config PrioritizationConfig, logger *slog.Logger) (*PrioritizationEngine, error) {
	if logger == nil {
		logger = slog.Default()
	}

	engine := &PrioritizationEngine{
		config: config,
		logger: logger,
		statistics: PrioritizationStatistics{
			PriorityDistribution:   make(map[string]int64),
			ComponentContributions: make(map[string]float64),
			MethodPerformance:      make(map[string]MethodStat),
			WeightingEffectiveness: make(map[string]float64),
			LastUpdate:             time.Now(),
		},
	}

	// Initialize sub-engines
	if err := engine.initializeEngines(); err != nil {
		return nil, fmt.Errorf("failed to initialize sub-engines: %w", err)
	}

	return engine, nil
}

// CalculateOverallRisk performs comprehensive risk prioritization
func (pe *PrioritizationEngine) CalculateOverallRisk(ctx context.Context, assessmentResult *RiskAssessmentResult, vuln *Vulnerability) (*PrioritizationResult, error) {
	startTime := time.Now()

	result := &PrioritizationResult{
		VulnerabilityID:         assessmentResult.VulnerabilityID,
		ComponentContributions:  make(map[string]float64),
		WeightedScores:         make(map[string]float64),
		NormalizedScores:       make(map[string]float64),
		ContextualFactors:      make([]ContextualFactor, 0),
		TemporalFactors:        make([]TemporalFactor, 0),
		BusinessAlignmentFactors: make([]BusinessAlignmentFactor, 0),
		ThreatLandscapeFactors: make([]ThreatLandscapeFactor, 0),
		RiskFactors:            assessmentResult.RiskFactors,
		MitigatingFactors:      assessmentResult.MitigatingFactors,
		AggravatingFactors:     assessmentResult.AggravatingFactors,
		PriorityJustification:  make([]string, 0),
		DecisionRationale:      make([]string, 0),
		AlternativeActions:     make([]AlternativeAction, 0),
		CalculationMethod:      pe.config.CalculationMethod,
		WeightingStrategy:      pe.config.WeightingStrategy,
		Timestamp:              time.Now(),
	}

	// Extract and normalize component scores
	componentScores := pe.extractComponentScores(assessmentResult)
	result.NormalizedScores = pe.normalizeScores(componentScores)

	// Determine appropriate weights
	weights := pe.determineWeights(ctx, assessmentResult, vuln, result)

	// Calculate weighted scores
	result.WeightedScores = pe.calculateWeightedScores(result.NormalizedScores, weights)

	// Apply contextual adjustments
	if pe.config.EnableContextualAdjustment {
		pe.applyContextualAdjustments(ctx, result, assessmentResult, vuln)
	}

	// Apply temporal factors
	if pe.config.EnableTemporalFactors {
		pe.applyTemporalFactors(ctx, result, assessmentResult, vuln)
	}

	// Apply business alignment factors
	if pe.config.EnableBusinessAlignment {
		pe.applyBusinessAlignmentFactors(ctx, result, assessmentResult, vuln)
	}

	// Apply threat landscape factors
	if pe.config.EnableThreatLandscape {
		pe.applyThreatLandscapeFactors(ctx, result, assessmentResult, vuln)
	}

	// Calculate final risk score
	result.RiskScore = pe.calculateFinalRiskScore(result)

	// Map to priority levels
	result.RiskLevel = pe.mapRiskLevel(result.RiskScore)
	result.Priority = pe.mapPriority(result.RiskScore, result)
	result.PriorityScore = pe.calculatePriorityScore(result)

	// Calculate confidence
	result.Confidence = pe.calculateOverallConfidence(result, assessmentResult)

	// Apply escalation rules
	pe.applyEscalationRules(result, assessmentResult, vuln)

	// Generate justification and rationale
	pe.generatePriorityJustification(result, assessmentResult, vuln)
	pe.generateDecisionRationale(result, assessmentResult, vuln)

	// Generate alternative actions
	pe.generateAlternativeActions(result, assessmentResult, vuln)

	// Calculate resource requirements
	result.ResourceRequirements = pe.calculateResourceRequirements(result, assessmentResult, vuln)

	// Generate timeline recommendation
	result.TimelineRecommendation = pe.generateTimelineRecommendation(result, assessmentResult, vuln)

	// Perform cost-benefit analysis
	result.CostBenefitAnalysis = pe.performCostBenefitAnalysis(result, assessmentResult, vuln)

	result.ProcessingTime = time.Since(startTime)

	// Update statistics
	pe.updateStatistics(result)

	pe.logger.Info("Risk prioritization completed",
		"vulnerability_id", result.VulnerabilityID,
		"risk_score", result.RiskScore,
		"risk_level", result.RiskLevel,
		"priority", result.Priority,
		"processing_time", result.ProcessingTime)

	return result, nil
}

// initializeEngines initializes sub-engines
func (pe *PrioritizationEngine) initializeEngines() error {
	pe.riskCalculator = &RiskCalculator{
		config: pe.config,
		logger: pe.logger,
	}

	pe.priorityMapper = &PriorityMapper{
		config: pe.config,
		logger: pe.logger,
	}

	pe.contextAnalyzer = &ContextAnalyzer{
		config: pe.config,
		logger: pe.logger,
	}

	pe.weightingEngine = &WeightingEngine{
		config: pe.config,
		logger: pe.logger,
	}

	pe.decisionEngine = &DecisionEngine{
		config: pe.config,
		logger: pe.logger,
	}

	return nil
}

// extractComponentScores extracts scores from assessment result
func (pe *PrioritizationEngine) extractComponentScores(assessmentResult *RiskAssessmentResult) map[string]float64 {
	scores := make(map[string]float64)

	// Extract CVSS score from vulnerability
	if assessmentResult.VulnerabilityID != "" {
		// CVSS would be extracted from vulnerability context
		scores["cvss"] = 7.0 // Default value, would be extracted from actual vulnerability
	}

	// Business Impact
	if assessmentResult.BusinessImpact != nil {
		scores["business_impact"] = assessmentResult.BusinessImpact.ImpactScore
	}

	// Asset Criticality
	if assessmentResult.AssetCriticality != nil {
		scores["asset_criticality"] = assessmentResult.AssetCriticality.CriticalityScore
	}

	// Threat Intelligence
	if assessmentResult.ThreatIntelligence != nil {
		scores["threat_intelligence"] = assessmentResult.ThreatIntelligence.ThreatScore
	}

	// Exploitability
	if assessmentResult.Exploitability != nil {
		scores["exploitability"] = assessmentResult.Exploitability.ExploitabilityScore
	}

	// Compliance Impact
	if assessmentResult.ComplianceImpact != nil {
		scores["compliance_impact"] = assessmentResult.ComplianceImpact.ComplianceScore
	}

	// Set default values for missing components
	defaultScores := map[string]float64{
		"cvss":                5.0,
		"business_impact":     5.0,
		"asset_criticality":   5.0,
		"threat_intelligence": 5.0,
		"exploitability":      5.0,
		"network_exposure":    5.0,
		"data_sensitivity":    5.0,
		"compliance_impact":   5.0,
	}

	for component, defaultScore := range defaultScores {
		if _, exists := scores[component]; !exists {
			scores[component] = defaultScore
		}
	}

	return scores
}

// normalizeScores normalizes component scores to a standard scale
func (pe *PrioritizationEngine) normalizeScores(scores map[string]float64) map[string]float64 {
	normalized := make(map[string]float64)

	switch pe.config.NormalizationMethod {
	case "min_max":
		// Min-Max normalization to 0-1 scale
		for component, score := range scores {
			normalized[component] = math.Max(0, math.Min(1, score/10.0))
		}
	case "z_score":
		// Z-score normalization (simplified)
		mean := pe.calculateMean(scores)
		stddev := pe.calculateStdDev(scores, mean)
		for component, score := range scores {
			if stddev > 0 {
				normalized[component] = (score - mean) / stddev
			} else {
				normalized[component] = 0.5
			}
		}
	case "percentile":
		// Percentile-based normalization
		values := make([]float64, 0, len(scores))
		for _, score := range scores {
			values = append(values, score)
		}
		sort.Float64s(values)
		
		for component, score := range scores {
			percentile := pe.calculatePercentile(score, values)
			normalized[component] = percentile / 100.0
		}
	default:
		// Default: simple 0-10 to 0-1 scaling
		for component, score := range scores {
			normalized[component] = math.Max(0, math.Min(1, score/10.0))
		}
	}

	return normalized
}

// determineWeights determines appropriate weights based on context
func (pe *PrioritizationEngine) determineWeights(ctx context.Context, assessmentResult *RiskAssessmentResult, vuln *Vulnerability, result *PrioritizationResult) ComponentWeights {
	if pe.config.DynamicWeightingEnabled {
		return pe.calculateDynamicWeights(ctx, assessmentResult, vuln, result)
	}

	// Use static weights with contextual adjustments
	weights := pe.config.StaticWeights

	// Apply contextual weight adjustments
	for context, contextWeights := range pe.config.ContextualWeights {
		if pe.contextMatches(context, assessmentResult, vuln) {
			weights = pe.mergeWeights(weights, contextWeights)
		}
	}

	return weights
}

// calculateDynamicWeights calculates weights based on current context
func (pe *PrioritizationEngine) calculateDynamicWeights(ctx context.Context, assessmentResult *RiskAssessmentResult, vuln *Vulnerability, result *PrioritizationResult) ComponentWeights {
	weights := pe.config.StaticWeights

	// Adjust weights based on threat landscape
	if pe.config.EnableThreatLandscape {
		threatWeights := pe.calculateThreatBasedWeights(assessmentResult, vuln)
		weights = pe.mergeWeights(weights, ComponentWeights{
			ThreatIntelligence: threatWeights["threat_intelligence"],
			Exploitability:     threatWeights["exploitability"],
		})
	}

	// Adjust weights based on business context
	if pe.config.EnableBusinessAlignment {
		businessWeights := pe.calculateBusinessBasedWeights(assessmentResult)
		weights = pe.mergeWeights(weights, ComponentWeights{
			BusinessImpact:   businessWeights["business_impact"],
			AssetCriticality: businessWeights["asset_criticality"],
		})
	}

	// Adjust weights based on resource constraints
	if pe.config.EnableResourceOptimization {
		resourceWeights := pe.calculateResourceBasedWeights()
		weights = pe.mergeWeights(weights, resourceWeights)
	}

	// Normalize weights to sum to 1.0
	return pe.normalizeWeights(weights)
}

// calculateWeightedScores calculates weighted component scores
func (pe *PrioritizationEngine) calculateWeightedScores(normalizedScores map[string]float64, weights ComponentWeights) map[string]float64 {
	weightedScores := make(map[string]float64)

	weightMap := map[string]float64{
		"cvss":                weights.CVSSScore,
		"business_impact":     weights.BusinessImpact,
		"asset_criticality":   weights.AssetCriticality,
		"threat_intelligence": weights.ThreatIntelligence,
		"exploitability":      weights.Exploitability,
		"network_exposure":    weights.NetworkExposure,
		"data_sensitivity":    weights.DataSensitivity,
		"compliance_impact":   weights.ComplianceImpact,
	}

	for component, normalizedScore := range normalizedScores {
		if weight, exists := weightMap[component]; exists {
			weightedScores[component] = normalizedScore * weight
		}
	}

	return weightedScores
}

// applyContextualAdjustments applies contextual adjustments to scores
func (pe *PrioritizationEngine) applyContextualAdjustments(ctx context.Context, result *PrioritizationResult, assessmentResult *RiskAssessmentResult, vuln *Vulnerability) {
	factors := make([]ContextualFactor, 0)

	// External facing adjustment
	if vuln != nil && vuln.NetworkContext.IsExternalFacing {
		factors = append(factors, ContextualFactor{
			Type:        "network_exposure",
			Description: "Asset is externally facing, increasing attack surface",
			Impact:      1.2,
			Confidence:  0.9,
			Source:      "network_analysis",
		})
	}

	// Business hours adjustment
	if pe.isDuringBusinessHours() {
		factors = append(factors, ContextualFactor{
			Type:        "business_hours",
			Description: "Vulnerability discovered during business hours",
			Impact:      1.1,
			Confidence:  0.8,
			Source:      "temporal_analysis",
		})
	}

	// High-profile vulnerability adjustment
	if vuln != nil && vuln.CVE != "" && pe.isHighProfileCVE(vuln.CVE) {
		factors = append(factors, ContextualFactor{
			Type:        "high_profile_cve",
			Description: "High-profile CVE with public attention",
			Impact:      1.3,
			Confidence:  0.9,
			Source:      "threat_intelligence",
		})
	}

	// Apply adjustments to weighted scores
	for _, factor := range factors {
		pe.applyContextualFactor(result, factor)
	}

	result.ContextualFactors = factors
}

// applyTemporalFactors applies time-based factors
func (pe *PrioritizationEngine) applyTemporalFactors(ctx context.Context, result *PrioritizationResult, assessmentResult *RiskAssessmentResult, vuln *Vulnerability) {
	factors := make([]TemporalFactor, 0)

	// Vulnerability age factor
	if vuln != nil {
		age := time.Since(vuln.DiscoveryTime)
		ageMultiplier := pe.calculateAgeMultiplier(age, pe.config.TimeDecayFactors.VulnerabilityAge)
		
		factors = append(factors, TemporalFactor{
			Type:           "vulnerability_age",
			Description:    fmt.Sprintf("Vulnerability discovered %.0f hours ago", age.Hours()),
			TimeMultiplier: ageMultiplier,
			Duration:       age,
			Urgency:        pe.determineAgeUrgency(age),
		})

		// Apply age multiplier to time-sensitive components
		pe.applyTemporalMultiplier(result, "exploitability", ageMultiplier)
		pe.applyTemporalMultiplier(result, "threat_intelligence", ageMultiplier)
	}

	// Seasonal adjustments
	for _, adjustment := range pe.config.SeasonalAdjustments {
		if pe.isInSeasonalPeriod(adjustment) {
			factors = append(factors, TemporalFactor{
				Type:           "seasonal",
				Description:    fmt.Sprintf("Seasonal adjustment: %s", adjustment.Description),
				TimeMultiplier: adjustment.Multiplier,
				Duration:       adjustment.EndDate.Sub(adjustment.StartDate),
				Urgency:        pe.determineSeasonalUrgency(adjustment.Multiplier),
			})

			// Apply seasonal multiplier to specified components
			for _, component := range adjustment.Components {
				pe.applyTemporalMultiplier(result, component, adjustment.Multiplier)
			}
		}
	}

	result.TemporalFactors = factors
}

// applyBusinessAlignmentFactors applies business alignment factors
func (pe *PrioritizationEngine) applyBusinessAlignmentFactors(ctx context.Context, result *PrioritizationResult, assessmentResult *RiskAssessmentResult, vuln *Vulnerability) {
	factors := make([]BusinessAlignmentFactor, 0)

	// Check alignment with business priorities
	for _, priority := range pe.config.BusinessPriorities {
		alignment := pe.calculateBusinessAlignment(priority, assessmentResult, vuln)
		if alignment > 0.1 {
			factors = append(factors, BusinessAlignmentFactor{
				Objective: priority.Name,
				Alignment: alignment,
				Impact:    priority.Weight * alignment,
				Priority:  pe.determinePriorityLevel(priority.Weight),
			})

			// Apply business priority multiplier
			businessMultiplier := 1.0 + (priority.Weight * alignment * 0.2)
			for _, component := range priority.Components {
				pe.applyBusinessMultiplier(result, component, businessMultiplier)
			}
		}
	}

	result.BusinessAlignmentFactors = factors
}

// applyThreatLandscapeFactors applies threat landscape factors
func (pe *PrioritizationEngine) applyThreatLandscapeFactors(ctx context.Context, result *PrioritizationResult, assessmentResult *RiskAssessmentResult, vuln *Vulnerability) {
	factors := make([]ThreatLandscapeFactor, 0)

	// Active threat campaigns
	if pe.hasActiveThreatCampaigns(vuln) {
		factors = append(factors, ThreatLandscapeFactor{
			ThreatType:  "active_campaign",
			Activity:    "high",
			Relevance:   0.9,
			Intelligence: "confirmed",
			Confidence:  0.8,
		})

		// Increase threat intelligence and exploitability weights
		pe.applyThreatMultiplier(result, "threat_intelligence", 1.4)
		pe.applyThreatMultiplier(result, "exploitability", 1.3)
	}

	// Industry-specific threats
	if pe.hasIndustrySpecificThreats() {
		factors = append(factors, ThreatLandscapeFactor{
			ThreatType:  "industry_specific",
			Activity:    "medium",
			Relevance:   0.7,
			Intelligence: "assessed",
			Confidence:  0.7,
		})

		pe.applyThreatMultiplier(result, "business_impact", 1.2)
	}

	result.ThreatLandscapeFactors = factors
}

// calculateFinalRiskScore calculates the final risk score
func (pe *PrioritizationEngine) calculateFinalRiskScore(result *PrioritizationResult) float64 {
	switch pe.config.CalculationMethod {
	case "weighted_average":
		return pe.calculateWeightedAverage(result.WeightedScores)
	case "geometric_mean":
		return pe.calculateGeometricMean(result.WeightedScores)
	case "harmonic_mean":
		return pe.calculateHarmonicMean(result.WeightedScores)
	case "max_component":
		return pe.calculateMaxComponent(result.WeightedScores)
	case "composite_risk":
		return pe.calculateCompositeRisk(result)
	default:
		return pe.calculateWeightedAverage(result.WeightedScores)
	}
}

// Risk calculation methods
func (pe *PrioritizationEngine) calculateWeightedAverage(weightedScores map[string]float64) float64 {
	total := 0.0
	count := 0
	for _, score := range weightedScores {
		total += score
		count++
	}
	if count > 0 {
		return total / float64(count)
	}
	return 0.0
}

func (pe *PrioritizationEngine) calculateGeometricMean(weightedScores map[string]float64) float64 {
	product := 1.0
	count := 0
	for _, score := range weightedScores {
		if score > 0 {
			product *= score
			count++
		}
	}
	if count > 0 {
		return math.Pow(product, 1.0/float64(count))
	}
	return 0.0
}

func (pe *PrioritizationEngine) calculateHarmonicMean(weightedScores map[string]float64) float64 {
	sum := 0.0
	count := 0
	for _, score := range weightedScores {
		if score > 0 {
			sum += 1.0 / score
			count++
		}
	}
	if count > 0 && sum > 0 {
		return float64(count) / sum
	}
	return 0.0
}

func (pe *PrioritizationEngine) calculateMaxComponent(weightedScores map[string]float64) float64 {
	maxScore := 0.0
	for _, score := range weightedScores {
		if score > maxScore {
			maxScore = score
		}
	}
	return maxScore
}

func (pe *PrioritizationEngine) calculateCompositeRisk(result *PrioritizationResult) float64 {
	// Complex composite risk calculation
	baseScore := pe.calculateWeightedAverage(result.WeightedScores)
	
	// Apply contextual adjustments
	contextMultiplier := 1.0
	for _, factor := range result.ContextualFactors {
		contextMultiplier *= factor.Impact
	}
	
	// Apply temporal adjustments
	temporalMultiplier := 1.0
	for _, factor := range result.TemporalFactors {
		temporalMultiplier *= factor.TimeMultiplier
	}
	
	// Apply business alignment adjustments
	businessMultiplier := 1.0
	for _, factor := range result.BusinessAlignmentFactors {
		businessMultiplier += factor.Impact * 0.1
	}
	
	compositeScore := baseScore * contextMultiplier * temporalMultiplier * businessMultiplier
	return math.Min(compositeScore, 1.0)
}

// Priority mapping methods
func (pe *PrioritizationEngine) mapRiskLevel(riskScore float64) string {
	if riskScore >= 0.8 {
		return "critical"
	} else if riskScore >= 0.6 {
		return "high"
	} else if riskScore >= 0.4 {
		return "medium"
	} else if riskScore >= 0.2 {
		return "low"
	}
	return "minimal"
}

func (pe *PrioritizationEngine) mapPriority(riskScore float64, result *PrioritizationResult) string {
	// Convert normalized risk score to 0-10 scale for threshold comparison
	scaledScore := riskScore * 10.0

	if scaledScore >= pe.config.PriorityThresholds.Critical {
		return "P0"
	} else if scaledScore >= pe.config.PriorityThresholds.High {
		return "P1"
	} else if scaledScore >= pe.config.PriorityThresholds.Medium {
		return "P2"
	} else if scaledScore >= pe.config.PriorityThresholds.Low {
		return "P3"
	}
	return "P4"
}

func (pe *PrioritizationEngine) calculatePriorityScore(result *PrioritizationResult) float64 {
	// Priority score is derived from risk score with adjustments
	baseScore := result.RiskScore * 10.0

	// Apply priority-specific adjustments
	switch result.Priority {
	case "P0":
		baseScore += 2.0
	case "P1":
		baseScore += 1.0
	case "P3":
		baseScore -= 1.0
	case "P4":
		baseScore -= 2.0
	}

	return math.Min(baseScore, 10.0)
}

// Confidence calculation
func (pe *PrioritizationEngine) calculateOverallConfidence(result *PrioritizationResult, assessmentResult *RiskAssessmentResult) float64 {
	confidences := make([]float64, 0)

	// Component confidences
	if assessmentResult.BusinessImpact != nil {
		confidences = append(confidences, assessmentResult.BusinessImpact.Confidence)
	}
	if assessmentResult.AssetCriticality != nil {
		confidences = append(confidences, assessmentResult.AssetCriticality.Confidence)
	}
	if assessmentResult.ThreatIntelligence != nil {
		confidences = append(confidences, assessmentResult.ThreatIntelligence.Confidence)
	}

	// Contextual factor confidences
	for _, factor := range result.ContextualFactors {
		confidences = append(confidences, factor.Confidence)
	}

	// Calculate average confidence
	if len(confidences) > 0 {
		total := 0.0
		for _, conf := range confidences {
			total += conf
		}
		return total / float64(len(confidences))
	}

	return 0.7 // Default confidence
}

// Helper methods (simplified implementations)
func (pe *PrioritizationEngine) calculateMean(scores map[string]float64) float64 {
	total := 0.0
	count := 0
	for _, score := range scores {
		total += score
		count++
	}
	if count > 0 {
		return total / float64(count)
	}
	return 0.0
}

func (pe *PrioritizationEngine) calculateStdDev(scores map[string]float64, mean float64) float64 {
	sum := 0.0
	count := 0
	for _, score := range scores {
		sum += math.Pow(score-mean, 2)
		count++
	}
	if count > 1 {
		return math.Sqrt(sum / float64(count-1))
	}
	return 1.0
}

func (pe *PrioritizationEngine) calculatePercentile(value float64, sortedValues []float64) float64 {
	count := 0
	for _, v := range sortedValues {
		if v <= value {
			count++
		}
	}
	return float64(count) / float64(len(sortedValues)) * 100.0
}

func (pe *PrioritizationEngine) contextMatches(context string, assessmentResult *RiskAssessmentResult, vuln *Vulnerability) bool {
	// Simplified context matching
	switch context {
	case "high_business_impact":
		return assessmentResult.BusinessImpact != nil && assessmentResult.BusinessImpact.ImpactScore >= 8.0
	case "external_facing":
		return vuln != nil && vuln.NetworkContext.IsExternalFacing
	case "critical_asset":
		return assessmentResult.AssetCriticality != nil && assessmentResult.AssetCriticality.CriticalityScore >= 8.0
	default:
		return false
	}
}

func (pe *PrioritizationEngine) mergeWeights(base, adjustment ComponentWeights) ComponentWeights {
	return ComponentWeights{
		CVSSScore:          pe.mergeWeight(base.CVSSScore, adjustment.CVSSScore),
		BusinessImpact:     pe.mergeWeight(base.BusinessImpact, adjustment.BusinessImpact),
		AssetCriticality:   pe.mergeWeight(base.AssetCriticality, adjustment.AssetCriticality),
		ThreatIntelligence: pe.mergeWeight(base.ThreatIntelligence, adjustment.ThreatIntelligence),
		Exploitability:     pe.mergeWeight(base.Exploitability, adjustment.Exploitability),
		NetworkExposure:    pe.mergeWeight(base.NetworkExposure, adjustment.NetworkExposure),
		DataSensitivity:    pe.mergeWeight(base.DataSensitivity, adjustment.DataSensitivity),
		ComplianceImpact:   pe.mergeWeight(base.ComplianceImpact, adjustment.ComplianceImpact),
	}
}

func (pe *PrioritizationEngine) mergeWeight(base, adjustment float64) float64 {
	if adjustment > 0 {
		return (base + adjustment) / 2.0
	}
	return base
}

func (pe *PrioritizationEngine) normalizeWeights(weights ComponentWeights) ComponentWeights {
	total := weights.CVSSScore + weights.BusinessImpact + weights.AssetCriticality +
		weights.ThreatIntelligence + weights.Exploitability + weights.NetworkExposure +
		weights.DataSensitivity + weights.ComplianceImpact

	if total > 0 {
		return ComponentWeights{
			CVSSScore:          weights.CVSSScore / total,
			BusinessImpact:     weights.BusinessImpact / total,
			AssetCriticality:   weights.AssetCriticality / total,
			ThreatIntelligence: weights.ThreatIntelligence / total,
			Exploitability:     weights.Exploitability / total,
			NetworkExposure:    weights.NetworkExposure / total,
			DataSensitivity:    weights.DataSensitivity / total,
			ComplianceImpact:   weights.ComplianceImpact / total,
		}
	}

	// Default equal weights
	equalWeight := 1.0 / 8.0
	return ComponentWeights{
		CVSSScore:          equalWeight,
		BusinessImpact:     equalWeight,
		AssetCriticality:   equalWeight,
		ThreatIntelligence: equalWeight,
		Exploitability:     equalWeight,
		NetworkExposure:    equalWeight,
		DataSensitivity:    equalWeight,
		ComplianceImpact:   equalWeight,
	}
}

// Additional helper methods (simplified implementations)
func (pe *PrioritizationEngine) isDuringBusinessHours() bool { return true }
func (pe *PrioritizationEngine) isHighProfileCVE(cve string) bool { return strings.Contains(cve, "2024") }
func (pe *PrioritizationEngine) applyContextualFactor(result *PrioritizationResult, factor ContextualFactor) {}
func (pe *PrioritizationEngine) calculateAgeMultiplier(age time.Duration, decayFactor float64) float64 { return 1.0 + (decayFactor * age.Hours() / 24.0) }
func (pe *PrioritizationEngine) determineAgeUrgency(age time.Duration) string { 
	if age < time.Hour*24 { return "high" }
	return "medium"
}
func (pe *PrioritizationEngine) applyTemporalMultiplier(result *PrioritizationResult, component string, multiplier float64) {}
func (pe *PrioritizationEngine) isInSeasonalPeriod(adjustment SeasonalAdjustment) bool { return false }
func (pe *PrioritizationEngine) determineSeasonalUrgency(multiplier float64) string { return "medium" }
func (pe *PrioritizationEngine) calculateBusinessAlignment(priority BusinessPriority, assessmentResult *RiskAssessmentResult, vuln *Vulnerability) float64 { return 0.5 }
func (pe *PrioritizationEngine) determinePriorityLevel(weight float64) string { return "medium" }
func (pe *PrioritizationEngine) applyBusinessMultiplier(result *PrioritizationResult, component string, multiplier float64) {}
func (pe *PrioritizationEngine) hasActiveThreatCampaigns(vuln *Vulnerability) bool { return false }
func (pe *PrioritizationEngine) hasIndustrySpecificThreats() bool { return false }
func (pe *PrioritizationEngine) applyThreatMultiplier(result *PrioritizationResult, component string, multiplier float64) {}
func (pe *PrioritizationEngine) calculateThreatBasedWeights(assessmentResult *RiskAssessmentResult, vuln *Vulnerability) map[string]float64 { return make(map[string]float64) }
func (pe *PrioritizationEngine) calculateBusinessBasedWeights(assessmentResult *RiskAssessmentResult) map[string]float64 { return make(map[string]float64) }
func (pe *PrioritizationEngine) calculateResourceBasedWeights() ComponentWeights { return ComponentWeights{} }
func (pe *PrioritizationEngine) applyEscalationRules(result *PrioritizationResult, assessmentResult *RiskAssessmentResult, vuln *Vulnerability) {}
func (pe *PrioritizationEngine) generatePriorityJustification(result *PrioritizationResult, assessmentResult *RiskAssessmentResult, vuln *Vulnerability) {}
func (pe *PrioritizationEngine) generateDecisionRationale(result *PrioritizationResult, assessmentResult *RiskAssessmentResult, vuln *Vulnerability) {}
func (pe *PrioritizationEngine) generateAlternativeActions(result *PrioritizationResult, assessmentResult *RiskAssessmentResult, vuln *Vulnerability) {}
func (pe *PrioritizationEngine) calculateResourceRequirements(result *PrioritizationResult, assessmentResult *RiskAssessmentResult, vuln *Vulnerability) ResourceRequirements { return ResourceRequirements{} }
func (pe *PrioritizationEngine) generateTimelineRecommendation(result *PrioritizationResult, assessmentResult *RiskAssessmentResult, vuln *Vulnerability) TimelineRecommendation { return TimelineRecommendation{} }
func (pe *PrioritizationEngine) performCostBenefitAnalysis(result *PrioritizationResult, assessmentResult *RiskAssessmentResult, vuln *Vulnerability) CostBenefitAnalysis { return CostBenefitAnalysis{} }

func (pe *PrioritizationEngine) updateStatistics(result *PrioritizationResult) {
	pe.mutex.Lock()
	defer pe.mutex.Unlock()

	pe.statistics.TotalPrioritizations++
	pe.statistics.PriorityDistribution[result.Priority]++

	// Update averages
	totalRisk := pe.statistics.AverageRiskScore * float64(pe.statistics.TotalPrioritizations-1)
	totalRisk += result.RiskScore
	pe.statistics.AverageRiskScore = totalRisk / float64(pe.statistics.TotalPrioritizations)

	totalPriority := pe.statistics.AveragePriorityScore * float64(pe.statistics.TotalPrioritizations-1)
	totalPriority += result.PriorityScore
	pe.statistics.AveragePriorityScore = totalPriority / float64(pe.statistics.TotalPrioritizations)

	pe.statistics.LastUpdate = time.Now()
}

// GetStatistics returns current prioritization statistics
func (pe *PrioritizationEngine) GetStatistics() PrioritizationStatistics {
	pe.mutex.RLock()
	defer pe.mutex.RUnlock()
	return pe.statistics
}