package risk

import (
	"context"
	"fmt"
	"log/slog"
	"math"
	"strings"
	"sync"
	"time"
)

// ExploitabilityAssessor evaluates the exploitability of vulnerabilities
type ExploitabilityAssessor struct {
	config               ExploitabilityConfig
	logger               *slog.Logger
	exploitDatabase      *ExploitDatabase
	difficultyAnalyzer   *DifficultyAnalyzer
	accessibilityAnalyzer *AccessibilityAnalyzer
	weaponizationTracker *WeaponizationTracker
	metricCalculator     *ExploitabilityMetricCalculator
	attackPathAnalyzer   *AttackPathAnalyzer
	statistics           ExploitabilityStatistics
	cache                ExploitabilityCache
	mutex                sync.RWMutex
}

// ExploitabilityConfig defines configuration for exploitability assessment
type ExploitabilityConfig struct {
	OrganizationProfile    OrganizationProfile     `json:"organization_profile"`
	
	// Assessment settings
	EnableTechnicalAnalysis    bool               `json:"enable_technical_analysis"`
	EnableAccessibilityAnalysis bool              `json:"enable_accessibility_analysis"`
	EnableWeaponizationAnalysis bool              `json:"enable_weaponization_analysis"`
	EnableAttackPathAnalysis   bool               `json:"enable_attack_path_analysis"`
	EnableEnvironmentalFactors bool               `json:"enable_environmental_factors"`
	
	// Exploit databases
	ExploitDatabases      []ExploitDatabaseConfig `json:"exploit_databases"`
	WeaponizedToolsDB     []WeaponizedToolConfig  `json:"weaponized_tools_db"`
	
	// Scoring weights
	TechnicalComplexityWeight    float64          `json:"technical_complexity_weight"`
	AccessibilityWeight          float64          `json:"accessibility_weight"`
	WeaponizationWeight          float64          `json:"weaponization_weight"`
	AttackPathWeight             float64          `json:"attack_path_weight"`
	EnvironmentalWeight          float64          `json:"environmental_weight"`
	TemporalWeight               float64          `json:"temporal_weight"`
	
	// Technical factors
	CVSSExploitabilityWeight     float64          `json:"cvss_exploitability_weight"`
	AuthenticationWeight         float64          `json:"authentication_weight"`
	UserInteractionWeight        float64          `json:"user_interaction_weight"`
	NetworkAccessWeight          float64          `json:"network_access_weight"`
	PrivilegesRequiredWeight     float64          `json:"privileges_required_weight"`
	
	// Accessibility factors
	NetworkExposureWeight        float64          `json:"network_exposure_weight"`
	InternetAccessibilityWeight  float64          `json:"internet_accessibility_weight"`
	InternalAccessibilityWeight  float64          `json:"internal_accessibility_weight"`
	PhysicalAccessWeight         float64          `json:"physical_access_weight"`
	
	// Environmental factors
	DefenseInDepthWeight         float64          `json:"defense_in_depth_weight"`
	MonitoringCoverageWeight     float64          `json:"monitoring_coverage_weight"`
	PatchingCadenceWeight        float64          `json:"patching_cadence_weight"`
	SecurityControlsWeight       float64          `json:"security_controls_weight"`
	
	// Performance settings
	CacheEnabled                 bool             `json:"cache_enabled"`
	CacheExpiration              time.Duration    `json:"cache_expiration"`
	CacheMaxSize                 int              `json:"cache_max_size"`
	AnalysisTimeout              time.Duration    `json:"analysis_timeout"`
	
	// iSECTECH specific
	CustomExploitabilityModels   []CustomExploitabilityModel `json:"custom_exploitability_models"`
	OrganizationalControls       []OrganizationalControl     `json:"organizational_controls"`
	ThreatModelMapping           map[string]float64          `json:"threat_model_mapping"`
	SkillLevelRequirements       map[string]float64          `json:"skill_level_requirements"`
}

// ExploitabilityResult contains exploitability assessment results
type ExploitabilityResult struct {
	VulnerabilityID        string                    `json:"vulnerability_id"`
	ExploitabilityScore    float64                   `json:"exploitability_score"`
	ExploitabilityLevel    string                    `json:"exploitability_level"`
	Confidence             float64                   `json:"confidence"`
	
	// Component analyses
	TechnicalAnalysis      *TechnicalExploitabilityAnalysis  `json:"technical_analysis,omitempty"`
	AccessibilityAnalysis  *AccessibilityAnalysis            `json:"accessibility_analysis,omitempty"`
	WeaponizationAnalysis  *WeaponizationAnalysis            `json:"weaponization_analysis,omitempty"`
	AttackPathAnalysis     *AttackPathAnalysis               `json:"attack_path_analysis,omitempty"`
	EnvironmentalAnalysis  *EnvironmentalFactorAnalysis      `json:"environmental_analysis,omitempty"`
	
	// Exploit information
	ExploitAvailability    *ExploitAvailabilityInfo          `json:"exploit_availability,omitempty"`
	WeaponizedTools        []WeaponizedTool                  `json:"weaponized_tools"`
	ExploitKits            []ExploitKitInfo                  `json:"exploit_kits"`
	ProofOfConcepts        []ProofOfConceptInfo              `json:"proof_of_concepts"`
	
	// Attack vectors and paths
	AttackVectors          []AttackVector                    `json:"attack_vectors"`
	AttackPaths            []AttackPath                      `json:"attack_paths"`
	AttackComplexity       AttackComplexityBreakdown        `json:"attack_complexity"`
	
	// Defensive considerations
	DefensiveEffectiveness []DefensiveMeasure                `json:"defensive_effectiveness"`
	DetectionDifficulty    DetectionDifficultyAnalysis       `json:"detection_difficulty"`
	
	// Risk factors
	ExploitabilityFactors  []ExploitabilityFactor            `json:"exploitability_factors"`
	MitigatingFactors      []ExploitabilityMitigatingFactor  `json:"mitigating_factors"`
	AggravatingFactors     []ExploitabilityAggravatingFactor `json:"aggravating_factors"`
	
	// Temporal aspects
	ExploitMaturity        ExploitMaturityAnalysis           `json:"exploit_maturity"`
	TrendAnalysis          ExploitTrendAnalysis              `json:"trend_analysis"`
	
	// Recommendations
	ExploitabilityRecommendations []ExploitabilityRecommendation `json:"exploitability_recommendations"`
	
	// Metadata
	ProcessingTime         time.Duration                     `json:"processing_time"`
	DataSources            []string                          `json:"data_sources"`
	LastUpdated            time.Time                         `json:"last_updated"`
	Timestamp              time.Time                         `json:"timestamp"`
}

// Supporting data structures
type ExploitDatabaseConfig struct {
	Name           string                 `json:"name"`
	Type           string                 `json:"type"`
	URL            string                 `json:"url"`
	APIKey         string                 `json:"api_key"`
	UpdateInterval time.Duration          `json:"update_interval"`
	Priority       int                    `json:"priority"`
	Reliability    float64                `json:"reliability"`
	Coverage       []string               `json:"coverage"`
	Enabled        bool                   `json:"enabled"`
	Metadata       map[string]interface{} `json:"metadata"`
}

type WeaponizedToolConfig struct {
	Name           string                 `json:"name"`
	Type           string                 `json:"type"`
	Availability   string                 `json:"availability"`
	Complexity     string                 `json:"complexity"`
	Effectiveness  float64                `json:"effectiveness"`
	LastUpdate     time.Time              `json:"last_update"`
	Metadata       map[string]interface{} `json:"metadata"`
}

type CustomExploitabilityModel struct {
	ID             string                 `json:"id"`
	Name           string                 `json:"name"`
	Description    string                 `json:"description"`
	Conditions     []ExploitabilityCondition `json:"conditions"`
	ScoreModifier  float64                `json:"score_modifier"`
	Enabled        bool                   `json:"enabled"`
	VulnTypes      []string               `json:"vuln_types"`
	AssetTypes     []string               `json:"asset_types"`
	Metadata       map[string]interface{} `json:"metadata"`
}

type ExploitabilityCondition struct {
	Field     string      `json:"field"`
	Operator  string      `json:"operator"`
	Value     interface{} `json:"value"`
	LogicalOp string      `json:"logical_op,omitempty"`
}

type OrganizationalControl struct {
	Name           string                 `json:"name"`
	Type           string                 `json:"type"`
	Effectiveness  float64                `json:"effectiveness"`
	Coverage       float64                `json:"coverage"`
	Implementation string                 `json:"implementation"`
	LastTested     time.Time              `json:"last_tested"`
	Metadata       map[string]interface{} `json:"metadata"`
}

type TechnicalExploitabilityAnalysis struct {
	CVSSExploitabilityScore  float64                    `json:"cvss_exploitability_score"`
	AttackVector             string                     `json:"attack_vector"`
	AttackComplexity         string                     `json:"attack_complexity"`
	PrivilegesRequired       string                     `json:"privileges_required"`
	UserInteraction          string                     `json:"user_interaction"`
	AuthenticationRequired   bool                       `json:"authentication_required"`
	TechnicalSkillRequired   string                     `json:"technical_skill_required"`
	ToolsRequired            []string                   `json:"tools_required"`
	PrerequisiteKnowledge    []string                   `json:"prerequisite_knowledge"`
	ExploitationTimeframe    time.Duration              `json:"exploitation_timeframe"`
	ReliabilityScore         float64                    `json:"reliability_score"`
	ConfidenceLevel          float64                    `json:"confidence_level"`
}

type AccessibilityAnalysis struct {
	NetworkAccessibility     NetworkAccessibilityInfo   `json:"network_accessibility"`
	PhysicalAccessibility    PhysicalAccessibilityInfo  `json:"physical_accessibility"`
	LogicalAccessibility     LogicalAccessibilityInfo   `json:"logical_accessibility"`
	TemporalAccessibility    TemporalAccessibilityInfo  `json:"temporal_accessibility"`
	OverallAccessibility     float64                    `json:"overall_accessibility"`
	AccessibilityBarriers    []AccessibilityBarrier     `json:"accessibility_barriers"`
	ConfidenceLevel          float64                    `json:"confidence_level"`
}

type NetworkAccessibilityInfo struct {
	InternetAccessible       bool                       `json:"internet_accessible"`
	InternalNetworkRequired  bool                       `json:"internal_network_required"`
	VPNRequired             bool                       `json:"vpn_required"`
	NetworkSegmentation     float64                    `json:"network_segmentation"`
	FirewallProtection      float64                    `json:"firewall_protection"`
	AccessControlLists      []string                   `json:"access_control_lists"`
	NetworkPath             []NetworkHop               `json:"network_path"`
	AccessibilityScore      float64                    `json:"accessibility_score"`
}

type PhysicalAccessibilityInfo struct {
	PhysicalAccessRequired   bool                       `json:"physical_access_required"`
	FacilitySecurityLevel    string                     `json:"facility_security_level"`
	AccessControlMeasures    []string                   `json:"access_control_measures"`
	SurveillanceMeasures     []string                   `json:"surveillance_measures"`
	PhysicalBarriers         []string                   `json:"physical_barriers"`
	AccessibilityScore       float64                    `json:"accessibility_score"`
}

type LogicalAccessibilityInfo struct {
	CredentialsRequired      bool                       `json:"credentials_required"`
	AuthenticationMethods    []string                   `json:"authentication_methods"`
	AuthorizationRequired    bool                       `json:"authorization_required"`
	PermissionLevel          string                     `json:"permission_level"`
	IdentityManagement       string                     `json:"identity_management"`
	AccessibilityScore       float64                    `json:"accessibility_score"`
}

type TemporalAccessibilityInfo struct {
	TimeConstraints          []TimeConstraint           `json:"time_constraints"`
	BusinessHoursRestrictions bool                      `json:"business_hours_restrictions"`
	MaintenanceWindows       []MaintenanceWindow        `json:"maintenance_windows"`
	TemporalBarriers         []string                   `json:"temporal_barriers"`
	AccessibilityScore       float64                    `json:"accessibility_score"`
}

type TimeConstraint struct {
	Type           string        `json:"type"`
	StartTime      string        `json:"start_time"`
	EndTime        string        `json:"end_time"`
	TimeZone       string        `json:"timezone"`
	DaysOfWeek     []string      `json:"days_of_week"`
	Impact         float64       `json:"impact"`
	Description    string        `json:"description"`
}

type AccessibilityBarrier struct {
	Type           string                 `json:"type"`
	Description    string                 `json:"description"`
	Effectiveness  float64                `json:"effectiveness"`
	BypassMethods  []string               `json:"bypass_methods"`
	BypassComplexity string               `json:"bypass_complexity"`
	Metadata       map[string]interface{} `json:"metadata"`
}

type NetworkHop struct {
	Device         string                 `json:"device"`
	DeviceType     string                 `json:"device_type"`
	SecurityLevel  string                 `json:"security_level"`
	Rules          []string               `json:"rules"`
	BypassDifficulty string               `json:"bypass_difficulty"`
	Metadata       map[string]interface{} `json:"metadata"`
}

type WeaponizationAnalysis struct {
	WeaponizationLevel       string                     `json:"weaponization_level"`
	WeaponizedExploits       []WeaponizedExploit        `json:"weaponized_exploits"`
	ExploitKits              []ExploitKitDetails        `json:"exploit_kits"`
	AutomatedTools           []AutomatedTool            `json:"automated_tools"`
	WeaponizationTrend       string                     `json:"weaponization_trend"`
	TimeToWeaponization      time.Duration              `json:"time_to_weaponization"`
	WeaponizationBarriers    []WeaponizationBarrier     `json:"weaponization_barriers"`
	ConfidenceLevel          float64                    `json:"confidence_level"`
}

type WeaponizedExploit struct {
	Name               string                 `json:"name"`
	Source             string                 `json:"source"`
	Type               string                 `json:"type"`
	Availability       string                 `json:"availability"`
	Cost               float64                `json:"cost"`
	Reliability        float64                `json:"reliability"`
	Sophistication     string                 `json:"sophistication"`
	TargetPlatforms    []string               `json:"target_platforms"`
	RequiredSkills     []string               `json:"required_skills"`
	PublishedDate      time.Time              `json:"published_date"`
	LastUpdated        time.Time              `json:"last_updated"`
	UsageFrequency     string                 `json:"usage_frequency"`
	Metadata           map[string]interface{} `json:"metadata"`
}

type ExploitKitDetails struct {
	Name               string                 `json:"name"`
	Version            string                 `json:"version"`
	Availability       string                 `json:"availability"`
	Price              float64                `json:"price"`
	Capabilities       []string               `json:"capabilities"`
	TargetedVulns      []string               `json:"targeted_vulns"`
	EaseOfUse          string                 `json:"ease_of_use"`
	Effectiveness      float64                `json:"effectiveness"`
	LastSeen           time.Time              `json:"last_seen"`
	ThreatActorUsage   []string               `json:"threat_actor_usage"`
	Metadata           map[string]interface{} `json:"metadata"`
}

type AutomatedTool struct {
	Name               string                 `json:"name"`
	Type               string                 `json:"type"`
	Category           string                 `json:"category"`
	Availability       string                 `json:"availability"`
	Complexity         string                 `json:"complexity"`
	Effectiveness      float64                `json:"effectiveness"`
	RequiredSkills     []string               `json:"required_skills"`
	Platforms          []string               `json:"platforms"`
	LastUpdated        time.Time              `json:"last_updated"`
	Metadata           map[string]interface{} `json:"metadata"`
}

type WeaponizationBarrier struct {
	Type               string                 `json:"type"`
	Description        string                 `json:"description"`
	Difficulty         string                 `json:"difficulty"`
	TimeRequired       time.Duration          `json:"time_required"`
	SkillsRequired     []string               `json:"skills_required"`
	ResourcesRequired  []string               `json:"resources_required"`
	BypassMethods      []string               `json:"bypass_methods"`
	Metadata           map[string]interface{} `json:"metadata"`
}

type AttackPathAnalysis struct {
	PossibleAttackPaths      []AttackPath               `json:"possible_attack_paths"`
	OptimalAttackPath        *AttackPath                `json:"optimal_attack_path,omitempty"`
	PathComplexityDistribution map[string]int           `json:"path_complexity_distribution"`
	AveragePathComplexity    float64                    `json:"average_path_complexity"`
	MinimumSkillRequired     string                     `json:"minimum_skill_required"`
	PathAnalysisMetrics      AttackPathMetrics          `json:"path_analysis_metrics"`
	ConfidenceLevel          float64                    `json:"confidence_level"`
}

type AttackPath struct {
	PathID                   string                     `json:"path_id"`
	PathName                 string                     `json:"path_name"`
	Steps                    []AttackStep               `json:"steps"`
	OverallComplexity        string                     `json:"overall_complexity"`
	RequiredSkillLevel       string                     `json:"required_skill_level"`
	RequiredTools            []string                   `json:"required_tools"`
	EstimatedTimeframe       time.Duration              `json:"estimated_timeframe"`
	SuccessProbability       float64                    `json:"success_probability"`
	DetectionProbability     float64                    `json:"detection_probability"`
	PathRisk                 float64                    `json:"path_risk"`
	Prerequisites            []string                   `json:"prerequisites"`
	Metadata                 map[string]interface{}     `json:"metadata"`
}

type AttackStep struct {
	StepID                   string                     `json:"step_id"`
	StepName                 string                     `json:"step_name"`
	Description              string                     `json:"description"`
	StepType                 string                     `json:"step_type"`
	Complexity               string                     `json:"complexity"`
	RequiredSkills           []string                   `json:"required_skills"`
	RequiredTools            []string                   `json:"required_tools"`
	TimeRequired             time.Duration              `json:"time_required"`
	SuccessRate              float64                    `json:"success_rate"`
	DetectionRisk            float64                    `json:"detection_risk"`
	Prerequisites            []string                   `json:"prerequisites"`
	Outputs                  []string                   `json:"outputs"`
	AlternativeMethods       []string                   `json:"alternative_methods"`
	Metadata                 map[string]interface{}     `json:"metadata"`
}

type AttackPathMetrics struct {
	TotalPaths               int                        `json:"total_paths"`
	LowComplexityPaths       int                        `json:"low_complexity_paths"`
	MediumComplexityPaths    int                        `json:"medium_complexity_paths"`
	HighComplexityPaths      int                        `json:"high_complexity_paths"`
	AverageStepsPerPath      float64                    `json:"average_steps_per_path"`
	AverageTimePerPath       time.Duration              `json:"average_time_per_path"`
	AverageSuccessRate       float64                    `json:"average_success_rate"`
	AverageDetectionRisk     float64                    `json:"average_detection_risk"`
}

type EnvironmentalFactorAnalysis struct {
	DefenseInDepthAnalysis   DefenseInDepthAnalysis     `json:"defense_in_depth_analysis"`
	MonitoringCoverage       MonitoringCoverageAnalysis `json:"monitoring_coverage"`
	SecurityControlsAnalysis SecurityControlsAnalysis   `json:"security_controls_analysis"`
	IncidentResponseReadiness IncidentResponseAnalysis  `json:"incident_response_readiness"`
	PatchingMaturity         PatchingMaturityAnalysis   `json:"patching_maturity"`
	OverallDefensiveness     float64                    `json:"overall_defensiveness"`
	EnvironmentalRiskFactors []EnvironmentalRiskFactor  `json:"environmental_risk_factors"`
	ConfidenceLevel          float64                    `json:"confidence_level"`
}

type DefenseInDepthAnalysis struct {
	LayerCoverage            map[string]float64         `json:"layer_coverage"`
	LayerEffectiveness       map[string]float64         `json:"layer_effectiveness"`
	GapAnalysis              []DefenseGap               `json:"gap_analysis"`
	RedundancyLevel          float64                    `json:"redundancy_level"`
	OverallMaturity          string                     `json:"overall_maturity"`
	DefenseScore             float64                    `json:"defense_score"`
}

type DefenseGap struct {
	Layer                    string                     `json:"layer"`
	GapType                  string                     `json:"gap_type"`
	Description              string                     `json:"description"`
	Severity                 string                     `json:"severity"`
	Impact                   float64                    `json:"impact"`
	Remediation              []string                   `json:"remediation"`
	Metadata                 map[string]interface{}     `json:"metadata"`
}

type MonitoringCoverageAnalysis struct {
	NetworkMonitoring        float64                    `json:"network_monitoring"`
	EndpointMonitoring       float64                    `json:"endpoint_monitoring"`
	ApplicationMonitoring    float64                    `json:"application_monitoring"`
	LoggingCoverage          float64                    `json:"logging_coverage"`
	AlertingCapability       float64                    `json:"alerting_capability"`
	ThreatDetectionCapability float64                   `json:"threat_detection_capability"`
	ResponseCapability       float64                    `json:"response_capability"`
	OverallCoverage          float64                    `json:"overall_coverage"`
	CoverageGaps             []MonitoringGap            `json:"coverage_gaps"`
}

type MonitoringGap struct {
	Area                     string                     `json:"area"`
	GapType                  string                     `json:"gap_type"`
	Description              string                     `json:"description"`
	Impact                   float64                    `json:"impact"`
	Remediation              []string                   `json:"remediation"`
	Metadata                 map[string]interface{}     `json:"metadata"`
}

type SecurityControlsAnalysis struct {
	PreventiveControls       []SecurityControl          `json:"preventive_controls"`
	DetectiveControls        []SecurityControl          `json:"detective_controls"`
	CorrectiveControls       []SecurityControl          `json:"corrective_controls"`
	CompensatingControls     []SecurityControl          `json:"compensating_controls"`
	ControlEffectiveness     map[string]float64         `json:"control_effectiveness"`
	ControlCoverage          map[string]float64         `json:"control_coverage"`
	OverallControlMaturity   string                     `json:"overall_control_maturity"`
	ControlGaps              []ControlGap               `json:"control_gaps"`
}

type SecurityControl struct {
	Name                     string                     `json:"name"`
	Type                     string                     `json:"type"`
	Category                 string                     `json:"category"`
	Implementation           string                     `json:"implementation"`
	Effectiveness            float64                    `json:"effectiveness"`
	Coverage                 float64                    `json:"coverage"`
	LastTested               time.Time                  `json:"last_tested"`
	TestResults              string                     `json:"test_results"`
	Automation               bool                       `json:"automation"`
	Metadata                 map[string]interface{}     `json:"metadata"`
}

type ControlGap struct {
	ControlType              string                     `json:"control_type"`
	GapDescription           string                     `json:"gap_description"`
	Impact                   float64                    `json:"impact"`
	Priority                 string                     `json:"priority"`
	Remediation              []string                   `json:"remediation"`
	Metadata                 map[string]interface{}     `json:"metadata"`
}

type IncidentResponseAnalysis struct {
	ResponseCapability       float64                    `json:"response_capability"`
	ResponseTimeMetrics      ResponseTimeMetrics        `json:"response_time_metrics"`
	EscalationProcedures     []EscalationProcedure      `json:"escalation_procedures"`
	CommunicationPlans       []CommunicationPlan        `json:"communication_plans"`
	RecoveryCapability       float64                    `json:"recovery_capability"`
	LessonsLearnedProcess    bool                       `json:"lessons_learned_process"`
	TrainingFrequency        string                     `json:"training_frequency"`
	OverallReadiness         string                     `json:"overall_readiness"`
}

type ResponseTimeMetrics struct {
	DetectionTime            time.Duration              `json:"detection_time"`
	AnalysisTime             time.Duration              `json:"analysis_time"`
	ContainmentTime          time.Duration              `json:"containment_time"`
	EradicationTime          time.Duration              `json:"eradication_time"`
	RecoveryTime             time.Duration              `json:"recovery_time"`
	TotalResponseTime        time.Duration              `json:"total_response_time"`
}

type EscalationProcedure struct {
	TriggerConditions        []string                   `json:"trigger_conditions"`
	EscalationLevels         []string                   `json:"escalation_levels"`
	ContactInformation       []string                   `json:"contact_information"`
	EscalationTimeframes     []time.Duration            `json:"escalation_timeframes"`
	DecisionCriteria         []string                   `json:"decision_criteria"`
}

type CommunicationPlan struct {
	Stakeholders             []string                   `json:"stakeholders"`
	CommunicationChannels    []string                   `json:"communication_channels"`
	UpdateFrequency          time.Duration              `json:"update_frequency"`
	Templates                []string                   `json:"templates"`
	ApprovalProcess          []string                   `json:"approval_process"`
}

type PatchingMaturityAnalysis struct {
	PatchingCadence          string                     `json:"patching_cadence"`
	CriticalPatchingTime     time.Duration              `json:"critical_patching_time"`
	HighPatchingTime         time.Duration              `json:"high_patching_time"`
	MediumPatchingTime       time.Duration              `json:"medium_patching_time"`
	LowPatchingTime          time.Duration              `json:"low_patching_time"`
	PatchingCoverage         float64                    `json:"patching_coverage"`
	TestingProcedures        bool                       `json:"testing_procedures"`
	RollbackCapability       bool                       `json:"rollback_capability"`
	AutomationLevel          string                     `json:"automation_level"`
	OverallMaturity          string                     `json:"overall_maturity"`
}

type EnvironmentalRiskFactor struct {
	Factor                   string                     `json:"factor"`
	Category                 string                     `json:"category"`
	Impact                   float64                    `json:"impact"`
	Likelihood               float64                    `json:"likelihood"`
	Mitigation               []string                   `json:"mitigation"`
	Metadata                 map[string]interface{}     `json:"metadata"`
}

type ExploitAvailabilityInfo struct {
	PublicExploitsAvailable  bool                       `json:"public_exploits_available"`
	PrivateExploitsAvailable bool                       `json:"private_exploits_available"`
	ProofOfConceptAvailable  bool                       `json:"proof_of_concept_available"`
	ExploitMaturity          string                     `json:"exploit_maturity"`
	ExploitReliability       float64                    `json:"exploit_reliability"`
	TimeToExploit            time.Duration              `json:"time_to_exploit"`
	SkillRequiredLevel       string                     `json:"skill_required_level"`
	ToolsRequired            []string                   `json:"tools_required"`
}

type WeaponizedTool struct {
	Name                     string                     `json:"name"`
	Type                     string                     `json:"type"`
	Availability             string                     `json:"availability"`
	Cost                     float64                    `json:"cost"`
	Effectiveness            float64                    `json:"effectiveness"`
	EaseOfUse               string                     `json:"ease_of_use"`
	RequiredSkills          []string                   `json:"required_skills"`
	SupportedPlatforms      []string                   `json:"supported_platforms"`
	LastUpdated             time.Time                  `json:"last_updated"`
	ThreatActorUsage        []string                   `json:"threat_actor_usage"`
	Metadata                map[string]interface{}     `json:"metadata"`
}

type ExploitKitInfo struct {
	Name                     string                     `json:"name"`
	Version                  string                     `json:"version"`
	Price                    float64                    `json:"price"`
	Availability             string                     `json:"availability"`
	TargetedVulnerabilities  []string                   `json:"targeted_vulnerabilities"`
	DeliveryMethods          []string                   `json:"delivery_methods"`
	Effectiveness            float64                    `json:"effectiveness"`
	LastSeen                 time.Time                  `json:"last_seen"`
	AssociatedGroups         []string                   `json:"associated_groups"`
	Metadata                 map[string]interface{}     `json:"metadata"`
}

type ProofOfConceptInfo struct {
	Source                   string                     `json:"source"`
	URL                      string                     `json:"url"`
	PublishedDate            time.Time                  `json:"published_date"`
	Author                   string                     `json:"author"`
	Reliability              float64                    `json:"reliability"`
	Complexity               string                     `json:"complexity"`
	RequiredSkills           []string                   `json:"required_skills"`
	PlatformSupport          []string                   `json:"platform_support"`
	Description              string                     `json:"description"`
	Metadata                 map[string]interface{}     `json:"metadata"`
}

type AttackVector struct {
	VectorType               string                     `json:"vector_type"`
	VectorName               string                     `json:"vector_name"`
	Description              string                     `json:"description"`
	Complexity               string                     `json:"complexity"`
	RequiredAccess           string                     `json:"required_access"`
	RequiredPrivileges       string                     `json:"required_privileges"`
	UserInteractionRequired  bool                       `json:"user_interaction_required"`
	RequiredSkills           []string                   `json:"required_skills"`
	RequiredTools            []string                   `json:"required_tools"`
	SuccessProbability       float64                    `json:"success_probability"`
	DetectionDifficulty      string                     `json:"detection_difficulty"`
	ImpactPotential          float64                    `json:"impact_potential"`
	Metadata                 map[string]interface{}     `json:"metadata"`
}

type AttackComplexityBreakdown struct {
	TechnicalComplexity      string                     `json:"technical_complexity"`
	OperationalComplexity    string                     `json:"operational_complexity"`
	ResourceComplexity       string                     `json:"resource_complexity"`
	TimeComplexity           string                     `json:"time_complexity"`
	SkillComplexity          string                     `json:"skill_complexity"`
	OverallComplexity        string                     `json:"overall_complexity"`
	ComplexityFactors        []ComplexityFactor         `json:"complexity_factors"`
}

type ComplexityFactor struct {
	Factor                   string                     `json:"factor"`
	Level                    string                     `json:"level"`
	Impact                   float64                    `json:"impact"`
	Description              string                     `json:"description"`
	Metadata                 map[string]interface{}     `json:"metadata"`
}

type DefensiveMeasure struct {
	MeasureType              string                     `json:"measure_type"`
	MeasureName              string                     `json:"measure_name"`
	Effectiveness            float64                    `json:"effectiveness"`
	Coverage                 float64                    `json:"coverage"`
	Implementation           string                     `json:"implementation"`
	BypassDifficulty         string                     `json:"bypass_difficulty"`
	BypassMethods            []string                   `json:"bypass_methods"`
	MaintenanceRequired      bool                       `json:"maintenance_required"`
	Cost                     float64                    `json:"cost"`
	Metadata                 map[string]interface{}     `json:"metadata"`
}

type DetectionDifficultyAnalysis struct {
	DetectionMethods         []DetectionMethod          `json:"detection_methods"`
	EvasionTechniques        []EvasionTechnique         `json:"evasion_techniques"`
	DetectionProbability     float64                    `json:"detection_probability"`
	TimeToDetection          time.Duration              `json:"time_to_detection"`
	FalsePositiveRate        float64                    `json:"false_positive_rate"`
	FalseNegativeRate        float64                    `json:"false_negative_rate"`
	OverallDifficulty        string                     `json:"overall_difficulty"`
}

type DetectionMethod struct {
	Method                   string                     `json:"method"`
	Type                     string                     `json:"type"`
	Effectiveness            float64                    `json:"effectiveness"`
	Coverage                 float64                    `json:"coverage"`
	RequiredCapabilities     []string                   `json:"required_capabilities"`
	Implementation           string                     `json:"implementation"`
	Metadata                 map[string]interface{}     `json:"metadata"`
}

type EvasionTechnique struct {
	Technique                string                     `json:"technique"`
	Type                     string                     `json:"type"`
	Effectiveness            float64                    `json:"effectiveness"`
	Complexity               string                     `json:"complexity"`
	RequiredSkills           []string                   `json:"required_skills"`
	CounterMeasures          []string                   `json:"counter_measures"`
	Metadata                 map[string]interface{}     `json:"metadata"`
}

type ExploitabilityFactor struct {
	Factor                   string                     `json:"factor"`
	Category                 string                     `json:"category"`
	Impact                   float64                    `json:"impact"`
	Confidence               float64                    `json:"confidence"`
	Source                   string                     `json:"source"`
	Evidence                 []string                   `json:"evidence"`
	Metadata                 map[string]interface{}     `json:"metadata"`
}

type ExploitabilityMitigatingFactor struct {
	Factor                   string                     `json:"factor"`
	Type                     string                     `json:"type"`
	Effectiveness            float64                    `json:"effectiveness"`
	Coverage                 float64                    `json:"coverage"`
	Implementation           string                     `json:"implementation"`
	Confidence               float64                    `json:"confidence"`
	Metadata                 map[string]interface{}     `json:"metadata"`
}

type ExploitabilityAggravatingFactor struct {
	Factor                   string                     `json:"factor"`
	Type                     string                     `json:"type"`
	Multiplier               float64                    `json:"multiplier"`
	Confidence               float64                    `json:"confidence"`
	Evidence                 []string                   `json:"evidence"`
	Metadata                 map[string]interface{}     `json:"metadata"`
}

type ExploitMaturityAnalysis struct {
	MaturityLevel            string                     `json:"maturity_level"`
	MaturityStages           []MaturityStage            `json:"maturity_stages"`
	TimeToMaturity           time.Duration              `json:"time_to_maturity"`
	MaturityIndicators       []MaturityIndicator        `json:"maturity_indicators"`
	MaturityTrend            string                     `json:"maturity_trend"`
}

type MaturityStage struct {
	Stage                    string                     `json:"stage"`
	Description              string                     `json:"description"`
	Reached                  bool                       `json:"reached"`
	ReachedDate              *time.Time                 `json:"reached_date,omitempty"`
	EstimatedDate            *time.Time                 `json:"estimated_date,omitempty"`
	Indicators               []string                   `json:"indicators"`
}

type MaturityIndicator struct {
	Indicator                string                     `json:"indicator"`
	Status                   string                     `json:"status"`
	Confidence               float64                    `json:"confidence"`
	Source                   string                     `json:"source"`
	LastObserved             time.Time                  `json:"last_observed"`
}

type ExploitTrendAnalysis struct {
	TrendDirection           string                     `json:"trend_direction"`
	TrendVelocity            string                     `json:"trend_velocity"`
	TrendFactors             []TrendFactor              `json:"trend_factors"`
	PredictedTrend           string                     `json:"predicted_trend"`
	TrendConfidence          float64                    `json:"trend_confidence"`
	HistoricalData           []HistoricalTrendPoint     `json:"historical_data"`
}

type TrendFactor struct {
	Factor                   string                     `json:"factor"`
	Impact                   string                     `json:"impact"`
	Confidence               float64                    `json:"confidence"`
	TimeFrame                time.Duration              `json:"time_frame"`
	Description              string                     `json:"description"`
}

type HistoricalTrendPoint struct {
	Date                     time.Time                  `json:"date"`
	ExploitCount             int                        `json:"exploit_count"`
	WeaponizationLevel       string                     `json:"weaponization_level"`
	ActivityLevel            string                     `json:"activity_level"`
	Notes                    string                     `json:"notes"`
}

type ExploitabilityRecommendation struct {
	Type                     string                     `json:"type"`
	Priority                 string                     `json:"priority"`
	Recommendation           string                     `json:"recommendation"`
	Rationale                string                     `json:"rationale"`
	Implementation           []string                   `json:"implementation"`
	Timeline                 time.Duration              `json:"timeline"`
	Cost                     float64                    `json:"cost"`
	EffectivenessReduction   float64                    `json:"effectiveness_reduction"`
	RiskReduction            float64                    `json:"risk_reduction"`
	Dependencies             []string                   `json:"dependencies"`
	Metadata                 map[string]interface{}     `json:"metadata"`
}

type ExploitabilityStatistics struct {
	TotalAssessments         int64                      `json:"total_assessments"`
	AverageExploitabilityScore float64                  `json:"average_exploitability_score"`
	ExploitabilityDistribution map[string]int64         `json:"exploitability_distribution"`
	ExploitAvailabilityRate  float64                    `json:"exploit_availability_rate"`
	WeaponizationRate        float64                    `json:"weaponization_rate"`
	ProcessingTime           float64                    `json:"processing_time"`
	ComponentPerformance     map[string]ComponentStat   `json:"component_performance"`
	LastUpdate               time.Time                  `json:"last_update"`
}

type ExploitabilityCache struct {
	cache     map[string]*ExploitabilityResult
	ttl       map[string]time.Time
	mutex     sync.RWMutex
	maxSize   int
	enabled   bool
	hitCount  int64
	missCount int64
}

// Supporting engines
type ExploitDatabase struct {
	exploits map[string][]ExploitRecord
	logger   *slog.Logger
	mutex    sync.RWMutex
}

type ExploitRecord struct {
	ID                string                 `json:"id"`
	CVE               string                 `json:"cve"`
	Type              string                 `json:"type"`
	Reliability       float64                `json:"reliability"`
	Complexity        string                 `json:"complexity"`
	PublishedDate     time.Time              `json:"published_date"`
	Source            string                 `json:"source"`
	Metadata          map[string]interface{} `json:"metadata"`
}

type DifficultyAnalyzer struct {
	logger *slog.Logger
}

type AccessibilityAnalyzer struct {
	logger *slog.Logger
}

type WeaponizationTracker struct {
	logger *slog.Logger
}

type ExploitabilityMetricCalculator struct {
	logger *slog.Logger
}

type AttackPathAnalyzer struct {
	logger *slog.Logger
}

// NewExploitabilityAssessor creates a new exploitability assessor
func NewExploitabilityAssessor(config ExploitabilityConfig, logger *slog.Logger) (*ExploitabilityAssessor, error) {
	if logger == nil {
		logger = slog.Default()
	}

	// Initialize cache
	cache := ExploitabilityCache{
		cache:   make(map[string]*ExploitabilityResult),
		ttl:     make(map[string]time.Time),
		maxSize: config.CacheMaxSize,
		enabled: config.CacheEnabled,
	}

	assessor := &ExploitabilityAssessor{
		config: config,
		logger: logger,
		cache:  cache,
		statistics: ExploitabilityStatistics{
			ExploitabilityDistribution: make(map[string]int64),
			ComponentPerformance:       make(map[string]ComponentStat),
			LastUpdate:                 time.Now(),
		},
	}

	// Initialize sub-components
	if err := assessor.initializeComponents(); err != nil {
		return nil, fmt.Errorf("failed to initialize components: %w", err)
	}

	return assessor, nil
}

// AssessExploitability performs comprehensive exploitability assessment
func (ea *ExploitabilityAssessor) AssessExploitability(ctx context.Context, vuln *Vulnerability) (*ExploitabilityResult, error) {
	startTime := time.Now()

	// Check cache first
	if ea.config.CacheEnabled {
		if cached := ea.getCachedResult(vuln.ID); cached != nil {
			ea.updateCacheHitStats(true)
			return cached, nil
		}
		ea.updateCacheHitStats(false)
	}

	// Create analysis context
	analysisCtx, cancel := context.WithTimeout(ctx, ea.config.AnalysisTimeout)
	defer cancel()

	// Initialize result
	result := &ExploitabilityResult{
		VulnerabilityID:               vuln.ID,
		WeaponizedTools:              make([]WeaponizedTool, 0),
		ExploitKits:                  make([]ExploitKitInfo, 0),
		ProofOfConcepts:              make([]ProofOfConceptInfo, 0),
		AttackVectors:                make([]AttackVector, 0),
		AttackPaths:                  make([]AttackPath, 0),
		DefensiveEffectiveness:       make([]DefensiveMeasure, 0),
		ExploitabilityFactors:        make([]ExploitabilityFactor, 0),
		MitigatingFactors:            make([]ExploitabilityMitigatingFactor, 0),
		AggravatingFactors:           make([]ExploitabilityAggravatingFactor, 0),
		ExploitabilityRecommendations: make([]ExploitabilityRecommendation, 0),
		DataSources:                  make([]string, 0),
		Timestamp:                    time.Now(),
	}

	// Perform technical analysis
	if ea.config.EnableTechnicalAnalysis {
		technicalAnalysis, err := ea.performTechnicalAnalysis(analysisCtx, vuln)
		if err != nil {
			ea.logger.Warn("Technical analysis failed", "error", err)
		} else {
			result.TechnicalAnalysis = technicalAnalysis
		}
	}

	// Perform accessibility analysis
	if ea.config.EnableAccessibilityAnalysis {
		accessibilityAnalysis, err := ea.performAccessibilityAnalysis(analysisCtx, vuln)
		if err != nil {
			ea.logger.Warn("Accessibility analysis failed", "error", err)
		} else {
			result.AccessibilityAnalysis = accessibilityAnalysis
		}
	}

	// Perform weaponization analysis
	if ea.config.EnableWeaponizationAnalysis {
		weaponizationAnalysis, err := ea.performWeaponizationAnalysis(analysisCtx, vuln)
		if err != nil {
			ea.logger.Warn("Weaponization analysis failed", "error", err)
		} else {
			result.WeaponizationAnalysis = weaponizationAnalysis
		}
	}

	// Perform attack path analysis
	if ea.config.EnableAttackPathAnalysis {
		attackPathAnalysis, err := ea.performAttackPathAnalysis(analysisCtx, vuln)
		if err != nil {
			ea.logger.Warn("Attack path analysis failed", "error", err)
		} else {
			result.AttackPathAnalysis = attackPathAnalysis
		}
	}

	// Perform environmental analysis
	if ea.config.EnableEnvironmentalFactors {
		environmentalAnalysis, err := ea.performEnvironmentalAnalysis(analysisCtx, vuln)
		if err != nil {
			ea.logger.Warn("Environmental analysis failed", "error", err)
		} else {
			result.EnvironmentalAnalysis = environmentalAnalysis
		}
	}

	// Analyze exploit availability
	result.ExploitAvailability = ea.analyzeExploitAvailability(vuln, result)

	// Generate attack vectors and paths
	result.AttackVectors = ea.generateAttackVectors(vuln, result)
	result.AttackComplexity = ea.analyzeAttackComplexity(vuln, result)

	// Analyze defensive effectiveness
	result.DefensiveEffectiveness = ea.analyzeDefensiveEffectiveness(vuln, result)
	result.DetectionDifficulty = ea.analyzeDetectionDifficulty(vuln, result)

	// Generate exploitability factors
	ea.generateExploitabilityFactors(result, vuln)
	ea.generateMitigatingFactors(result, vuln)
	ea.generateAggravatingFactors(result, vuln)

	// Analyze exploit maturity and trends
	result.ExploitMaturity = ea.analyzeExploitMaturity(vuln, result)
	result.TrendAnalysis = ea.analyzeTrends(vuln, result)

	// Apply custom exploitability models
	ea.applyCustomExploitabilityModels(result, vuln)

	// Calculate overall exploitability score
	result.ExploitabilityScore = ea.calculateExploitabilityScore(result, vuln)
	result.ExploitabilityLevel = ea.determineExploitabilityLevel(result.ExploitabilityScore)
	result.Confidence = ea.calculateConfidence(result)

	// Generate recommendations
	ea.generateExploitabilityRecommendations(result, vuln)

	result.ProcessingTime = time.Since(startTime)
	result.LastUpdated = time.Now()

	// Cache result
	if ea.config.CacheEnabled {
		ea.cacheResult(vuln.ID, result)
	}

	// Update statistics
	ea.updateStatistics(result)

	ea.logger.Info("Exploitability assessment completed",
		"vulnerability_id", vuln.ID,
		"exploitability_score", result.ExploitabilityScore,
		"exploitability_level", result.ExploitabilityLevel,
		"processing_time", result.ProcessingTime)

	return result, nil
}

// initializeComponents initializes sub-components
func (ea *ExploitabilityAssessor) initializeComponents() error {
	ea.exploitDatabase = &ExploitDatabase{
		exploits: make(map[string][]ExploitRecord),
		logger:   ea.logger,
	}

	ea.difficultyAnalyzer = &DifficultyAnalyzer{logger: ea.logger}
	ea.accessibilityAnalyzer = &AccessibilityAnalyzer{logger: ea.logger}
	ea.weaponizationTracker = &WeaponizationTracker{logger: ea.logger}
	ea.metricCalculator = &ExploitabilityMetricCalculator{logger: ea.logger}
	ea.attackPathAnalyzer = &AttackPathAnalyzer{logger: ea.logger}

	return nil
}

// Analysis methods (simplified implementations)
func (ea *ExploitabilityAssessor) performTechnicalAnalysis(ctx context.Context, vuln *Vulnerability) (*TechnicalExploitabilityAnalysis, error) {
	analysis := &TechnicalExploitabilityAnalysis{
		CVSSExploitabilityScore: ea.extractCVSSExploitabilityScore(vuln),
		AttackVector:           ea.determineAttackVector(vuln),
		AttackComplexity:       ea.determineAttackComplexity(vuln),
		PrivilegesRequired:     ea.determinePrivilegesRequired(vuln),
		UserInteraction:        ea.determineUserInteraction(vuln),
		AuthenticationRequired: ea.determineAuthenticationRequired(vuln),
		TechnicalSkillRequired: ea.determineTechnicalSkillRequired(vuln),
		ToolsRequired:          ea.determineToolsRequired(vuln),
		PrerequisiteKnowledge:  ea.determinePrerequisiteKnowledge(vuln),
		ExploitationTimeframe:  ea.estimateExploitationTimeframe(vuln),
		ReliabilityScore:       ea.calculateReliabilityScore(vuln),
		ConfidenceLevel:        0.8,
	}

	return analysis, nil
}

func (ea *ExploitabilityAssessor) performAccessibilityAnalysis(ctx context.Context, vuln *Vulnerability) (*AccessibilityAnalysis, error) {
	analysis := &AccessibilityAnalysis{
		AccessibilityBarriers: make([]AccessibilityBarrier, 0),
		ConfidenceLevel:       0.7,
	}

	// Analyze network accessibility
	analysis.NetworkAccessibility = ea.analyzeNetworkAccessibility(vuln)
	
	// Analyze physical accessibility
	analysis.PhysicalAccessibility = ea.analyzePhysicalAccessibility(vuln)
	
	// Analyze logical accessibility
	analysis.LogicalAccessibility = ea.analyzeLogicalAccessibility(vuln)
	
	// Analyze temporal accessibility
	analysis.TemporalAccessibility = ea.analyzeTemporalAccessibility(vuln)
	
	// Calculate overall accessibility
	analysis.OverallAccessibility = ea.calculateOverallAccessibility(analysis)
	
	// Identify accessibility barriers
	analysis.AccessibilityBarriers = ea.identifyAccessibilityBarriers(vuln, analysis)

	return analysis, nil
}

func (ea *ExploitabilityAssessor) performWeaponizationAnalysis(ctx context.Context, vuln *Vulnerability) (*WeaponizationAnalysis, error) {
	analysis := &WeaponizationAnalysis{
		WeaponizedExploits:    make([]WeaponizedExploit, 0),
		ExploitKits:          make([]ExploitKitDetails, 0),
		AutomatedTools:       make([]AutomatedTool, 0),
		WeaponizationBarriers: make([]WeaponizationBarrier, 0),
		ConfidenceLevel:      0.6,
	}

	// Determine weaponization level
	analysis.WeaponizationLevel = ea.determineWeaponizationLevel(vuln)
	
	// Find weaponized exploits
	analysis.WeaponizedExploits = ea.findWeaponizedExploits(vuln)
	
	// Find exploit kits
	analysis.ExploitKits = ea.findExploitKits(vuln)
	
	// Find automated tools
	analysis.AutomatedTools = ea.findAutomatedTools(vuln)
	
	// Analyze weaponization trend
	analysis.WeaponizationTrend = ea.analyzeWeaponizationTrend(vuln)
	
	// Estimate time to weaponization
	analysis.TimeToWeaponization = ea.estimateTimeToWeaponization(vuln)
	
	// Identify weaponization barriers
	analysis.WeaponizationBarriers = ea.identifyWeaponizationBarriers(vuln)

	return analysis, nil
}

func (ea *ExploitabilityAssessor) performAttackPathAnalysis(ctx context.Context, vuln *Vulnerability) (*AttackPathAnalysis, error) {
	analysis := &AttackPathAnalysis{
		PossibleAttackPaths:        make([]AttackPath, 0),
		PathComplexityDistribution: make(map[string]int),
		ConfidenceLevel:           0.7,
	}

	// Generate possible attack paths
	analysis.PossibleAttackPaths = ea.generatePossibleAttackPaths(vuln)
	
	// Find optimal attack path
	analysis.OptimalAttackPath = ea.findOptimalAttackPath(analysis.PossibleAttackPaths)
	
	// Calculate complexity distribution
	analysis.PathComplexityDistribution = ea.calculatePathComplexityDistribution(analysis.PossibleAttackPaths)
	
	// Calculate average path complexity
	analysis.AveragePathComplexity = ea.calculateAveragePathComplexity(analysis.PossibleAttackPaths)
	
	// Determine minimum skill required
	analysis.MinimumSkillRequired = ea.determineMinimumSkillRequired(analysis.PossibleAttackPaths)
	
	// Calculate path analysis metrics
	analysis.PathAnalysisMetrics = ea.calculatePathAnalysisMetrics(analysis.PossibleAttackPaths)

	return analysis, nil
}

func (ea *ExploitabilityAssessor) performEnvironmentalAnalysis(ctx context.Context, vuln *Vulnerability) (*EnvironmentalFactorAnalysis, error) {
	analysis := &EnvironmentalFactorAnalysis{
		EnvironmentalRiskFactors: make([]EnvironmentalRiskFactor, 0),
		ConfidenceLevel:         0.8,
	}

	// Analyze defense in depth
	analysis.DefenseInDepthAnalysis = ea.analyzeDefenseInDepth(vuln)
	
	// Analyze monitoring coverage
	analysis.MonitoringCoverage = ea.analyzeMonitoringCoverage(vuln)
	
	// Analyze security controls
	analysis.SecurityControlsAnalysis = ea.analyzeSecurityControls(vuln)
	
	// Analyze incident response readiness
	analysis.IncidentResponseReadiness = ea.analyzeIncidentResponseReadiness(vuln)
	
	// Analyze patching maturity
	analysis.PatchingMaturity = ea.analyzePatchingMaturity(vuln)
	
	// Calculate overall defensiveness
	analysis.OverallDefensiveness = ea.calculateOverallDefensiveness(analysis)
	
	// Generate environmental risk factors
	analysis.EnvironmentalRiskFactors = ea.generateEnvironmentalRiskFactors(vuln, analysis)

	return analysis, nil
}

// Calculate overall exploitability score
func (ea *ExploitabilityAssessor) calculateExploitabilityScore(result *ExploitabilityResult, vuln *Vulnerability) float64 {
	score := 0.0
	weights := 0.0

	// Technical complexity component
	if result.TechnicalAnalysis != nil {
		technicalScore := ea.calculateTechnicalScore(result.TechnicalAnalysis)
		score += technicalScore * ea.config.TechnicalComplexityWeight
		weights += ea.config.TechnicalComplexityWeight
	}

	// Accessibility component
	if result.AccessibilityAnalysis != nil {
		accessibilityScore := result.AccessibilityAnalysis.OverallAccessibility * 10.0
		score += accessibilityScore * ea.config.AccessibilityWeight
		weights += ea.config.AccessibilityWeight
	}

	// Weaponization component
	if result.WeaponizationAnalysis != nil {
		weaponizationScore := ea.calculateWeaponizationScore(result.WeaponizationAnalysis)
		score += weaponizationScore * ea.config.WeaponizationWeight
		weights += ea.config.WeaponizationWeight
	}

	// Attack path component
	if result.AttackPathAnalysis != nil {
		attackPathScore := ea.calculateAttackPathScore(result.AttackPathAnalysis)
		score += attackPathScore * ea.config.AttackPathWeight
		weights += ea.config.AttackPathWeight
	}

	// Environmental component
	if result.EnvironmentalAnalysis != nil {
		environmentalScore := (10.0 - result.EnvironmentalAnalysis.OverallDefensiveness)
		score += environmentalScore * ea.config.EnvironmentalWeight
		weights += ea.config.EnvironmentalWeight
	}

	// Calculate weighted average
	if weights > 0 {
		score = score / weights
	} else {
		score = 5.0 // Default medium score
	}

	// Apply temporal factors
	score = ea.applyTemporalFactors(score, vuln)

	return math.Min(score, 10.0)
}

// Helper methods (simplified implementations)
func (ea *ExploitabilityAssessor) extractCVSSExploitabilityScore(vuln *Vulnerability) float64 {
	// Extract CVSS exploitability sub-score
	// This would typically be parsed from CVSS vector string
	return vuln.CVSS * 0.4 // Simplified approximation
}

func (ea *ExploitabilityAssessor) determineAttackVector(vuln *Vulnerability) string {
	if vuln.NetworkContext.IsExternalFacing {
		return "network"
	}
	return "local"
}

func (ea *ExploitabilityAssessor) determineAttackComplexity(vuln *Vulnerability) string {
	if vuln.CVSS >= 9.0 {
		return "low"
	} else if vuln.CVSS >= 7.0 {
		return "medium"
	}
	return "high"
}

func (ea *ExploitabilityAssessor) determinePrivilegesRequired(vuln *Vulnerability) string {
	if strings.Contains(strings.ToLower(vuln.Description), "privilege") {
		return "high"
	} else if strings.Contains(strings.ToLower(vuln.Description), "user") {
		return "low"
	}
	return "none"
}

func (ea *ExploitabilityAssessor) determineUserInteraction(vuln *Vulnerability) string {
	if strings.Contains(strings.ToLower(vuln.Description), "click") ||
	   strings.Contains(strings.ToLower(vuln.Description), "phishing") {
		return "required"
	}
	return "none"
}

func (ea *ExploitabilityAssessor) determineAuthenticationRequired(vuln *Vulnerability) bool {
	return strings.Contains(strings.ToLower(vuln.Description), "authentication")
}

func (ea *ExploitabilityAssessor) determineTechnicalSkillRequired(vuln *Vulnerability) string {
	complexity := ea.determineAttackComplexity(vuln)
	switch complexity {
	case "low":
		return "script_kiddie"
	case "medium":
		return "skilled"
	default:
		return "expert"
	}
}

func (ea *ExploitabilityAssessor) determineToolsRequired(vuln *Vulnerability) []string {
	tools := make([]string, 0)
	
	if strings.Contains(strings.ToLower(vuln.Description), "buffer") ||
	   strings.Contains(strings.ToLower(vuln.Description), "overflow") {
		tools = append(tools, "debugger", "exploit_framework")
	}
	
	if strings.Contains(strings.ToLower(vuln.Description), "injection") {
		tools = append(tools, "payload_generator", "web_proxy")
	}
	
	if len(tools) == 0 {
		tools = append(tools, "basic_tools")
	}
	
	return tools
}

func (ea *ExploitabilityAssessor) determinePrerequisiteKnowledge(vuln *Vulnerability) []string {
	knowledge := make([]string, 0)
	
	if strings.Contains(strings.ToLower(vuln.Description), "buffer") {
		knowledge = append(knowledge, "memory_management", "assembly_language")
	}
	
	if strings.Contains(strings.ToLower(vuln.Description), "web") {
		knowledge = append(knowledge, "web_technologies", "http_protocol")
	}
	
	if len(knowledge) == 0 {
		knowledge = append(knowledge, "basic_security")
	}
	
	return knowledge
}

func (ea *ExploitabilityAssessor) estimateExploitationTimeframe(vuln *Vulnerability) time.Duration {
	complexity := ea.determineAttackComplexity(vuln)
	
	switch complexity {
	case "low":
		return time.Minute * 30
	case "medium":
		return time.Hour * 4
	default:
		return time.Hour * 24
	}
}

func (ea *ExploitabilityAssessor) calculateReliabilityScore(vuln *Vulnerability) float64 {
	baseScore := vuln.CVSS / 10.0
	
	if vuln.NetworkContext.IsExternalFacing {
		baseScore += 0.2
	}
	
	return math.Min(baseScore, 1.0)
}

func (ea *ExploitabilityAssessor) determineExploitabilityLevel(score float64) string {
	if score >= 8.0 {
		return "critical"
	} else if score >= 6.0 {
		return "high"
	} else if score >= 4.0 {
		return "medium"
	} else if score >= 2.0 {
		return "low"
	}
	return "minimal"
}

func (ea *ExploitabilityAssessor) calculateConfidence(result *ExploitabilityResult) float64 {
	confidences := make([]float64, 0)

	if result.TechnicalAnalysis != nil {
		confidences = append(confidences, result.TechnicalAnalysis.ConfidenceLevel)
	}
	if result.AccessibilityAnalysis != nil {
		confidences = append(confidences, result.AccessibilityAnalysis.ConfidenceLevel)
	}
	if result.WeaponizationAnalysis != nil {
		confidences = append(confidences, result.WeaponizationAnalysis.ConfidenceLevel)
	}

	if len(confidences) > 0 {
		total := 0.0
		for _, conf := range confidences {
			total += conf
		}
		return total / float64(len(confidences))
	}

	return 0.7 // Default confidence
}

func (ea *ExploitabilityAssessor) applyTemporalFactors(score float64, vuln *Vulnerability) float64 {
	age := time.Since(vuln.DiscoveryTime)
	
	// Newer vulnerabilities are often more exploitable
	if age < time.Hour*24*7 {
		score *= 1.2
	} else if age > time.Hour*24*365 {
		score *= 0.9
	}
	
	return score
}

// Placeholder implementations for complex analysis methods
func (ea *ExploitabilityAssessor) analyzeNetworkAccessibility(vuln *Vulnerability) NetworkAccessibilityInfo { 
	return NetworkAccessibilityInfo{
		InternetAccessible: vuln.NetworkContext.IsExternalFacing,
		AccessibilityScore: func() float64 {
			if vuln.NetworkContext.IsExternalFacing { return 9.0 }
			return 6.0
		}(),
	}
}
func (ea *ExploitabilityAssessor) analyzePhysicalAccessibility(vuln *Vulnerability) PhysicalAccessibilityInfo { 
	return PhysicalAccessibilityInfo{AccessibilityScore: 3.0}
}
func (ea *ExploitabilityAssessor) analyzeLogicalAccessibility(vuln *Vulnerability) LogicalAccessibilityInfo { 
	return LogicalAccessibilityInfo{AccessibilityScore: 5.0}
}
func (ea *ExploitabilityAssessor) analyzeTemporalAccessibility(vuln *Vulnerability) TemporalAccessibilityInfo { 
	return TemporalAccessibilityInfo{AccessibilityScore: 7.0}
}
func (ea *ExploitabilityAssessor) calculateOverallAccessibility(analysis *AccessibilityAnalysis) float64 { 
	return (analysis.NetworkAccessibility.AccessibilityScore + 
			analysis.PhysicalAccessibility.AccessibilityScore + 
			analysis.LogicalAccessibility.AccessibilityScore + 
			analysis.TemporalAccessibility.AccessibilityScore) / 40.0
}
func (ea *ExploitabilityAssessor) identifyAccessibilityBarriers(vuln *Vulnerability, analysis *AccessibilityAnalysis) []AccessibilityBarrier { return []AccessibilityBarrier{} }
func (ea *ExploitabilityAssessor) determineWeaponizationLevel(vuln *Vulnerability) string { return "proof_of_concept" }
func (ea *ExploitabilityAssessor) findWeaponizedExploits(vuln *Vulnerability) []WeaponizedExploit { return []WeaponizedExploit{} }
func (ea *ExploitabilityAssessor) findExploitKits(vuln *Vulnerability) []ExploitKitDetails { return []ExploitKitDetails{} }
func (ea *ExploitabilityAssessor) findAutomatedTools(vuln *Vulnerability) []AutomatedTool { return []AutomatedTool{} }
func (ea *ExploitabilityAssessor) analyzeWeaponizationTrend(vuln *Vulnerability) string { return "increasing" }
func (ea *ExploitabilityAssessor) estimateTimeToWeaponization(vuln *Vulnerability) time.Duration { return time.Hour * 24 * 30 }
func (ea *ExploitabilityAssessor) identifyWeaponizationBarriers(vuln *Vulnerability) []WeaponizationBarrier { return []WeaponizationBarrier{} }
func (ea *ExploitabilityAssessor) generatePossibleAttackPaths(vuln *Vulnerability) []AttackPath { return []AttackPath{} }
func (ea *ExploitabilityAssessor) findOptimalAttackPath(paths []AttackPath) *AttackPath { return nil }
func (ea *ExploitabilityAssessor) calculatePathComplexityDistribution(paths []AttackPath) map[string]int { return make(map[string]int) }
func (ea *ExploitabilityAssessor) calculateAveragePathComplexity(paths []AttackPath) float64 { return 5.0 }
func (ea *ExploitabilityAssessor) determineMinimumSkillRequired(paths []AttackPath) string { return "intermediate" }
func (ea *ExploitabilityAssessor) calculatePathAnalysisMetrics(paths []AttackPath) AttackPathMetrics { return AttackPathMetrics{} }
func (ea *ExploitabilityAssessor) analyzeDefenseInDepth(vuln *Vulnerability) DefenseInDepthAnalysis { return DefenseInDepthAnalysis{} }
func (ea *ExploitabilityAssessor) analyzeMonitoringCoverage(vuln *Vulnerability) MonitoringCoverageAnalysis { return MonitoringCoverageAnalysis{} }
func (ea *ExploitabilityAssessor) analyzeSecurityControls(vuln *Vulnerability) SecurityControlsAnalysis { return SecurityControlsAnalysis{} }
func (ea *ExploitabilityAssessor) analyzeIncidentResponseReadiness(vuln *Vulnerability) IncidentResponseAnalysis { return IncidentResponseAnalysis{} }
func (ea *ExploitabilityAssessor) analyzePatchingMaturity(vuln *Vulnerability) PatchingMaturityAnalysis { return PatchingMaturityAnalysis{} }
func (ea *ExploitabilityAssessor) calculateOverallDefensiveness(analysis *EnvironmentalFactorAnalysis) float64 { return 6.0 }
func (ea *ExploitabilityAssessor) generateEnvironmentalRiskFactors(vuln *Vulnerability, analysis *EnvironmentalFactorAnalysis) []EnvironmentalRiskFactor { return []EnvironmentalRiskFactor{} }
func (ea *ExploitabilityAssessor) analyzeExploitAvailability(vuln *Vulnerability, result *ExploitabilityResult) *ExploitAvailabilityInfo { return &ExploitAvailabilityInfo{} }
func (ea *ExploitabilityAssessor) generateAttackVectors(vuln *Vulnerability, result *ExploitabilityResult) []AttackVector { return []AttackVector{} }
func (ea *ExploitabilityAssessor) analyzeAttackComplexity(vuln *Vulnerability, result *ExploitabilityResult) AttackComplexityBreakdown { return AttackComplexityBreakdown{} }
func (ea *ExploitabilityAssessor) analyzeDefensiveEffectiveness(vuln *Vulnerability, result *ExploitabilityResult) []DefensiveMeasure { return []DefensiveMeasure{} }
func (ea *ExploitabilityAssessor) analyzeDetectionDifficulty(vuln *Vulnerability, result *ExploitabilityResult) DetectionDifficultyAnalysis { return DetectionDifficultyAnalysis{} }
func (ea *ExploitabilityAssessor) generateExploitabilityFactors(result *ExploitabilityResult, vuln *Vulnerability) {}
func (ea *ExploitabilityAssessor) generateMitigatingFactors(result *ExploitabilityResult, vuln *Vulnerability) {}
func (ea *ExploitabilityAssessor) generateAggravatingFactors(result *ExploitabilityResult, vuln *Vulnerability) {}
func (ea *ExploitabilityAssessor) analyzeExploitMaturity(vuln *Vulnerability, result *ExploitabilityResult) ExploitMaturityAnalysis { return ExploitMaturityAnalysis{} }
func (ea *ExploitabilityAssessor) analyzeTrends(vuln *Vulnerability, result *ExploitabilityResult) ExploitTrendAnalysis { return ExploitTrendAnalysis{} }
func (ea *ExploitabilityAssessor) applyCustomExploitabilityModels(result *ExploitabilityResult, vuln *Vulnerability) {}
func (ea *ExploitabilityAssessor) generateExploitabilityRecommendations(result *ExploitabilityResult, vuln *Vulnerability) {}
func (ea *ExploitabilityAssessor) calculateTechnicalScore(analysis *TechnicalExploitabilityAnalysis) float64 { 
	return 10.0 - (analysis.CVSSExploitabilityScore * 2.5)
}
func (ea *ExploitabilityAssessor) calculateWeaponizationScore(analysis *WeaponizationAnalysis) float64 { 
	switch analysis.WeaponizationLevel {
	case "not_weaponized": return 2.0
	case "proof_of_concept": return 5.0
	case "functional_exploit": return 7.0
	case "weaponized": return 9.0
	default: return 5.0
	}
}
func (ea *ExploitabilityAssessor) calculateAttackPathScore(analysis *AttackPathAnalysis) float64 { 
	return 10.0 - analysis.AveragePathComplexity
}

// Cache and statistics methods
func (ea *ExploitabilityAssessor) getCachedResult(vulnerabilityID string) *ExploitabilityResult {
	ea.cache.mutex.RLock()
	defer ea.cache.mutex.RUnlock()

	if !ea.cache.enabled {
		return nil
	}

	result, exists := ea.cache.cache[vulnerabilityID]
	if !exists {
		return nil
	}

	if ttl, exists := ea.cache.ttl[vulnerabilityID]; exists {
		if time.Now().After(ttl) {
			delete(ea.cache.cache, vulnerabilityID)
			delete(ea.cache.ttl, vulnerabilityID)
			return nil
		}
	}

	return result
}

func (ea *ExploitabilityAssessor) cacheResult(vulnerabilityID string, result *ExploitabilityResult) {
	ea.cache.mutex.Lock()
	defer ea.cache.mutex.Unlock()

	if !ea.cache.enabled {
		return
	}

	if len(ea.cache.cache) >= ea.cache.maxSize {
		// Simple eviction
		for id := range ea.cache.cache {
			delete(ea.cache.cache, id)
			delete(ea.cache.ttl, id)
			break
		}
	}

	ea.cache.cache[vulnerabilityID] = result
	ea.cache.ttl[vulnerabilityID] = time.Now().Add(ea.config.CacheExpiration)
}

func (ea *ExploitabilityAssessor) updateCacheHitStats(hit bool) {
	ea.cache.mutex.Lock()
	defer ea.cache.mutex.Unlock()

	if hit {
		ea.cache.hitCount++
	} else {
		ea.cache.missCount++
	}
}

func (ea *ExploitabilityAssessor) updateStatistics(result *ExploitabilityResult) {
	ea.mutex.Lock()
	defer ea.mutex.Unlock()

	ea.statistics.TotalAssessments++

	// Update average exploitability score
	totalScore := ea.statistics.AverageExploitabilityScore * float64(ea.statistics.TotalAssessments-1)
	totalScore += result.ExploitabilityScore
	ea.statistics.AverageExploitabilityScore = totalScore / float64(ea.statistics.TotalAssessments)

	// Update exploitability level distribution
	ea.statistics.ExploitabilityDistribution[result.ExploitabilityLevel]++

	// Update exploit availability rate
	if result.ExploitAvailability != nil && result.ExploitAvailability.PublicExploitsAvailable {
		ea.statistics.ExploitAvailabilityRate = float64(ea.statistics.TotalAssessments-1)/float64(ea.statistics.TotalAssessments)*ea.statistics.ExploitAvailabilityRate + 1.0/float64(ea.statistics.TotalAssessments)
	}

	ea.statistics.LastUpdate = time.Now()
}

// GetStatistics returns current exploitability statistics
func (ea *ExploitabilityAssessor) GetStatistics() ExploitabilityStatistics {
	ea.mutex.RLock()
	defer ea.mutex.RUnlock()
	return ea.statistics
}