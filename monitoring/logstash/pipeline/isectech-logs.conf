# iSECTECH Logstash Pipeline Configuration
# Production-grade log processing pipeline for security platform

# ═══════════════════════════════════════════════════════════════════════════════
# INPUT CONFIGURATION
# ═══════════════════════════════════════════════════════════════════════════════

input {
  # Beats input for Filebeat/Metricbeat
  beats {
    port => 5044
    type => "beats"
  }

  # Syslog input for system logs
  syslog {
    port => 5514
    type => "syslog"
  }

  # HTTP input for application logs
  http {
    port => 8080
    type => "http"
    codec => json
    additional_codecs => {
      "application/json" => "json"
    }
  }

  # Kafka input for high-volume logs
  kafka {
    bootstrap_servers => "kafka:9092"
    topics => ["application-logs", "security-logs", "audit-logs"]
    consumer_threads => 4
    type => "kafka"
  }

  # TCP input for structured logs
  tcp {
    port => 5000
    type => "tcp"
    codec => json_lines
  }

  # UDP input for high-throughput logs
  udp {
    port => 5001
    type => "udp"
    codec => json
  }
}

# ═══════════════════════════════════════════════════════════════════════════════
# FILTER CONFIGURATION
# ═══════════════════════════════════════════════════════════════════════════════

filter {
  # Add common fields
  mutate {
    add_field => { 
      "[@metadata][index_prefix]" => "logs-isectech"
      "[@metadata][environment]" => "production"
      "[@metadata][project]" => "isectech"
    }
  }

  # Parse timestamp
  if [timestamp] {
    date {
      match => [ "timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss.SSS", "yyyy-MM-dd HH:mm:ss" ]
      target => "@timestamp"
    }
  }

  # Application log processing
  if [type] == "application" or [service] {
    # Parse JSON application logs
    if [message] =~ /^\{.*\}$/ {
      json {
        source => "message"
        target => "app"
      }
    }

    # Extract trace information
    if [trace_id] {
      mutate {
        add_field => { "tracing.trace_id" => "%{trace_id}" }
      }
    }

    if [span_id] {
      mutate {
        add_field => { "tracing.span_id" => "%{span_id}" }
      }
    }

    # Service name normalization
    if [service] {
      mutate {
        lowercase => ["service"]
        gsub => ["service", "[^a-z0-9-]", "-"]
      }
    }

    # Log level normalization
    if [level] {
      mutate {
        uppercase => ["level"]
      }
    }

    # Set index pattern for application logs
    mutate {
      replace => { "[@metadata][index_prefix]" => "logs-isectech-application" }
    }
  }

  # Security log processing
  if [type] == "security" or [event_type] {
    # Parse security events
    if [event_type] {
      mutate {
        add_field => { "security.event_type" => "%{event_type}" }
      }
    }

    # IP address geolocation
    if [source_ip] {
      geoip {
        source => "source_ip"
        target => "geoip"
        add_field => [ "security.source_country", "%{[geoip][country_name]}" ]
      }
    }

    # User agent parsing
    if [user_agent] {
      useragent {
        source => "user_agent"
        target => "ua"
      }
    }

    # Threat intelligence enrichment
    if [source_ip] {
      # Add threat intelligence lookup (placeholder for external service)
      mutate {
        add_field => { "[@metadata][threat_lookup]" => "%{source_ip}" }
      }
    }

    # Authentication event processing
    if [action] == "login" or [action] == "logout" {
      mutate {
        add_field => { "security.auth_event" => "true" }
      }
    }

    # Set index pattern for security logs
    mutate {
      replace => { "[@metadata][index_prefix]" => "logs-isectech-security" }
    }
  }

  # System log processing
  if [type] == "syslog" or [program] {
    # Parse syslog format
    grok {
      match => { 
        "message" => "%{SYSLOGTIMESTAMP:syslog_timestamp} %{IPORHOST:hostname} %{DATA:program}(?:\[%{POSINT:pid}\])?: %{GREEDYDATA:syslog_message}"
      }
    }

    # Parse syslog timestamp
    if [syslog_timestamp] {
      date {
        match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
        target => "@timestamp"
      }
    }

    # Set index pattern for system logs
    mutate {
      replace => { "[@metadata][index_prefix]" => "logs-isectech-system" }
    }
  }

  # Kubernetes log processing
  if [kubernetes] {
    # Parse Kubernetes metadata
    if [kubernetes][pod] {
      mutate {
        add_field => { 
          "k8s.pod_name" => "%{[kubernetes][pod][name]}"
          "k8s.namespace" => "%{[kubernetes][namespace]}"
          "k8s.container" => "%{[kubernetes][container][name]}"
        }
      }
    }

    # Set index pattern for Kubernetes logs
    mutate {
      replace => { "[@metadata][index_prefix]" => "logs-isectech-kubernetes" }
    }
  }

  # Database log processing
  if [type] == "database" or [program] =~ /postgres|mysql|redis/ {
    # PostgreSQL log parsing
    if [program] == "postgres" {
      grok {
        match => { 
          "message" => "%{TIMESTAMP_ISO8601:db_timestamp} %{WORD:timezone} \[%{POSINT:pid}\] %{WORD:level}: %{GREEDYDATA:db_message}"
        }
      }
    }

    # Set index pattern for database logs
    mutate {
      replace => { "[@metadata][index_prefix]" => "logs-isectech-database" }
    }
  }

  # Audit log processing
  if [type] == "audit" or [audit_id] {
    # Parse audit events
    if [audit_id] {
      mutate {
        add_field => { "audit.id" => "%{audit_id}" }
      }
    }

    if [user] {
      mutate {
        add_field => { "audit.user" => "%{user}" }
      }
    }

    if [verb] {
      mutate {
        add_field => { "audit.action" => "%{verb}" }
      }
    }

    # Set index pattern for audit logs
    mutate {
      replace => { "[@metadata][index_prefix]" => "logs-isectech-audit" }
    }
  }

  # Web server log processing
  if [type] == "nginx" or [type] == "apache" {
    # Parse access logs
    if [message] =~ /^\d+\.\d+\.\d+\.\d+/ {
      grok {
        match => { 
          "message" => "%{COMBINEDAPACHELOG}"
        }
      }

      # Parse response time if present
      if [response_time] {
        mutate {
          convert => { "response_time" => "float" }
        }
      }
    }

    # Set index pattern for web logs
    mutate {
      replace => { "[@metadata][index_prefix]" => "logs-isectech-web" }
    }
  }

  # Error detection and classification
  if [level] =~ /(?i)error|fatal|critical/ or [message] =~ /(?i)error|exception|failed|fatal/ {
    mutate {
      add_field => { "error.detected" => "true" }
      add_field => { "alert.priority" => "high" }
    }

    # Extract stack traces
    if [message] =~ /(?i)stacktrace|stack trace/ {
      mutate {
        add_field => { "error.has_stacktrace" => "true" }
      }
    }
  }

  # Performance metrics extraction
  if [response_time] or [duration] or [elapsed] {
    if [response_time] {
      mutate {
        convert => { "response_time" => "float" }
        add_field => { "performance.response_time_ms" => "%{response_time}" }
      }
    }
  }

  # Clean up temporary fields
  mutate {
    remove_field => [ "host", "agent", "ecs", "log", "input" ]
  }

  # Final field mapping and cleanup
  mutate {
    rename => { 
      "message" => "log.message"
      "level" => "log.level"
      "service" => "service.name"
    }
  }
}

# ═══════════════════════════════════════════════════════════════════════════════
# OUTPUT CONFIGURATION
# ═══════════════════════════════════════════════════════════════════════════════

output {
  # Elasticsearch output
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "%{[@metadata][index_prefix]}-%{+YYYY.MM.dd}"
    template_name => "isectech-logs"
    template_pattern => "logs-isectech-*"
    template => "/usr/share/logstash/templates/isectech-template.json"
    template_overwrite => true
    
    # Authentication
    user => "elastic"
    password => "${ELASTIC_PASSWORD}"
    
    # Performance settings
    workers => 4
    flush_size => 1000
    idle_flush_time => 5
    
    # Retry configuration
    retry_on_conflict => 3
    retry_initial_interval => 2
    retry_max_interval => 64
  }

  # Send critical errors to separate alerting system
  if [alert][priority] == "high" {
    http {
      url => "http://alertmanager:9093/api/v1/alerts"
      http_method => "post"
      format => "json"
      mapping => {
        "alerts" => [
          {
            "labels" => {
              "alertname" => "LogError"
              "severity" => "critical"
              "service" => "%{[service][name]}"
              "instance" => "%{host}"
            }
            "annotations" => {
              "summary" => "Critical error detected in logs"
              "description" => "%{[log][message]}"
            }
          }
        ]
      }
    }
  }

  # Debug output for development
  if [@metadata][debug] == "true" {
    stdout {
      codec => rubydebug
    }
  }
}