// iSECTECH Vulnerability Scanner - Vulnerability Domain Entity
// Production-grade vulnerability data model for comprehensive security assessment
// Copyright (c) 2024 iSECTECH. All rights reserved.

package entity

import (
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
)

// Vulnerability represents a comprehensive security vulnerability
type Vulnerability struct {
	// Core identification
	ID       uuid.UUID `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
	TenantID uuid.UUID `json:"tenant_id" gorm:"type:uuid;not null;index"`
	AssetID  uuid.UUID `json:"asset_id" gorm:"type:uuid;not null;index"`

	// Vulnerability identification
	VulnerabilityID string `json:"vulnerability_id" gorm:"type:varchar(255);not null;index"` // CVE, CWE, custom ID
	Title           string `json:"title" gorm:"type:varchar(500);not null"`
	Description     string `json:"description" gorm:"type:text"`
	Synopsis        string `json:"synopsis" gorm:"type:text"`

	// Classification and severity
	Severity    SeverityLevel `json:"severity" gorm:"type:varchar(20);not null;index"`
	CVSSScore   float64       `json:"cvss_score" gorm:"index"`
	CVSSVector  string        `json:"cvss_vector" gorm:"type:varchar(255)"`
	CVSSVersion string        `json:"cvss_version" gorm:"type:varchar(10)"`
	EPSSScore   *float64      `json:"epss_score,omitempty"` // Exploit Prediction Scoring System
	Category    VulnCategory  `json:"category" gorm:"type:varchar(50);index"`
	VulnType    VulnType      `json:"vuln_type" gorm:"type:varchar(50);index"`

	// Affected component details
	Component        ComponentInfo `json:"component" gorm:"embedded;embeddedPrefix:component_"`
	AffectedSoftware SoftwareInfo  `json:"affected_software" gorm:"embedded;embeddedPrefix:software_"`
	Location         VulnLocation  `json:"location" gorm:"embedded;embeddedPrefix:location_"`

	// Risk assessment
	RiskScore         float64           `json:"risk_score" gorm:"index"`
	BusinessImpact    BusinessImpact    `json:"business_impact" gorm:"type:varchar(20);index"`
	ExploitComplexity ExploitComplexity `json:"exploit_complexity" gorm:"type:varchar(20)"`
	AttackVector      AttackVector      `json:"attack_vector" gorm:"type:varchar(20)"`
	AttackComplexity  AttackComplexity  `json:"attack_complexity" gorm:"type:varchar(20)"`

	// Exploitation information
	ExploitAvailable  bool            `json:"exploit_available"`
	ExploitPublic     bool            `json:"exploit_public"`
	ExploitMaturity   ExploitMaturity `json:"exploit_maturity" gorm:"type:varchar(20)"`
	WeaponizedExploit bool            `json:"weaponized_exploit"`

	// Threat intelligence
	ThreatActors  []string           `json:"threat_actors" gorm:"type:jsonb"`
	IOCs          []IOC              `json:"iocs" gorm:"type:jsonb"`
	KnownExploits []ExploitReference `json:"known_exploits" gorm:"type:jsonb"`

	// References and compliance
	References       []VulnReference    `json:"references" gorm:"type:jsonb"`
	ComplianceImpact []ComplianceImpact `json:"compliance_impact" gorm:"type:jsonb"`
	Advisories       []SecurityAdvisory `json:"advisories" gorm:"type:jsonb"`

	// Detection and discovery
	Scanner           ScannerInfo `json:"scanner" gorm:"embedded;embeddedPrefix:scanner_"`
	ScanID            uuid.UUID   `json:"scan_id" gorm:"type:uuid;index"`
	DiscoveredAt      time.Time   `json:"discovered_at" gorm:"not null;index"`
	LastVerified      time.Time   `json:"last_verified" gorm:"index"`
	VerificationCount int         `json:"verification_count" gorm:"default:1"`

	// Remediation information
	Remediation     RemediationInfo `json:"remediation" gorm:"embedded;embeddedPrefix:remediation_"`
	Workaround      string          `json:"workaround" gorm:"type:text"`
	PatchAvailable  bool            `json:"patch_available"`
	PatchComplexity PatchComplexity `json:"patch_complexity" gorm:"type:varchar(20)"`

	// Status and lifecycle
	Status          VulnStatus     `json:"status" gorm:"type:varchar(20);not null;index;default:'open'"`
	Resolution      VulnResolution `json:"resolution" gorm:"type:varchar(30)"`
	ResolutionDate  *time.Time     `json:"resolution_date,omitempty"`
	ResolutionBy    string         `json:"resolution_by" gorm:"type:varchar(100)"`
	ResolutionNotes string         `json:"resolution_notes" gorm:"type:text"`

	// Risk acceptance and exceptions
	RiskAccepted     bool           `json:"risk_accepted"`
	AcceptanceReason string         `json:"acceptance_reason" gorm:"type:text"`
	AcceptedBy       string         `json:"accepted_by" gorm:"type:varchar(100)"`
	AcceptanceExpiry *time.Time     `json:"acceptance_expiry,omitempty"`
	Exception        *VulnException `json:"exception,omitempty" gorm:"type:jsonb"`

	// SLA and compliance tracking
	SLATarget        time.Time        `json:"sla_target" gorm:"index"`
	SLAStatus        SLAStatus        `json:"sla_status" gorm:"type:varchar(20);index"`
	ComplianceStatus ComplianceStatus `json:"compliance_status" gorm:"type:varchar(20)"`

	// Analysis and validation
	FalsePositive  bool       `json:"false_positive"`
	FPReason       string     `json:"fp_reason" gorm:"type:text"`
	ValidatedBy    string     `json:"validated_by" gorm:"type:varchar(100)"`
	ValidationDate *time.Time `json:"validation_date,omitempty"`
	AnalysisNotes  string     `json:"analysis_notes" gorm:"type:text"`

	// Metadata and context
	Tags         []VulnTag         `json:"tags" gorm:"type:jsonb"`
	CustomFields map[string]string `json:"custom_fields" gorm:"type:jsonb"`
	Evidence     []Evidence        `json:"evidence" gorm:"type:jsonb"`
	Artifacts    []Artifact        `json:"artifacts" gorm:"type:jsonb"`

	// Audit information
	CreatedAt     time.Time    `json:"created_at" gorm:"not null"`
	UpdatedAt     time.Time    `json:"updated_at" gorm:"not null"`
	CreatedBy     string       `json:"created_by" gorm:"type:varchar(100)"`
	UpdatedBy     string       `json:"updated_by" gorm:"type:varchar(100)"`
	ChangeHistory []VulnChange `json:"change_history" gorm:"type:jsonb"`
}

// SeverityLevel represents vulnerability severity levels
type SeverityLevel string

const (
	SeverityCritical SeverityLevel = "critical"
	SeverityHigh     SeverityLevel = "high"
	SeverityMedium   SeverityLevel = "medium"
	SeverityLow      SeverityLevel = "low"
	SeverityInfo     SeverityLevel = "info"
	SeverityUnknown  SeverityLevel = "unknown"
)

// VulnCategory represents vulnerability categories
type VulnCategory string

const (
	CategorySoftware      VulnCategory = "software"
	CategoryConfiguration VulnCategory = "configuration"
	CategoryNetwork       VulnCategory = "network"
	CategoryApplication   VulnCategory = "application"
	CategorySystem        VulnCategory = "system"
	CategoryDatabase      VulnCategory = "database"
	CategoryWeb           VulnCategory = "web"
	CategoryMobile        VulnCategory = "mobile"
	CategoryCloud         VulnCategory = "cloud"
	CategoryContainer     VulnCategory = "container"
	CategoryIoT           VulnCategory = "iot"
	CategoryPhysical      VulnCategory = "physical"
)

// VulnType represents specific vulnerability types
type VulnType string

const (
	TypeBufferOverflow        VulnType = "buffer_overflow"
	TypeSQLInjection          VulnType = "sql_injection"
	TypeXSS                   VulnType = "xss"
	TypeCSRF                  VulnType = "csrf"
	TypePrivilegeEscalation   VulnType = "privilege_escalation"
	TypeCodeInjection         VulnType = "code_injection"
	TypePathTraversal         VulnType = "path_traversal"
	TypeDenialOfService       VulnType = "denial_of_service"
	TypeCryptographic         VulnType = "cryptographic"
	TypeAuthentication        VulnType = "authentication"
	TypeAuthorization         VulnType = "authorization"
	TypeInformationDisclosure VulnType = "information_disclosure"
	TypeMissingPatch          VulnType = "missing_patch"
	TypeMisconfiguration      VulnType = "misconfiguration"
	TypeWeakCredentials       VulnType = "weak_credentials"
	TypeInsecureDefaults      VulnType = "insecure_defaults"
	TypeSupplyChain           VulnType = "supply_chain"
	TypeMalware               VulnType = "malware"
	TypeRootkit               VulnType = "rootkit"
	TypeBackdoor              VulnType = "backdoor"
	TypeOther                 VulnType = "other"
)

// BusinessImpact represents business impact levels
type BusinessImpact string

const (
	BusinessImpactCritical BusinessImpact = "critical"
	BusinessImpactHigh     BusinessImpact = "high"
	BusinessImpactMedium   BusinessImpact = "medium"
	BusinessImpactLow      BusinessImpact = "low"
	BusinessImpactNone     BusinessImpact = "none"
)

// ExploitComplexity represents exploitation complexity
type ExploitComplexity string

const (
	ExploitComplexityLow    ExploitComplexity = "low"
	ExploitComplexityMedium ExploitComplexity = "medium"
	ExploitComplexityHigh   ExploitComplexity = "high"
)

// AttackVector represents attack vectors
type AttackVector string

const (
	AttackVectorNetwork  AttackVector = "network"
	AttackVectorAdjacent AttackVector = "adjacent"
	AttackVectorLocal    AttackVector = "local"
	AttackVectorPhysical AttackVector = "physical"
)

// AttackComplexity represents attack complexity
type AttackComplexity string

const (
	AttackComplexityLow  AttackComplexity = "low"
	AttackComplexityHigh AttackComplexity = "high"
)

// ExploitMaturity represents exploit maturity levels
type ExploitMaturity string

const (
	ExploitMaturityNone       ExploitMaturity = "none"
	ExploitMaturityUnproven   ExploitMaturity = "unproven"
	ExploitMaturityPOC        ExploitMaturity = "poc"
	ExploitMaturityFunctional ExploitMaturity = "functional"
	ExploitMaturityHigh       ExploitMaturity = "high"
)

// VulnStatus represents vulnerability status
type VulnStatus string

const (
	VulnStatusOpen          VulnStatus = "open"
	VulnStatusInProgress    VulnStatus = "in_progress"
	VulnStatusResolved      VulnStatus = "resolved"
	VulnStatusClosed        VulnStatus = "closed"
	VulnStatusSuppressed    VulnStatus = "suppressed"
	VulnStatusAccepted      VulnStatus = "accepted"
	VulnStatusDuplicate     VulnStatus = "duplicate"
	VulnStatusFalsePositive VulnStatus = "false_positive"
)

// VulnResolution represents resolution types
type VulnResolution string

const (
	ResolutionFixed           VulnResolution = "fixed"
	ResolutionPatched         VulnResolution = "patched"
	ResolutionMitigated       VulnResolution = "mitigated"
	ResolutionWorkaround      VulnResolution = "workaround"
	ResolutionAccepted        VulnResolution = "accepted"
	ResolutionNotReproducible VulnResolution = "not_reproducible"
	ResolutionWontFix         VulnResolution = "wont_fix"
	ResolutionDuplicate       VulnResolution = "duplicate"
)

// PatchComplexity represents patching complexity
type PatchComplexity string

const (
	PatchComplexityLow     PatchComplexity = "low"
	PatchComplexityMedium  PatchComplexity = "medium"
	PatchComplexityHigh    PatchComplexity = "high"
	PatchComplexityExtreme PatchComplexity = "extreme"
)

// SLAStatus represents SLA compliance status
type SLAStatus string

const (
	SLAStatusMet      SLAStatus = "met"
	SLAStatusAtRisk   SLAStatus = "at_risk"
	SLAStatusBreached SLAStatus = "breached"
	SLAStatusExtended SLAStatus = "extended"
)

// ComplianceStatus represents compliance status
type ComplianceStatus string

const (
	ComplianceStatusCompliant    ComplianceStatus = "compliant"
	ComplianceStatusNonCompliant ComplianceStatus = "non_compliant"
	ComplianceStatusExempt       ComplianceStatus = "exempt"
	ComplianceStatusPending      ComplianceStatus = "pending"
)

// ComponentInfo represents affected component information
type ComponentInfo struct {
	Name         string `json:"name"`
	Type         string `json:"type"`
	Version      string `json:"version"`
	Path         string `json:"path,omitempty"`
	Architecture string `json:"architecture,omitempty"`
	Package      string `json:"package,omitempty"`
	Service      string `json:"service,omitempty"`
	Process      string `json:"process,omitempty"`
	Port         int    `json:"port,omitempty"`
	Protocol     string `json:"protocol,omitempty"`
}

// SoftwareInfo represents software information
type SoftwareInfo struct {
	Vendor           string `json:"vendor"`
	Product          string `json:"product"`
	Version          string `json:"version"`
	VersionCondition string `json:"version_condition,omitempty"` // <, <=, =, >=, >
	CPE              string `json:"cpe,omitempty"`
	SWID             string `json:"swid,omitempty"`
	PURL             string `json:"purl,omitempty"`
}

// VulnLocation represents vulnerability location
type VulnLocation struct {
	URL        string `json:"url,omitempty"`
	Hostname   string `json:"hostname,omitempty"`
	IPAddress  string `json:"ip_address,omitempty"`
	Port       int    `json:"port,omitempty"`
	Protocol   string `json:"protocol,omitempty"`
	Service    string `json:"service,omitempty"`
	FilePath   string `json:"file_path,omitempty"`
	LineNumber int    `json:"line_number,omitempty"`
	Function   string `json:"function,omitempty"`
	Parameter  string `json:"parameter,omitempty"`
}

// IOC represents Indicator of Compromise
type IOC struct {
	Type        string    `json:"type"`
	Value       string    `json:"value"`
	Confidence  float64   `json:"confidence"`
	Source      string    `json:"source"`
	FirstSeen   time.Time `json:"first_seen"`
	LastSeen    time.Time `json:"last_seen"`
	Description string    `json:"description,omitempty"`
}

// ExploitReference represents exploit reference information
type ExploitReference struct {
	ID          string    `json:"id"`
	Type        string    `json:"type"`
	URL         string    `json:"url"`
	Description string    `json:"description"`
	Reliability string    `json:"reliability"`
	PublishedAt time.Time `json:"published_at"`
	Source      string    `json:"source"`
}

// VulnReference represents vulnerability references
type VulnReference struct {
	Type string `json:"type"`
	URL  string `json:"url"`
	Name string `json:"name,omitempty"`
}

// ComplianceImpact represents compliance framework impact
type ComplianceImpact struct {
	Framework string     `json:"framework"`
	Controls  []string   `json:"controls"`
	Impact    string     `json:"impact"`
	Required  bool       `json:"required"`
	Deadline  *time.Time `json:"deadline,omitempty"`
}

// SecurityAdvisory represents security advisory information
type SecurityAdvisory struct {
	ID          string     `json:"id"`
	Title       string     `json:"title"`
	Publisher   string     `json:"publisher"`
	URL         string     `json:"url"`
	PublishedAt time.Time  `json:"published_at"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
	Severity    string     `json:"severity"`
}

// ScannerInfo represents scanner information
type ScannerInfo struct {
	Name       string  `json:"name"`
	Type       string  `json:"type"`
	Version    string  `json:"version"`
	Engine     string  `json:"engine,omitempty"`
	Plugin     string  `json:"plugin,omitempty"`
	PluginID   string  `json:"plugin_id,omitempty"`
	Signature  string  `json:"signature,omitempty"`
	Confidence float64 `json:"confidence"`
}

// RemediationInfo represents remediation information
type RemediationInfo struct {
	Solution      string                `json:"solution"`
	Steps         []string              `json:"steps"`
	Effort        string                `json:"effort"`
	Timeline      string                `json:"timeline"`
	Cost          string                `json:"cost,omitempty"`
	Risk          string                `json:"risk"`
	Prerequisites []string              `json:"prerequisites,omitempty"`
	Resources     []RemediationResource `json:"resources,omitempty"`
}

// RemediationResource represents remediation resources
type RemediationResource struct {
	Type        string `json:"type"`
	Name        string `json:"name"`
	URL         string `json:"url"`
	Description string `json:"description,omitempty"`
}

// VulnException represents vulnerability exception information
type VulnException struct {
	ID                   uuid.UUID `json:"id"`
	Reason               string    `json:"reason"`
	Justification        string    `json:"justification"`
	CompensatingControls []string  `json:"compensating_controls"`
	ApprovedBy           string    `json:"approved_by"`
	ApprovedAt           time.Time `json:"approved_at"`
	ExpiresAt            time.Time `json:"expires_at"`
	ReviewDate           time.Time `json:"review_date"`
	Conditions           []string  `json:"conditions,omitempty"`
}

// VulnTag represents vulnerability tags
type VulnTag struct {
	Key       string    `json:"key"`
	Value     string    `json:"value"`
	Source    string    `json:"source"`
	CreatedAt time.Time `json:"created_at"`
}

// Evidence represents vulnerability evidence
type Evidence struct {
	Type        string                 `json:"type"`
	Description string                 `json:"description"`
	Data        map[string]interface{} `json:"data"`
	Timestamp   time.Time              `json:"timestamp"`
	Source      string                 `json:"source"`
	Confidence  float64                `json:"confidence"`
}

// Artifact represents vulnerability artifacts
type Artifact struct {
	ID          uuid.UUID `json:"id"`
	Type        string    `json:"type"`
	Name        string    `json:"name"`
	Path        string    `json:"path"`
	Size        int64     `json:"size"`
	Hash        string    `json:"hash"`
	ContentType string    `json:"content_type"`
	CreatedAt   time.Time `json:"created_at"`
	Description string    `json:"description,omitempty"`
}

// VulnChange represents vulnerability change history
type VulnChange struct {
	Timestamp time.Time   `json:"timestamp"`
	User      string      `json:"user"`
	Operation string      `json:"operation"`
	Field     string      `json:"field,omitempty"`
	OldValue  interface{} `json:"old_value,omitempty"`
	NewValue  interface{} `json:"new_value,omitempty"`
	Reason    string      `json:"reason,omitempty"`
	IPAddress string      `json:"ip_address,omitempty"`
	UserAgent string      `json:"user_agent,omitempty"`
}

// TableName returns the database table name for Vulnerability
func (Vulnerability) TableName() string {
	return "vulnerabilities"
}

// GenerateFingerprint generates a unique fingerprint for the vulnerability
func (v *Vulnerability) GenerateFingerprint() string {
	data := fmt.Sprintf("%s|%s|%s|%s|%s|%s",
		v.VulnerabilityID,
		v.AssetID.String(),
		v.Component.Name,
		v.Component.Version,
		v.Location.URL,
		v.Location.FilePath,
	)

	hash := sha256.Sum256([]byte(data))
	return hex.EncodeToString(hash[:])[:16]
}

// CalculateRiskScore calculates comprehensive risk score
func (v *Vulnerability) CalculateRiskScore() float64 {
	baseScore := v.CVSSScore
	if baseScore == 0 {
		baseScore = v.getSeverityScore()
	}

	// Asset criticality factor (from asset service)
	assetFactor := 1.0

	// Exploit availability factor
	exploitFactor := 1.0
	if v.ExploitAvailable {
		exploitFactor = 1.5
		if v.ExploitPublic {
			exploitFactor = 2.0
		}
		if v.WeaponizedExploit {
			exploitFactor = 2.5
		}
	}

	// EPSS factor
	epssFactor := 1.0
	if v.EPSSScore != nil {
		epssFactor = 1.0 + (*v.EPSSScore * 0.5)
	}

	// Business impact factor
	businessFactor := v.getBusinessImpactFactor()

	// Threat intelligence factor
	threatFactor := 1.0
	if len(v.ThreatActors) > 0 {
		threatFactor = 1.3
	}
	if len(v.IOCs) > 0 {
		threatFactor = 1.4
	}

	// Calculate final score
	riskScore := baseScore * assetFactor * exploitFactor * epssFactor * businessFactor * threatFactor

	// Cap at 100
	if riskScore > 100 {
		riskScore = 100
	}

	return riskScore
}

// CalculateSLATarget calculates SLA target based on severity and business impact
func (v *Vulnerability) CalculateSLATarget() time.Time {
	now := time.Now().UTC()

	var days int
	switch v.Severity {
	case SeverityCritical:
		days = 1
	case SeverityHigh:
		days = 7
	case SeverityMedium:
		days = 30
	case SeverityLow:
		days = 90
	case SeverityInfo:
		days = 180
	default:
		days = 30
	}

	// Adjust based on business impact
	switch v.BusinessImpact {
	case BusinessImpactCritical:
		days = int(float64(days) * 0.5) // Halve the time
	case BusinessImpactHigh:
		days = int(float64(days) * 0.75)
	case BusinessImpactLow:
		days = int(float64(days) * 1.5)
	case BusinessImpactNone:
		days = int(float64(days) * 2.0)
	}

	return now.AddDate(0, 0, days)
}

// IsExpired checks if vulnerability has exceeded its SLA
func (v *Vulnerability) IsExpired() bool {
	return time.Now().UTC().After(v.SLATarget)
}

// IsHighRisk determines if this is a high-risk vulnerability
func (v *Vulnerability) IsHighRisk() bool {
	return v.RiskScore >= 70 ||
		v.Severity == SeverityCritical ||
		(v.Severity == SeverityHigh && v.ExploitAvailable) ||
		v.BusinessImpact == BusinessImpactCritical
}

// RequiresImmediateAttention checks if vulnerability needs immediate attention
func (v *Vulnerability) RequiresImmediateAttention() bool {
	return v.Severity == SeverityCritical ||
		(v.Severity == SeverityHigh && v.WeaponizedExploit) ||
		v.BusinessImpact == BusinessImpactCritical ||
		(v.IsExpired() && v.RiskScore >= 50)
}

// GetComplianceRequirements returns applicable compliance requirements
func (v *Vulnerability) GetComplianceRequirements() []string {
	var frameworks []string
	for _, impact := range v.ComplianceImpact {
		if impact.Required {
			frameworks = append(frameworks, impact.Framework)
		}
	}
	return frameworks
}

// UpdateSLAStatus updates SLA status based on current time
func (v *Vulnerability) UpdateSLAStatus() {
	now := time.Now().UTC()
	timeToTarget := v.SLATarget.Sub(now)

	if timeToTarget < 0 {
		v.SLAStatus = SLAStatusBreached
	} else if timeToTarget < time.Hour*24 { // Less than 24 hours
		v.SLAStatus = SLAStatusAtRisk
	} else {
		v.SLAStatus = SLAStatusMet
	}
}

// AddTag adds a tag to the vulnerability
func (v *Vulnerability) AddTag(key, value, source string) {
	// Remove existing tag with same key
	for i, tag := range v.Tags {
		if tag.Key == key {
			v.Tags = append(v.Tags[:i], v.Tags[i+1:]...)
			break
		}
	}

	// Add new tag
	v.Tags = append(v.Tags, VulnTag{
		Key:       key,
		Value:     value,
		Source:    source,
		CreatedAt: time.Now().UTC(),
	})
}

// HasTag checks if vulnerability has a specific tag
func (v *Vulnerability) HasTag(key, value string) bool {
	for _, tag := range v.Tags {
		if tag.Key == key && tag.Value == value {
			return true
		}
	}
	return false
}

// AddEvidence adds evidence to the vulnerability
func (v *Vulnerability) AddEvidence(evidenceType, description, source string, data map[string]interface{}, confidence float64) {
	evidence := Evidence{
		Type:        evidenceType,
		Description: description,
		Data:        data,
		Timestamp:   time.Now().UTC(),
		Source:      source,
		Confidence:  confidence,
	}
	v.Evidence = append(v.Evidence, evidence)
}

// Validate performs business logic validation
func (v *Vulnerability) Validate() error {
	if v.TenantID == uuid.Nil {
		return ErrTenantIDRequired
	}

	if v.AssetID == uuid.Nil {
		return ErrAssetIDRequired
	}

	if v.VulnerabilityID == "" {
		return ErrVulnerabilityIDRequired
	}

	if v.Title == "" {
		return ErrTitleRequired
	}

	if v.Severity == "" {
		return ErrSeverityRequired
	}

	if v.CVSSScore < 0 || v.CVSSScore > 10 {
		return ErrInvalidCVSSScore
	}

	return nil
}

// Private helper methods

func (v *Vulnerability) getSeverityScore() float64 {
	switch v.Severity {
	case SeverityCritical:
		return 9.0
	case SeverityHigh:
		return 7.0
	case SeverityMedium:
		return 5.0
	case SeverityLow:
		return 3.0
	case SeverityInfo:
		return 1.0
	default:
		return 0.0
	}
}

func (v *Vulnerability) getBusinessImpactFactor() float64 {
	switch v.BusinessImpact {
	case BusinessImpactCritical:
		return 2.0
	case BusinessImpactHigh:
		return 1.5
	case BusinessImpactMedium:
		return 1.0
	case BusinessImpactLow:
		return 0.8
	case BusinessImpactNone:
		return 0.5
	default:
		return 1.0
	}
}

// Custom errors for vulnerability validation
var (
	ErrTenantIDRequired        = VulnerabilityError{Code: "TENANT_ID_REQUIRED", Message: "Tenant ID is required"}
	ErrAssetIDRequired         = VulnerabilityError{Code: "ASSET_ID_REQUIRED", Message: "Asset ID is required"}
	ErrVulnerabilityIDRequired = VulnerabilityError{Code: "VULNERABILITY_ID_REQUIRED", Message: "Vulnerability ID is required"}
	ErrTitleRequired           = VulnerabilityError{Code: "TITLE_REQUIRED", Message: "Title is required"}
	ErrSeverityRequired        = VulnerabilityError{Code: "SEVERITY_REQUIRED", Message: "Severity is required"}
	ErrInvalidCVSSScore        = VulnerabilityError{Code: "INVALID_CVSS_SCORE", Message: "CVSS score must be between 0 and 10"}
)

// VulnerabilityError represents vulnerability-specific errors
type VulnerabilityError struct {
	Code    string `json:"code"`
	Message string `json:"message"`
	Field   string `json:"field,omitempty"`
}

func (e VulnerabilityError) Error() string {
	return e.Message
}

// MarshalJSON implements custom JSON marshaling for Vulnerability
func (v *Vulnerability) MarshalJSON() ([]byte, error) {
	type Alias Vulnerability
	return json.Marshal(&struct {
		*Alias
		Fingerprint          string   `json:"fingerprint"`
		CalculatedRiskScore  float64  `json:"calculated_risk_score"`
		IsHighRisk           bool     `json:"is_high_risk"`
		RequiresAttention    bool     `json:"requires_attention"`
		DaysToSLA            int      `json:"days_to_sla"`
		ComplianceFrameworks []string `json:"compliance_frameworks"`
	}{
		Alias:                (*Alias)(v),
		Fingerprint:          v.GenerateFingerprint(),
		CalculatedRiskScore:  v.CalculateRiskScore(),
		IsHighRisk:           v.IsHighRisk(),
		RequiresAttention:    v.RequiresImmediateAttention(),
		DaysToSLA:            int(time.Until(v.SLATarget).Hours() / 24),
		ComplianceFrameworks: v.GetComplianceRequirements(),
	})
}
