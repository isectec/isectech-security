// iSECTECH Vulnerability Scanner - Scan Domain Entity
// Production-grade scan management and orchestration
// Copyright (c) 2024 iSECTECH. All rights reserved.

package entity

import (
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

// Scan represents a vulnerability scan job
type Scan struct {
	// Core identification
	ID          uuid.UUID `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
	TenantID    uuid.UUID `json:"tenant_id" gorm:"type:uuid;not null;index"`
	Name        string    `json:"name" gorm:"type:varchar(255);not null"`
	Description string    `json:"description" gorm:"type:text"`

	// Scan configuration
	ScanType      ScanType      `json:"scan_type" gorm:"type:varchar(50);not null;index"`
	ScanProfile   string        `json:"scan_profile" gorm:"type:varchar(100);index"`
	Scanner       string        `json:"scanner" gorm:"type:varchar(100);not null;index"`
	ScannerConfig ScannerConfig `json:"scanner_config" gorm:"type:jsonb"`

	// Target specification
	Targets      ScanTargets  `json:"targets" gorm:"embedded;embeddedPrefix:targets_"`
	AssetIDs     []uuid.UUID  `json:"asset_ids" gorm:"type:jsonb"`
	AssetFilters AssetFilters `json:"asset_filters" gorm:"type:jsonb"`

	// Scheduling and execution
	Schedule    *ScanSchedule `json:"schedule,omitempty" gorm:"type:jsonb"`
	Priority    ScanPriority  `json:"priority" gorm:"type:varchar(20);default:'medium'"`
	Concurrent  bool          `json:"concurrent" gorm:"default:false"`
	MaxDuration time.Duration `json:"max_duration" gorm:"default:3600000000000"` // 1 hour default

	// Status and lifecycle
	Status        ScanStatus    `json:"status" gorm:"type:varchar(20);not null;index;default:'pending'"`
	StartedAt     *time.Time    `json:"started_at,omitempty"`
	CompletedAt   *time.Time    `json:"completed_at,omitempty"`
	Duration      time.Duration `json:"duration"`
	Progress      float64       `json:"progress" gorm:"default:0"`
	CurrentTarget string        `json:"current_target" gorm:"type:varchar(255)"`

	// Results and metrics
	Results     ScanResults     `json:"results" gorm:"embedded;embeddedPrefix:results_"`
	Statistics  ScanStatistics  `json:"statistics" gorm:"embedded;embeddedPrefix:stats_"`
	Performance ScanPerformance `json:"performance" gorm:"embedded;embeddedPrefix:perf_"`

	// Error handling and diagnostics
	Errors    []ScanError            `json:"errors" gorm:"type:jsonb"`
	Warnings  []ScanWarning          `json:"warnings" gorm:"type:jsonb"`
	LogLevel  string                 `json:"log_level" gorm:"type:varchar(20);default:'info'"`
	DebugInfo map[string]interface{} `json:"debug_info" gorm:"type:jsonb"`

	// Integration and correlation
	ParentScanID  *uuid.UUID  `json:"parent_scan_id,omitempty" gorm:"type:uuid;index"`
	ChildScans    []uuid.UUID `json:"child_scans" gorm:"type:jsonb"`
	CampaignID    *uuid.UUID  `json:"campaign_id,omitempty" gorm:"type:uuid;index"`
	CorrelationID string      `json:"correlation_id" gorm:"type:varchar(255);index"`

	// Policy and compliance
	PolicyID       *uuid.UUID      `json:"policy_id,omitempty" gorm:"type:uuid"`
	ComplianceReqs []string        `json:"compliance_reqs" gorm:"type:jsonb"`
	ExclusionRules []ExclusionRule `json:"exclusion_rules" gorm:"type:jsonb"`

	// Security and access control
	CreatedBy     string        `json:"created_by" gorm:"type:varchar(100);not null"`
	UpdatedBy     string        `json:"updated_by" gorm:"type:varchar(100)"`
	Visibility    Visibility    `json:"visibility" gorm:"type:varchar(20);default:'private'"`
	AccessControl AccessControl `json:"access_control" gorm:"type:jsonb"`

	// Metadata and tagging
	Tags         []ScanTag         `json:"tags" gorm:"type:jsonb"`
	CustomFields map[string]string `json:"custom_fields" gorm:"type:jsonb"`
	ExternalRefs map[string]string `json:"external_refs" gorm:"type:jsonb"`

	// Audit information
	CreatedAt     time.Time    `json:"created_at" gorm:"not null"`
	UpdatedAt     time.Time    `json:"updated_at" gorm:"not null"`
	ChangeHistory []ScanChange `json:"change_history" gorm:"type:jsonb"`
}

// ScanType represents different types of vulnerability scans
type ScanType string

const (
	ScanTypeNetwork        ScanType = "network"
	ScanTypeWeb            ScanType = "web"
	ScanTypeDatabase       ScanType = "database"
	ScanTypeApplication    ScanType = "application"
	ScanTypeContainer      ScanType = "container"
	ScanTypeCloud          ScanType = "cloud"
	ScanTypeInfrastructure ScanType = "infrastructure"
	ScanTypeCode           ScanType = "code"
	ScanTypeMobile         ScanType = "mobile"
	ScanTypeAPI            ScanType = "api"
	ScanTypeWireless       ScanType = "wireless"
	ScanTypeConfiguration  ScanType = "configuration"
	ScanTypeCompliance     ScanType = "compliance"
	ScanTypeCredential     ScanType = "credential"
	ScanTypeMalware        ScanType = "malware"
	ScanTypeAgentBased     ScanType = "agent_based"
	ScanTypeComposite      ScanType = "composite"
)

// ScanPriority represents scan priority levels
type ScanPriority string

const (
	ScanPriorityCritical ScanPriority = "critical"
	ScanPriorityHigh     ScanPriority = "high"
	ScanPriorityMedium   ScanPriority = "medium"
	ScanPriorityLow      ScanPriority = "low"
)

// ScanStatus represents scan execution status
type ScanStatus string

const (
	ScanStatusPending   ScanStatus = "pending"
	ScanStatusQueued    ScanStatus = "queued"
	ScanStatusRunning   ScanStatus = "running"
	ScanStatusPaused    ScanStatus = "paused"
	ScanStatusCompleted ScanStatus = "completed"
	ScanStatusFailed    ScanStatus = "failed"
	ScanStatusCancelled ScanStatus = "cancelled"
	ScanStatusTimeout   ScanStatus = "timeout"
	ScanStatusPartial   ScanStatus = "partial"
)

// Visibility represents scan visibility levels
type Visibility string

const (
	VisibilityPrivate    Visibility = "private"
	VisibilityShared     Visibility = "shared"
	VisibilityPublic     Visibility = "public"
	VisibilityRestricted Visibility = "restricted"
)

// ScannerConfig represents scanner-specific configuration
type ScannerConfig struct {
	Engine         string                 `json:"engine"`
	Version        string                 `json:"version"`
	Profile        string                 `json:"profile"`
	Plugins        []PluginConfig         `json:"plugins,omitempty"`
	Settings       map[string]interface{} `json:"settings,omitempty"`
	Credentials    []CredentialRef        `json:"credentials,omitempty"`
	Performance    PerformanceConfig      `json:"performance"`
	Authentication AuthConfig             `json:"authentication,omitempty"`
}

// PluginConfig represents scanner plugin configuration
type PluginConfig struct {
	ID       string                 `json:"id"`
	Name     string                 `json:"name"`
	Version  string                 `json:"version,omitempty"`
	Enabled  bool                   `json:"enabled"`
	Settings map[string]interface{} `json:"settings,omitempty"`
}

// CredentialRef represents credential references
type CredentialRef struct {
	ID       uuid.UUID `json:"id"`
	Type     string    `json:"type"`
	Username string    `json:"username,omitempty"`
	Domain   string    `json:"domain,omitempty"`
	Purpose  string    `json:"purpose"`
}

// PerformanceConfig represents performance configuration
type PerformanceConfig struct {
	MaxConcurrent  int            `json:"max_concurrent"`
	Timeout        time.Duration  `json:"timeout"`
	RetryCount     int            `json:"retry_count"`
	ThrottleRate   int            `json:"throttle_rate"`
	BandwidthLimit int            `json:"bandwidth_limit,omitempty"`
	ResourceLimits ResourceLimits `json:"resource_limits"`
}

// ResourceLimits represents resource usage limits
type ResourceLimits struct {
	CPULimit     float64 `json:"cpu_limit,omitempty"`
	MemoryLimit  int64   `json:"memory_limit,omitempty"`
	DiskLimit    int64   `json:"disk_limit,omitempty"`
	NetworkLimit int64   `json:"network_limit,omitempty"`
}

// AuthConfig represents authentication configuration
type AuthConfig struct {
	Type         string            `json:"type"`
	Credentials  map[string]string `json:"credentials,omitempty"`
	Headers      map[string]string `json:"headers,omitempty"`
	Cookies      map[string]string `json:"cookies,omitempty"`
	Certificates []string          `json:"certificates,omitempty"`
}

// ScanTargets represents scan target specification
type ScanTargets struct {
	Networks       []NetworkTarget   `json:"networks,omitempty"`
	Hosts          []HostTarget      `json:"hosts,omitempty"`
	URLs           []URLTarget       `json:"urls,omitempty"`
	Applications   []AppTarget       `json:"applications,omitempty"`
	Repositories   []RepoTarget      `json:"repositories,omitempty"`
	CloudResources []CloudTarget     `json:"cloud_resources,omitempty"`
	Containers     []ContainerTarget `json:"containers,omitempty"`
}

// NetworkTarget represents network scan targets
type NetworkTarget struct {
	CIDR        string   `json:"cidr"`
	Ports       []string `json:"ports,omitempty"`
	Protocols   []string `json:"protocols,omitempty"`
	Exclusions  []string `json:"exclusions,omitempty"`
	Description string   `json:"description,omitempty"`
}

// HostTarget represents host scan targets
type HostTarget struct {
	Hostname    string   `json:"hostname,omitempty"`
	IPAddress   string   `json:"ip_address,omitempty"`
	Ports       []string `json:"ports,omitempty"`
	Services    []string `json:"services,omitempty"`
	Credentials []string `json:"credentials,omitempty"`
	Description string   `json:"description,omitempty"`
}

// URLTarget represents web application targets
type URLTarget struct {
	URL         string            `json:"url"`
	Method      string            `json:"method,omitempty"`
	Headers     map[string]string `json:"headers,omitempty"`
	Parameters  map[string]string `json:"parameters,omitempty"`
	Credentials []string          `json:"credentials,omitempty"`
	Scope       string            `json:"scope,omitempty"`
	Description string            `json:"description,omitempty"`
}

// AppTarget represents application scan targets
type AppTarget struct {
	Name         string   `json:"name"`
	Type         string   `json:"type"`
	Version      string   `json:"version,omitempty"`
	Path         string   `json:"path,omitempty"`
	Config       string   `json:"config,omitempty"`
	Dependencies []string `json:"dependencies,omitempty"`
	Description  string   `json:"description,omitempty"`
}

// RepoTarget represents code repository targets
type RepoTarget struct {
	URL         string   `json:"url"`
	Branch      string   `json:"branch,omitempty"`
	Commit      string   `json:"commit,omitempty"`
	Languages   []string `json:"languages,omitempty"`
	Exclusions  []string `json:"exclusions,omitempty"`
	Credentials []string `json:"credentials,omitempty"`
	Description string   `json:"description,omitempty"`
}

// CloudTarget represents cloud resource targets
type CloudTarget struct {
	Provider    string            `json:"provider"`
	Region      string            `json:"region,omitempty"`
	AccountID   string            `json:"account_id,omitempty"`
	Resources   []string          `json:"resources,omitempty"`
	Tags        map[string]string `json:"tags,omitempty"`
	Credentials []string          `json:"credentials,omitempty"`
	Description string            `json:"description,omitempty"`
}

// ContainerTarget represents container scan targets
type ContainerTarget struct {
	Image       string            `json:"image"`
	Tag         string            `json:"tag,omitempty"`
	Registry    string            `json:"registry,omitempty"`
	Runtime     string            `json:"runtime,omitempty"`
	Namespace   string            `json:"namespace,omitempty"`
	Labels      map[string]string `json:"labels,omitempty"`
	Description string            `json:"description,omitempty"`
}

// AssetFilters represents asset filtering criteria
type AssetFilters struct {
	AssetTypes        []string          `json:"asset_types,omitempty"`
	Criticalities     []string          `json:"criticalities,omitempty"`
	BusinessFunctions []string          `json:"business_functions,omitempty"`
	NetworkSegments   []string          `json:"network_segments,omitempty"`
	Tags              map[string]string `json:"tags,omitempty"`
	Owners            []string          `json:"owners,omitempty"`
	Locations         []string          `json:"locations,omitempty"`
	LastScanBefore    *time.Time        `json:"last_scan_before,omitempty"`
	CreatedAfter      *time.Time        `json:"created_after,omitempty"`
}

// ScanSchedule represents scan scheduling configuration
type ScanSchedule struct {
	Enabled   bool       `json:"enabled"`
	CronExpr  string     `json:"cron_expr"`
	Timezone  string     `json:"timezone,omitempty"`
	StartDate time.Time  `json:"start_date"`
	EndDate   *time.Time `json:"end_date,omitempty"`
	NextRun   time.Time  `json:"next_run"`
	LastRun   *time.Time `json:"last_run,omitempty"`
	MaxRuns   int        `json:"max_runs,omitempty"`
	RunCount  int        `json:"run_count"`
}

// ScanResults represents scan execution results
type ScanResults struct {
	VulnerabilitiesFound int     `json:"vulnerabilities_found"`
	CriticalCount        int     `json:"critical_count"`
	HighCount            int     `json:"high_count"`
	MediumCount          int     `json:"medium_count"`
	LowCount             int     `json:"low_count"`
	InfoCount            int     `json:"info_count"`
	NewVulnerabilities   int     `json:"new_vulnerabilities"`
	FixedVulnerabilities int     `json:"fixed_vulnerabilities"`
	FalsePositives       int     `json:"false_positives"`
	ConfirmedFindings    int     `json:"confirmed_findings"`
	RiskScore            float64 `json:"risk_score"`
	ComplianceScore      float64 `json:"compliance_score"`
}

// ScanStatistics represents scan execution statistics
type ScanStatistics struct {
	TargetsScanned      int           `json:"targets_scanned"`
	TargetsResponding   int           `json:"targets_responding"`
	PortsScanned        int           `json:"ports_scanned"`
	ServicesDetected    int           `json:"services_detected"`
	HostsReachable      int           `json:"hosts_reachable"`
	RequestsSent        int           `json:"requests_sent"`
	ResponsesReceived   int           `json:"responses_received"`
	BytesTransferred    int64         `json:"bytes_transferred"`
	TestsExecuted       int           `json:"tests_executed"`
	PluginsUsed         int           `json:"plugins_used"`
	AverageResponseTime time.Duration `json:"average_response_time"`
	SuccessRate         float64       `json:"success_rate"`
	ErrorRate           float64       `json:"error_rate"`
}

// ScanPerformance represents scan performance metrics
type ScanPerformance struct {
	CPUUsageAvg    float64       `json:"cpu_usage_avg"`
	CPUUsageMax    float64       `json:"cpu_usage_max"`
	MemoryUsageAvg int64         `json:"memory_usage_avg"`
	MemoryUsageMax int64         `json:"memory_usage_max"`
	NetworkIOBytes int64         `json:"network_io_bytes"`
	DiskIOBytes    int64         `json:"disk_io_bytes"`
	QueueWaitTime  time.Duration `json:"queue_wait_time"`
	ExecutionTime  time.Duration `json:"execution_time"`
	ProcessingTime time.Duration `json:"processing_time"`
	ReportGenTime  time.Duration `json:"report_gen_time"`
	ThroughputMBps float64       `json:"throughput_mbps"`
}

// ScanError represents scan execution errors
type ScanError struct {
	Code        string                 `json:"code"`
	Message     string                 `json:"message"`
	Target      string                 `json:"target,omitempty"`
	Component   string                 `json:"component,omitempty"`
	Timestamp   time.Time              `json:"timestamp"`
	Severity    string                 `json:"severity"`
	Recoverable bool                   `json:"recoverable"`
	Context     map[string]interface{} `json:"context,omitempty"`
	StackTrace  string                 `json:"stack_trace,omitempty"`
}

// ScanWarning represents scan warnings
type ScanWarning struct {
	Code      string                 `json:"code"`
	Message   string                 `json:"message"`
	Target    string                 `json:"target,omitempty"`
	Timestamp time.Time              `json:"timestamp"`
	Context   map[string]interface{} `json:"context,omitempty"`
}

// ExclusionRule represents scan exclusion rules
type ExclusionRule struct {
	ID          string     `json:"id"`
	Type        string     `json:"type"`
	Pattern     string     `json:"pattern"`
	Reason      string     `json:"reason"`
	AppliedBy   string     `json:"applied_by"`
	AppliedAt   time.Time  `json:"applied_at"`
	ExpiresAt   *time.Time `json:"expires_at,omitempty"`
	Description string     `json:"description,omitempty"`
}

// AccessControl represents scan access control
type AccessControl struct {
	ReadUsers   []string            `json:"read_users,omitempty"`
	WriteUsers  []string            `json:"write_users,omitempty"`
	ReadGroups  []string            `json:"read_groups,omitempty"`
	WriteGroups []string            `json:"write_groups,omitempty"`
	Permissions map[string][]string `json:"permissions,omitempty"`
}

// ScanTag represents scan metadata tags
type ScanTag struct {
	Key       string    `json:"key"`
	Value     string    `json:"value"`
	Source    string    `json:"source"`
	CreatedAt time.Time `json:"created_at"`
}

// ScanChange represents scan change history
type ScanChange struct {
	Timestamp time.Time   `json:"timestamp"`
	User      string      `json:"user"`
	Operation string      `json:"operation"`
	Field     string      `json:"field,omitempty"`
	OldValue  interface{} `json:"old_value,omitempty"`
	NewValue  interface{} `json:"new_value,omitempty"`
	Reason    string      `json:"reason,omitempty"`
	IPAddress string      `json:"ip_address,omitempty"`
}

// TableName returns the database table name for Scan
func (Scan) TableName() string {
	return "scans"
}

// IsRunning checks if the scan is currently running
func (s *Scan) IsRunning() bool {
	return s.Status == ScanStatusRunning
}

// IsCompleted checks if the scan has completed
func (s *Scan) IsCompleted() bool {
	return s.Status == ScanStatusCompleted ||
		s.Status == ScanStatusFailed ||
		s.Status == ScanStatusCancelled ||
		s.Status == ScanStatusTimeout ||
		s.Status == ScanStatusPartial
}

// CanStart checks if the scan can be started
func (s *Scan) CanStart() bool {
	return s.Status == ScanStatusPending || s.Status == ScanStatusQueued
}

// CanPause checks if the scan can be paused
func (s *Scan) CanPause() bool {
	return s.Status == ScanStatusRunning
}

// CanResume checks if the scan can be resumed
func (s *Scan) CanResume() bool {
	return s.Status == ScanStatusPaused
}

// CanCancel checks if the scan can be cancelled
func (s *Scan) CanCancel() bool {
	return s.Status == ScanStatusPending ||
		s.Status == ScanStatusQueued ||
		s.Status == ScanStatusRunning ||
		s.Status == ScanStatusPaused
}

// UpdateProgress updates scan progress
func (s *Scan) UpdateProgress(progress float64, currentTarget string) {
	s.Progress = progress
	s.CurrentTarget = currentTarget
	s.UpdatedAt = time.Now().UTC()
}

// Start marks the scan as started
func (s *Scan) Start() {
	now := time.Now().UTC()
	s.Status = ScanStatusRunning
	s.StartedAt = &now
	s.UpdatedAt = now
}

// Complete marks the scan as completed
func (s *Scan) Complete() {
	now := time.Now().UTC()
	s.Status = ScanStatusCompleted
	s.CompletedAt = &now
	s.Progress = 100.0
	if s.StartedAt != nil {
		s.Duration = now.Sub(*s.StartedAt)
	}
	s.UpdatedAt = now
}

// Fail marks the scan as failed
func (s *Scan) Fail(reason string) {
	now := time.Now().UTC()
	s.Status = ScanStatusFailed
	s.CompletedAt = &now
	if s.StartedAt != nil {
		s.Duration = now.Sub(*s.StartedAt)
	}
	s.UpdatedAt = now

	// Add error
	s.Errors = append(s.Errors, ScanError{
		Code:        "SCAN_FAILED",
		Message:     reason,
		Timestamp:   now,
		Severity:    "error",
		Recoverable: false,
	})
}

// Cancel marks the scan as cancelled
func (s *Scan) Cancel(reason string) {
	now := time.Now().UTC()
	s.Status = ScanStatusCancelled
	s.CompletedAt = &now
	if s.StartedAt != nil {
		s.Duration = now.Sub(*s.StartedAt)
	}
	s.UpdatedAt = now

	// Add warning
	s.Warnings = append(s.Warnings, ScanWarning{
		Code:      "SCAN_CANCELLED",
		Message:   reason,
		Timestamp: now,
	})
}

// AddError adds an error to the scan
func (s *Scan) AddError(code, message, target, component string, severity string, recoverable bool) {
	s.Errors = append(s.Errors, ScanError{
		Code:        code,
		Message:     message,
		Target:      target,
		Component:   component,
		Timestamp:   time.Now().UTC(),
		Severity:    severity,
		Recoverable: recoverable,
	})
}

// AddWarning adds a warning to the scan
func (s *Scan) AddWarning(code, message, target string) {
	s.Warnings = append(s.Warnings, ScanWarning{
		Code:      code,
		Message:   message,
		Target:    target,
		Timestamp: time.Now().UTC(),
	})
}

// HasTag checks if scan has a specific tag
func (s *Scan) HasTag(key, value string) bool {
	for _, tag := range s.Tags {
		if tag.Key == key && tag.Value == value {
			return true
		}
	}
	return false
}

// AddTag adds a tag to the scan
func (s *Scan) AddTag(key, value, source string) {
	// Remove existing tag with same key
	for i, tag := range s.Tags {
		if tag.Key == key {
			s.Tags = append(s.Tags[:i], s.Tags[i+1:]...)
			break
		}
	}

	// Add new tag
	s.Tags = append(s.Tags, ScanTag{
		Key:       key,
		Value:     value,
		Source:    source,
		CreatedAt: time.Now().UTC(),
	})
}

// GetTotalTargets returns the total number of targets in the scan
func (s *Scan) GetTotalTargets() int {
	total := 0
	total += len(s.Targets.Networks)
	total += len(s.Targets.Hosts)
	total += len(s.Targets.URLs)
	total += len(s.Targets.Applications)
	total += len(s.Targets.Repositories)
	total += len(s.Targets.CloudResources)
	total += len(s.Targets.Containers)
	total += len(s.AssetIDs)
	return total
}

// GetPriorityScore returns numerical priority score for sorting
func (s *Scan) GetPriorityScore() int {
	switch s.Priority {
	case ScanPriorityCritical:
		return 100
	case ScanPriorityHigh:
		return 75
	case ScanPriorityMedium:
		return 50
	case ScanPriorityLow:
		return 25
	default:
		return 50
	}
}

// CalculateRiskScore calculates overall risk score for the scan
func (s *Scan) CalculateRiskScore() float64 {
	if s.Results.VulnerabilitiesFound == 0 {
		return 0.0
	}

	// Weighted scoring
	score := float64(s.Results.CriticalCount*10 +
		s.Results.HighCount*7 +
		s.Results.MediumCount*4 +
		s.Results.LowCount*2 +
		s.Results.InfoCount*1)

	// Normalize by number of targets
	targets := float64(s.GetTotalTargets())
	if targets > 0 {
		score = score / targets
	}

	// Cap at 100
	if score > 100 {
		score = 100
	}

	return score
}

// Validate performs business logic validation
func (s *Scan) Validate() error {
	if s.TenantID == uuid.Nil {
		return ErrScanTenantIDRequired
	}

	if s.Name == "" {
		return ErrScanNameRequired
	}

	if s.ScanType == "" {
		return ErrScanTypeRequired
	}

	if s.Scanner == "" {
		return ErrScannerRequired
	}

	if s.CreatedBy == "" {
		return ErrCreatedByRequired
	}

	// Validate targets
	if len(s.AssetIDs) == 0 && s.GetTotalTargets() == 0 {
		return ErrNoTargetsSpecified
	}

	return nil
}

// Custom errors for scan validation
var (
	ErrScanTenantIDRequired = ScanError{Code: "SCAN_TENANT_ID_REQUIRED", Message: "Scan tenant ID is required"}
	ErrScanNameRequired     = ScanError{Code: "SCAN_NAME_REQUIRED", Message: "Scan name is required"}
	ErrScanTypeRequired     = ScanError{Code: "SCAN_TYPE_REQUIRED", Message: "Scan type is required"}
	ErrScannerRequired      = ScanError{Code: "SCANNER_REQUIRED", Message: "Scanner is required"}
	ErrCreatedByRequired    = ScanError{Code: "CREATED_BY_REQUIRED", Message: "Created by is required"}
	ErrNoTargetsSpecified   = ScanError{Code: "NO_TARGETS_SPECIFIED", Message: "No scan targets specified"}
)

// MarshalJSON implements custom JSON marshaling for Scan
func (s *Scan) MarshalJSON() ([]byte, error) {
	type Alias Scan
	return json.Marshal(&struct {
		*Alias
		TotalTargets   int     `json:"total_targets"`
		PriorityScore  int     `json:"priority_score"`
		CalculatedRisk float64 `json:"calculated_risk"`
		CanStart       bool    `json:"can_start"`
		CanPause       bool    `json:"can_pause"`
		CanResume      bool    `json:"can_resume"`
		CanCancel      bool    `json:"can_cancel"`
		IsRunning      bool    `json:"is_running"`
		IsCompleted    bool    `json:"is_completed"`
	}{
		Alias:          (*Alias)(s),
		TotalTargets:   s.GetTotalTargets(),
		PriorityScore:  s.GetPriorityScore(),
		CalculatedRisk: s.CalculateRiskScore(),
		CanStart:       s.CanStart(),
		CanPause:       s.CanPause(),
		CanResume:      s.CanResume(),
		CanCancel:      s.CanCancel(),
		IsRunning:      s.IsRunning(),
		IsCompleted:    s.IsCompleted(),
	})
}
