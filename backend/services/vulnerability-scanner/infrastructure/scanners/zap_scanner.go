// iSECTECH Vulnerability Scanner - OWASP ZAP Scanner Implementation
// Production-grade OWASP ZAP integration for web application vulnerability scanning
// Copyright (c) 2024 iSECTECH. All rights reserved.

package scanners

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/sirupsen/logrus"

	"github.com/isectech/backend/services/vulnerability-scanner/domain/entity"
	"github.com/isectech/backend/services/vulnerability-scanner/domain/service"
)

// ZAPScanner implements VulnerabilityScanner and WebScanner for OWASP ZAP
type ZAPScanner struct {
	name         string
	config       ZAPConfig
	client       *ZAPClient
	logger       *logrus.Logger
	enabled      bool
	lastUpdate   time.Time
	activeScans  map[string]*ZAPScanSession
	capabilities []string
}

// ZAPConfig holds ZAP scanner configuration
type ZAPConfig struct {
	Host         string            `json:"host"`
	Port         int               `json:"port"`
	APIKey       string            `json:"api_key"`
	UseTLS       bool              `json:"use_tls"`
	Timeout      time.Duration     `json:"timeout"`
	MaxScans     int               `json:"max_scans"`
	SpiderConfig ZAPSpiderConfig   `json:"spider_config"`
	ScanPolicies map[string]string `json:"scan_policies"`
	AuthScripts  map[string]string `json:"auth_scripts"`
	ProxyChain   *ProxyConfig      `json:"proxy_chain,omitempty"`
	UserAgents   []string          `json:"user_agents"`
	SessionMgmt  SessionMgmtConfig `json:"session_mgmt"`
}

// ZAPSpiderConfig holds spider configuration
type ZAPSpiderConfig struct {
	MaxDepth          int      `json:"max_depth"`
	MaxChildren       int      `json:"max_children"`
	MaxDuration       int      `json:"max_duration"`
	AcceptCookies     bool     `json:"accept_cookies"`
	HandleParams      bool     `json:"handle_params"`
	ParseComments     bool     `json:"parse_comments"`
	ParseSitemap      bool     `json:"parse_sitemap"`
	ParseRobots       bool     `json:"parse_robots"`
	PostForm          bool     `json:"post_form"`
	ProcessForm       bool     `json:"process_form"`
	RequestWaitTime   int      `json:"request_wait_time"`
	SendRefererHeader bool     `json:"send_referer_header"`
	ThreadCount       int      `json:"thread_count"`
	UserAgent         string   `json:"user_agent"`
	ExcludeRegex      []string `json:"exclude_regex"`
}

// ProxyConfig holds proxy configuration
type ProxyConfig struct {
	Host     string `json:"host"`
	Port     int    `json:"port"`
	Username string `json:"username,omitempty"`
	Password string `json:"password,omitempty"`
}

// SessionMgmtConfig holds session management configuration
type SessionMgmtConfig struct {
	Method          string            `json:"method"` // cookie, token, manual
	CookieNames     []string          `json:"cookie_names"`
	TokenHeaders    []string          `json:"token_headers"`
	LoginURL        string            `json:"login_url,omitempty"`
	LogoutURL       string            `json:"logout_url,omitempty"`
	LogoutIndicator string            `json:"logout_indicator,omitempty"`
	LoginForm       map[string]string `json:"login_form,omitempty"`
}

// ZAPClient handles communication with ZAP API
type ZAPClient struct {
	baseURL    string
	apiKey     string
	httpClient *http.Client
	logger     *logrus.Logger
}

// ZAPScanSession tracks an active ZAP scan
type ZAPScanSession struct {
	ID             uuid.UUID
	ScanID         int
	SpiderID       int
	PassiveScanID  int
	ActiveScanID   int
	Status         entity.ScanStatus
	StartedAt      time.Time
	Progress       float64
	BaseURL        string
	SpiderProgress int
	ScanProgress   int
	Context        string
	SessionToken   string
	Authentication *service.AuthenticationConfig
}

// ZAP API Response structures

type ZAPResponse struct {
	Status string      `json:"status,omitempty"`
	Result interface{} `json:"result,omitempty"`
}

type ZAPSpiderResponse struct {
	Scan string `json:"scan"`
}

type ZAPScanResponse struct {
	Scan string `json:"scan"`
}

type ZAPSpiderStatus struct {
	Status   string `json:"status"`
	Progress string `json:"progress"`
}

type ZAPScanStatus struct {
	Status   string `json:"status"`
	Progress string `json:"progress"`
}

type ZAPAlert struct {
	SourceID    string `json:"sourceid"`
	Other       string `json:"other"`
	Method      string `json:"method"`
	Evidence    string `json:"evidence"`
	PluginID    string `json:"pluginid"`
	CWEID       string `json:"cweid"`
	Confidence  string `json:"confidence"`
	WASCID      string `json:"wascid"`
	Description string `json:"description"`
	MessageID   string `json:"messageid"`
	InputVector string `json:"inputVector"`
	URL         string `json:"url"`
	Tags        string `json:"tags"`
	Reference   string `json:"reference"`
	Solution    string `json:"solution"`
	Alert       string `json:"alert"`
	Param       string `json:"param"`
	Attack      string `json:"attack"`
	Name        string `json:"name"`
	Risk        string `json:"risk"`
	ID          string `json:"id"`
	AlertRef    string `json:"alertRef"`
}

type ZAPContext struct {
	ID                  string   `json:"id"`
	Name                string   `json:"name"`
	Description         string   `json:"description"`
	InScope             bool     `json:"inScope"`
	IncludeRegexs       []string `json:"includeRegexs"`
	ExcludeRegexs       []string `json:"excludeRegexs"`
	TechnologyList      []string `json:"technologyList"`
	UrlParameterParser  string   `json:"urlParameterParser"`
	PostParameterParser string   `json:"postParameterParser"`
	DataDrivenNodes     []string `json:"dataDrivenNodes"`
}

// NewZAPScanner creates a new ZAP scanner instance
func NewZAPScanner(name string, config ZAPConfig, logger *logrus.Logger) (*ZAPScanner, error) {
	if config.Host == "" {
		return nil, fmt.Errorf("ZAP host is required")
	}

	// Set defaults
	if config.Port == 0 {
		config.Port = 8080
	}
	if config.Timeout == 0 {
		config.Timeout = 30 * time.Second
	}
	if config.MaxScans == 0 {
		config.MaxScans = 3
	}

	// Default spider configuration
	if config.SpiderConfig.MaxDepth == 0 {
		config.SpiderConfig.MaxDepth = 5
	}
	if config.SpiderConfig.MaxChildren == 0 {
		config.SpiderConfig.MaxChildren = 10
	}
	if config.SpiderConfig.ThreadCount == 0 {
		config.SpiderConfig.ThreadCount = 2
	}

	// Create HTTP client
	httpClient := &http.Client{
		Timeout: config.Timeout,
	}

	// Create ZAP client
	protocol := "http"
	if config.UseTLS {
		protocol = "https"
	}
	baseURL := fmt.Sprintf("%s://%s:%d", protocol, config.Host, config.Port)

	client := &ZAPClient{
		baseURL:    baseURL,
		apiKey:     config.APIKey,
		httpClient: httpClient,
		logger:     logger,
	}

	scanner := &ZAPScanner{
		name:        name,
		config:      config,
		client:      client,
		logger:      logger,
		enabled:     true,
		lastUpdate:  time.Now().UTC(),
		activeScans: make(map[string]*ZAPScanSession),
		capabilities: []string{
			"web_application_scanning",
			"sql_injection_testing",
			"xss_testing",
			"csrf_testing",
			"authentication_testing",
			"authorization_testing",
			"session_management",
			"input_validation",
			"ajax_spidering",
			"passive_scanning",
			"active_scanning",
			"api_testing",
			"websocket_testing",
		},
	}

	logger.WithFields(logrus.Fields{
		"scanner": name,
		"host":    config.Host,
		"port":    config.Port,
		"tls":     config.UseTLS,
	}).Info("ZAP scanner created")

	return scanner, nil
}

// VulnerabilityScanner interface implementation

func (s *ZAPScanner) GetName() string {
	return s.name
}

func (s *ZAPScanner) GetType() service.ScannerType {
	return service.ScannerTypeWeb
}

func (s *ZAPScanner) GetVersion() string {
	// This would be detected from ZAP
	return "ZAP 2.14.0"
}

func (s *ZAPScanner) GetSupportedScanTypes() []entity.ScanType {
	return []entity.ScanType{
		entity.ScanTypeWeb,
		entity.ScanTypeApplication,
		entity.ScanTypeAPI,
	}
}

func (s *ZAPScanner) GetCapabilities() []string {
	return s.capabilities
}

func (s *ZAPScanner) IsEnabled() bool {
	return s.enabled
}

func (s *ZAPScanner) IsHealthy() bool {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	health, err := s.GetHealth(ctx)
	return err == nil && health.Status == service.HealthStatusHealthy
}

func (s *ZAPScanner) Initialize(ctx context.Context, config service.ScannerConfiguration) error {
	s.logger.WithField("scanner", s.name).Info("Initializing ZAP scanner")

	// Test connection to ZAP
	if err := s.client.TestConnection(ctx); err != nil {
		s.logger.WithError(err).Error("ZAP connection test failed")
		return fmt.Errorf("connection test failed: %w", err)
	}

	// Get ZAP version
	version, err := s.client.GetVersion(ctx)
	if err != nil {
		s.logger.WithError(err).Error("Failed to get ZAP version")
		return fmt.Errorf("version check failed: %w", err)
	}

	// Configure proxy if specified
	if s.config.ProxyChain != nil {
		if err := s.client.SetProxyChain(ctx, s.config.ProxyChain); err != nil {
			s.logger.WithError(err).Warn("Failed to configure proxy chain")
		}
	}

	s.logger.WithField("version", version).Info("ZAP scanner initialized successfully")
	return nil
}

func (s *ZAPScanner) Validate(ctx context.Context, scanConfig entity.ScannerConfig) error {
	// Validate scanner configuration
	if scanConfig.Engine != "zap" && scanConfig.Engine != "owasp-zap" {
		return fmt.Errorf("unsupported engine: %s", scanConfig.Engine)
	}

	// Check if scan policy exists
	if scanConfig.Profile != "" {
		if _, exists := s.config.ScanPolicies[scanConfig.Profile]; !exists {
			return fmt.Errorf("scan policy %s not found", scanConfig.Profile)
		}
	}

	return nil
}

func (s *ZAPScanner) Shutdown(ctx context.Context) error {
	s.logger.WithField("scanner", s.name).Info("Shutting down ZAP scanner")

	// Stop all active scans
	for _, session := range s.activeScans {
		if session.ActiveScanID > 0 {
			if err := s.client.StopActiveScan(ctx, session.ActiveScanID); err != nil {
				s.logger.WithError(err).WithField("scan_id", session.ActiveScanID).Warn("Failed to stop active scan")
			}
		}
		if session.SpiderID > 0 {
			if err := s.client.StopSpider(ctx, session.SpiderID); err != nil {
				s.logger.WithError(err).WithField("spider_id", session.SpiderID).Warn("Failed to stop spider")
			}
		}
	}

	s.enabled = false
	return nil
}

func (s *ZAPScanner) GetHealth(ctx context.Context) (*service.ScannerHealth, error) {
	health := &service.ScannerHealth{
		Status:         service.HealthStatusHealthy,
		Version:        s.GetVersion(),
		Uptime:         time.Since(s.lastUpdate),
		ActiveScans:    len(s.activeScans),
		TotalScans:     0, // Would track this
		LastScanTime:   s.lastUpdate,
		ResourceUsage:  service.ResourceUsage{},
		DatabaseStatus: service.DatabaseStatus{Connected: true},
		PluginStatus:   make(map[string]service.HealthStatus),
		Issues:         []service.HealthIssue{},
	}

	// Test connection
	if err := s.client.TestConnection(ctx); err != nil {
		health.Status = service.HealthStatusUnhealthy
		health.Issues = append(health.Issues, service.HealthIssue{
			Code:      "CONNECTION_FAILED",
			Message:   err.Error(),
			Severity:  "error",
			Component: "zap_client",
			Timestamp: time.Now().UTC(),
		})
	}

	// Check if too many active scans
	if len(s.activeScans) >= s.config.MaxScans {
		health.Status = service.HealthStatusDegraded
		health.Issues = append(health.Issues, service.HealthIssue{
			Code:      "MAX_SCANS_REACHED",
			Message:   "Maximum number of concurrent scans reached",
			Severity:  "warning",
			Component: "scan_limit",
			Timestamp: time.Now().UTC(),
		})
	}

	return health, nil
}

func (s *ZAPScanner) StartScan(ctx context.Context, scan *entity.Scan) (*service.ScanExecution, error) {
	logger := s.logger.WithFields(logrus.Fields{
		"scan_id":   scan.ID,
		"scan_type": scan.ScanType,
		"targets":   len(scan.Targets.URLs),
	})

	logger.Info("Starting ZAP web application scan")

	// Check scan limits
	if len(s.activeScans) >= s.config.MaxScans {
		return nil, fmt.Errorf("maximum number of concurrent scans reached")
	}

	// Validate targets
	if len(scan.Targets.URLs) == 0 {
		return nil, fmt.Errorf("no URL targets specified for web scan")
	}

	// Get base URL (use first target)
	baseURL := scan.Targets.URLs[0].URL

	// Create scan session
	session := &ZAPScanSession{
		ID:        uuid.New(),
		Status:    entity.ScanStatusRunning,
		StartedAt: time.Now().UTC(),
		Progress:  0.0,
		BaseURL:   baseURL,
	}

	// Create context in ZAP
	contextName := fmt.Sprintf("iSECTECH-Context-%s", scan.ID)
	contextID, err := s.client.CreateContext(ctx, contextName, baseURL)
	if err != nil {
		return nil, fmt.Errorf("failed to create context: %w", err)
	}
	session.Context = contextID

	// Set up authentication if provided
	if len(scan.Targets.URLs) > 0 && len(scan.ScannerConfig.Credentials) > 0 {
		authConfig := s.buildAuthConfig(scan.ScannerConfig.Credentials[0])
		session.Authentication = &authConfig

		if err := s.setupAuthentication(ctx, contextID, authConfig); err != nil {
			logger.WithError(err).Warn("Failed to setup authentication")
		}
	}

	// Start spider
	spiderID, err := s.client.StartSpider(ctx, baseURL, contextID)
	if err != nil {
		return nil, fmt.Errorf("failed to start spider: %w", err)
	}
	session.SpiderID = spiderID

	// Store session
	s.activeScans[session.ID.String()] = session

	execution := &service.ScanExecution{
		ID:        session.ID,
		ScanID:    scan.ID,
		Scanner:   s.name,
		Status:    entity.ScanStatusRunning,
		StartedAt: session.StartedAt,
		Progress:  0.0,
		Metadata: map[string]interface{}{
			"zap_context_id": contextID,
			"zap_spider_id":  spiderID,
			"base_url":       baseURL,
		},
	}

	logger.WithFields(logrus.Fields{
		"execution_id": execution.ID,
		"context_id":   contextID,
		"spider_id":    spiderID,
		"base_url":     baseURL,
	}).Info("ZAP web scan started successfully")

	return execution, nil
}

func (s *ZAPScanner) MonitorScan(ctx context.Context, executionID uuid.UUID) (*service.ScanProgress, error) {
	session, exists := s.activeScans[executionID.String()]
	if !exists {
		return nil, fmt.Errorf("scan session not found")
	}

	var overallProgress float64 = 0
	var status entity.ScanStatus = entity.ScanStatusRunning

	// Check spider progress
	if session.SpiderID > 0 {
		spiderStatus, err := s.client.GetSpiderStatus(ctx, session.SpiderID)
		if err == nil {
			session.SpiderProgress, _ = strconv.Atoi(spiderStatus.Progress)

			if spiderStatus.Status == "100" && session.ActiveScanID == 0 {
				// Spider completed, start active scan
				activeScanID, err := s.client.StartActiveScan(ctx, session.BaseURL, session.Context)
				if err == nil {
					session.ActiveScanID = activeScanID
				}
			}
		}
	}

	// Check active scan progress
	if session.ActiveScanID > 0 {
		scanStatus, err := s.client.GetActiveScanStatus(ctx, session.ActiveScanID)
		if err == nil {
			session.ScanProgress, _ = strconv.Atoi(scanStatus.Progress)

			if scanStatus.Status == "100" {
				status = entity.ScanStatusCompleted
				overallProgress = 100
			} else {
				// Calculate overall progress (50% spider, 50% active scan)
				overallProgress = float64(session.SpiderProgress)/2 + float64(session.ScanProgress)/2
			}
		}
	} else {
		// Only spider running
		overallProgress = float64(session.SpiderProgress) / 2
	}

	session.Status = status
	session.Progress = overallProgress

	progress := &service.ScanProgress{
		ExecutionID: executionID,
		Progress:    overallProgress,
		Status:      status,
		ElapsedTime: time.Since(session.StartedAt),
		LastUpdate:  time.Now().UTC(),
		Statistics:  service.ExecutionStatistics{
			// Would be populated from ZAP statistics
		},
	}

	return progress, nil
}

func (s *ZAPScanner) CancelScan(ctx context.Context, executionID uuid.UUID) error {
	session, exists := s.activeScans[executionID.String()]
	if !exists {
		return fmt.Errorf("scan session not found")
	}

	// Stop active scan
	if session.ActiveScanID > 0 {
		if err := s.client.StopActiveScan(ctx, session.ActiveScanID); err != nil {
			s.logger.WithError(err).Warn("Failed to stop active scan")
		}
	}

	// Stop spider
	if session.SpiderID > 0 {
		if err := s.client.StopSpider(ctx, session.SpiderID); err != nil {
			s.logger.WithError(err).Warn("Failed to stop spider")
		}
	}

	session.Status = entity.ScanStatusCancelled

	s.logger.WithField("execution_id", executionID).Info("ZAP scan cancelled")
	return nil
}

func (s *ZAPScanner) GetScanResults(ctx context.Context, executionID uuid.UUID) (*service.ScanResults, error) {
	session, exists := s.activeScans[executionID.String()]
	if !exists {
		return nil, fmt.Errorf("scan session not found")
	}

	// Get alerts from ZAP
	alerts, err := s.client.GetAlerts(ctx, session.BaseURL)
	if err != nil {
		return nil, fmt.Errorf("failed to get alerts: %w", err)
	}

	// Convert ZAP alerts to vulnerabilities
	vulnerabilities, err := s.convertAlerts(ctx, alerts, session)
	if err != nil {
		return nil, fmt.Errorf("failed to convert alerts: %w", err)
	}

	// Build summary
	summary := s.buildResultSummary(vulnerabilities)

	results := &service.ScanResults{
		ExecutionID:     executionID,
		Vulnerabilities: vulnerabilities,
		Summary:         summary,
		Statistics:      entity.ScanStatistics{},  // Would be populated from ZAP
		Performance:     entity.ScanPerformance{}, // Would be populated from ZAP
		ProcessedAt:     time.Now().UTC(),
	}

	// Clean up session
	delete(s.activeScans, executionID.String())

	s.logger.WithFields(logrus.Fields{
		"execution_id":    executionID,
		"vulnerabilities": len(vulnerabilities),
		"critical_count":  summary.CriticalCount,
		"high_count":      summary.HighCount,
	}).Info("ZAP scan results processed")

	return results, nil
}

func (s *ZAPScanner) ParseResults(ctx context.Context, resultData io.Reader, format string) ([]*entity.Vulnerability, error) {
	// Implementation would parse ZAP JSON/XML reports
	return []*entity.Vulnerability{}, nil
}

func (s *ZAPScanner) NormalizeVulnerability(ctx context.Context, rawVuln interface{}) (*entity.Vulnerability, error) {
	alert, ok := rawVuln.(ZAPAlert)
	if !ok {
		return nil, fmt.Errorf("invalid vulnerability format")
	}

	vuln := &entity.Vulnerability{
		VulnerabilityID: alert.PluginID,
		Title:           alert.Alert,
		Description:     alert.Description,
		Synopsis:        alert.Other,
		Severity:        s.mapRiskToSeverity(alert.Risk),
		CVSSScore:       s.mapRiskToCVSS(alert.Risk),
		Category:        entity.CategoryWeb,
		VulnType:        s.mapAlertToVulnType(alert.Alert),

		Component: entity.ComponentInfo{
			Name: alert.URL,
			Type: "web_application",
		},

		Location: entity.VulnLocation{
			URL:       alert.URL,
			Parameter: alert.Param,
		},

		Scanner: entity.ScannerInfo{
			Name:       s.name,
			Type:       string(s.GetType()),
			Version:    s.GetVersion(),
			Plugin:     alert.Alert,
			PluginID:   alert.PluginID,
			Confidence: s.mapConfidenceToFloat(alert.Confidence),
		},

		References: s.parseZAPReferences(alert.Reference),

		Remediation: entity.RemediationInfo{
			Solution: alert.Solution,
		},

		Evidence: []entity.Evidence{
			{
				Type:        "http_request",
				Description: "Attack evidence",
				Data: map[string]interface{}{
					"method":    alert.Method,
					"attack":    alert.Attack,
					"evidence":  alert.Evidence,
					"parameter": alert.Param,
				},
				Timestamp:  time.Now().UTC(),
				Source:     s.name,
				Confidence: s.mapConfidenceToFloat(alert.Confidence),
			},
		},

		DiscoveredAt: time.Now().UTC(),
		Status:       entity.VulnStatusOpen,
		CreatedAt:    time.Now().UTC(),
		UpdatedAt:    time.Now().UTC(),
	}

	// Set CWE if available
	if alert.CWEID != "" {
		vuln.VulnerabilityID = fmt.Sprintf("CWE-%s", alert.CWEID)
	}

	return vuln, nil
}

func (s *ZAPScanner) ValidateResults(ctx context.Context, vulnerabilities []*entity.Vulnerability) ([]service.ValidationResult, error) {
	var results []service.ValidationResult

	for _, vuln := range vulnerabilities {
		result := service.ValidationResult{
			VulnID:      vuln.VulnerabilityID,
			Valid:       true,
			Confidence:  vuln.Scanner.Confidence,
			ValidatedAt: time.Now().UTC(),
		}

		// Validate web-specific fields
		if vuln.Location.URL == "" {
			result.Valid = false
			result.Issues = append(result.Issues, "Missing target URL")
		}

		// Check for common false positives
		if strings.Contains(strings.ToLower(vuln.Title), "information disclosure") && vuln.Severity == entity.SeverityLow {
			result.Suggestions = append(result.Suggestions, "Consider manual verification for information disclosure findings")
		}

		results = append(results, result)
	}

	return results, nil
}

func (s *ZAPScanner) GetScanProfiles(ctx context.Context) ([]service.ScanProfile, error) {
	var profiles []service.ScanProfile

	for id, name := range s.config.ScanPolicies {
		profiles = append(profiles, service.ScanProfile{
			ID:          id,
			Name:        name,
			Description: fmt.Sprintf("ZAP scan policy: %s", name),
			Type:        entity.ScanTypeWeb,
			Enabled:     true,
			CreatedAt:   time.Now().UTC(),
			UpdatedAt:   time.Now().UTC(),
		})
	}

	return profiles, nil
}

func (s *ZAPScanner) GetPlugins(ctx context.Context) ([]service.PluginInfo, error) {
	// Implementation would query ZAP for available plugins/rules
	return []service.PluginInfo{}, nil
}

func (s *ZAPScanner) UpdatePlugins(ctx context.Context) error {
	// ZAP plugins are updated through the ZAP marketplace
	return nil
}

func (s *ZAPScanner) GetCredentialRequirements(ctx context.Context, scanType entity.ScanType) ([]service.CredentialRequirement, error) {
	requirements := []service.CredentialRequirement{
		{
			Type:        "form_based",
			Name:        "Form-based Authentication",
			Description: "Username and password for form-based login",
			Required:    false,
			Fields:      []string{"username", "password", "login_url"},
		},
		{
			Type:        "http_basic",
			Name:        "HTTP Basic Authentication",
			Description: "HTTP Basic authentication credentials",
			Required:    false,
			Fields:      []string{"username", "password"},
		},
		{
			Type:        "bearer_token",
			Name:        "Bearer Token",
			Description: "API bearer token for authentication",
			Required:    false,
			Fields:      []string{"token", "header_name"},
		},
		{
			Type:        "session_cookie",
			Name:        "Session Cookie",
			Description: "Pre-authenticated session cookie",
			Required:    false,
			Fields:      []string{"cookie_name", "cookie_value"},
		},
	}

	return requirements, nil
}

func (s *ZAPScanner) GenerateReport(ctx context.Context, executionID uuid.UUID, format service.ReportFormat) (io.Reader, error) {
	// Implementation would generate reports using ZAP's reporting capabilities
	return nil, fmt.Errorf("report generation not implemented")
}

func (s *ZAPScanner) ExportResults(ctx context.Context, executionID uuid.UUID, format service.ExportFormat) (io.Reader, error) {
	// Implementation would export results using ZAP's export capabilities
	return nil, fmt.Errorf("result export not implemented")
}

// WebScanner interface implementation

func (s *ZAPScanner) SpiderApplication(ctx context.Context, baseURL string, config service.SpiderConfig) ([]service.URLInfo, error) {
	// Create temporary context
	contextID, err := s.client.CreateContext(ctx, "temp-spider", baseURL)
	if err != nil {
		return nil, fmt.Errorf("failed to create context: %w", err)
	}
	defer s.client.RemoveContext(ctx, contextID)

	// Start spider
	spiderID, err := s.client.StartSpider(ctx, baseURL, contextID)
	if err != nil {
		return nil, fmt.Errorf("failed to start spider: %w", err)
	}

	// Wait for completion
	for {
		status, err := s.client.GetSpiderStatus(ctx, spiderID)
		if err != nil {
			return nil, fmt.Errorf("failed to get spider status: %w", err)
		}

		if status.Status == "100" {
			break
		}

		time.Sleep(time.Second)
	}

	// Get discovered URLs
	urls, err := s.client.GetSpiderResults(ctx, spiderID)
	if err != nil {
		return nil, fmt.Errorf("failed to get spider results: %w", err)
	}

	return urls, nil
}

func (s *ZAPScanner) DiscoverEndpoints(ctx context.Context, baseURL string) ([]service.EndpointInfo, error) {
	// Implementation would discover API endpoints
	return []service.EndpointInfo{}, nil
}

func (s *ZAPScanner) DetectTechnology(ctx context.Context, url string) (*service.TechnologyStack, error) {
	// Implementation would use ZAP's technology detection
	return &service.TechnologyStack{}, nil
}

func (s *ZAPScanner) ScanWebVulnerabilities(ctx context.Context, targets []service.WebTarget) ([]*entity.Vulnerability, error) {
	// Implementation would run comprehensive web vulnerability scans
	return []*entity.Vulnerability{}, nil
}

func (s *ZAPScanner) TestSQLInjection(ctx context.Context, endpoints []service.EndpointInfo) ([]*entity.Vulnerability, error) {
	// Implementation would test for SQL injection vulnerabilities
	return []*entity.Vulnerability{}, nil
}

func (s *ZAPScanner) TestXSS(ctx context.Context, endpoints []service.EndpointInfo) ([]*entity.Vulnerability, error) {
	// Implementation would test for XSS vulnerabilities
	return []*entity.Vulnerability{}, nil
}

func (s *ZAPScanner) TestCSRF(ctx context.Context, endpoints []service.EndpointInfo) ([]*entity.Vulnerability, error) {
	// Implementation would test for CSRF vulnerabilities
	return []*entity.Vulnerability{}, nil
}

func (s *ZAPScanner) TestAuthentication(ctx context.Context, endpoints []service.EndpointInfo) ([]*entity.Vulnerability, error) {
	// Implementation would test authentication mechanisms
	return []*entity.Vulnerability{}, nil
}

func (s *ZAPScanner) TestAuthorization(ctx context.Context, endpoints []service.EndpointInfo) ([]*entity.Vulnerability, error) {
	// Implementation would test authorization controls
	return []*entity.Vulnerability{}, nil
}

func (s *ZAPScanner) Authenticate(ctx context.Context, authConfig service.AuthenticationConfig) (*service.SessionInfo, error) {
	// Implementation would handle authentication
	return &service.SessionInfo{}, nil
}

func (s *ZAPScanner) MaintainSession(ctx context.Context, session *service.SessionInfo) error {
	// Implementation would maintain authenticated sessions
	return nil
}

// Private helper methods

func (s *ZAPScanner) buildAuthConfig(credential entity.CredentialRef) service.AuthenticationConfig {
	return service.AuthenticationConfig{
		Type:     credential.Type,
		Username: credential.Username,
		// Password would be retrieved securely
	}
}

func (s *ZAPScanner) setupAuthentication(ctx context.Context, contextID string, authConfig service.AuthenticationConfig) error {
	// Implementation would configure authentication in ZAP
	return nil
}

func (s *ZAPScanner) convertAlerts(ctx context.Context, alerts []ZAPAlert, session *ZAPScanSession) ([]*entity.Vulnerability, error) {
	var vulnerabilities []*entity.Vulnerability

	for _, alert := range alerts {
		vuln, err := s.NormalizeVulnerability(ctx, alert)
		if err != nil {
			s.logger.WithError(err).Warn("Failed to normalize vulnerability")
			continue
		}

		// Set scan-specific information
		vuln.ScanID = session.ID
		vuln.DiscoveredAt = session.StartedAt

		vulnerabilities = append(vulnerabilities, vuln)
	}

	return vulnerabilities, nil
}

func (s *ZAPScanner) buildResultSummary(vulnerabilities []*entity.Vulnerability) service.ResultSummary {
	summary := service.ResultSummary{
		TotalVulnerabilities: len(vulnerabilities),
	}

	for _, vuln := range vulnerabilities {
		switch vuln.Severity {
		case entity.SeverityCritical:
			summary.CriticalCount++
		case entity.SeverityHigh:
			summary.HighCount++
		case entity.SeverityMedium:
			summary.MediumCount++
		case entity.SeverityLow:
			summary.LowCount++
		case entity.SeverityInfo:
			summary.InfoCount++
		}
	}

	// Calculate risk score
	summary.RiskScore = float64(summary.CriticalCount*10 + summary.HighCount*7 + summary.MediumCount*4 + summary.LowCount*2 + summary.InfoCount*1)

	return summary
}

func (s *ZAPScanner) mapRiskToSeverity(risk string) entity.SeverityLevel {
	switch strings.ToLower(risk) {
	case "high":
		return entity.SeverityHigh
	case "medium":
		return entity.SeverityMedium
	case "low":
		return entity.SeverityLow
	case "informational":
		return entity.SeverityInfo
	default:
		return entity.SeverityUnknown
	}
}

func (s *ZAPScanner) mapRiskToCVSS(risk string) float64 {
	switch strings.ToLower(risk) {
	case "high":
		return 7.5
	case "medium":
		return 5.0
	case "low":
		return 2.5
	case "informational":
		return 0.0
	default:
		return 0.0
	}
}

func (s *ZAPScanner) mapAlertToVulnType(alert string) entity.VulnType {
	alertLower := strings.ToLower(alert)

	if strings.Contains(alertLower, "sql injection") {
		return entity.TypeSQLInjection
	}
	if strings.Contains(alertLower, "cross site scripting") || strings.Contains(alertLower, "xss") {
		return entity.TypeXSS
	}
	if strings.Contains(alertLower, "csrf") || strings.Contains(alertLower, "cross site request") {
		return entity.TypeCSRF
	}
	if strings.Contains(alertLower, "authentication") {
		return entity.TypeAuthentication
	}
	if strings.Contains(alertLower, "authorization") {
		return entity.TypeAuthorization
	}
	if strings.Contains(alertLower, "injection") {
		return entity.TypeCodeInjection
	}
	if strings.Contains(alertLower, "traversal") {
		return entity.TypePathTraversal
	}
	if strings.Contains(alertLower, "disclosure") {
		return entity.TypeInformationDisclosure
	}

	return entity.TypeOther
}

func (s *ZAPScanner) mapConfidenceToFloat(confidence string) float64 {
	switch strings.ToLower(confidence) {
	case "high":
		return 0.9
	case "medium":
		return 0.7
	case "low":
		return 0.5
	default:
		return 0.5
	}
}

func (s *ZAPScanner) parseZAPReferences(reference string) []entity.VulnReference {
	var references []entity.VulnReference

	if reference != "" {
		// ZAP references are typically URLs separated by newlines
		urls := strings.Split(reference, "\n")
		for _, url := range urls {
			url = strings.TrimSpace(url)
			if url != "" {
				references = append(references, entity.VulnReference{
					Type: "external",
					URL:  url,
				})
			}
		}
	}

	return references
}

// ZAP Client implementation

func (c *ZAPClient) TestConnection(ctx context.Context) error {
	resp, err := c.makeRequest(ctx, "GET", "/JSON/core/view/version/", nil)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	return nil
}

func (c *ZAPClient) GetVersion(ctx context.Context) (string, error) {
	resp, err := c.makeRequest(ctx, "GET", "/JSON/core/view/version/", nil)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	var result map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return "", err
	}

	if version, ok := result["version"].(string); ok {
		return version, nil
	}

	return "unknown", nil
}

func (c *ZAPClient) CreateContext(ctx context.Context, name, url string) (string, error) {
	params := map[string]string{
		"contextName": name,
		"incRegexs":   fmt.Sprintf("%s.*", url),
	}

	resp, err := c.makeRequest(ctx, "GET", "/JSON/context/action/newContext/", params)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	var result map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return "", err
	}

	if contextID, ok := result["contextId"].(string); ok {
		return contextID, nil
	}

	return "", fmt.Errorf("failed to get context ID")
}

func (c *ZAPClient) RemoveContext(ctx context.Context, contextID string) error {
	params := map[string]string{
		"contextId": contextID,
	}

	resp, err := c.makeRequest(ctx, "GET", "/JSON/context/action/removeContext/", params)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	return nil
}

func (c *ZAPClient) StartSpider(ctx context.Context, url, contextID string) (int, error) {
	params := map[string]string{
		"url":       url,
		"contextId": contextID,
	}

	resp, err := c.makeRequest(ctx, "GET", "/JSON/spider/action/scan/", params)
	if err != nil {
		return 0, err
	}
	defer resp.Body.Close()

	var result map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return 0, err
	}

	if scanStr, ok := result["scan"].(string); ok {
		return strconv.Atoi(scanStr)
	}

	return 0, fmt.Errorf("failed to get spider ID")
}

func (c *ZAPClient) GetSpiderStatus(ctx context.Context, spiderID int) (*ZAPSpiderStatus, error) {
	params := map[string]string{
		"scanId": strconv.Itoa(spiderID),
	}

	resp, err := c.makeRequest(ctx, "GET", "/JSON/spider/view/status/", params)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	status := &ZAPSpiderStatus{
		Status:   result["status"].(string),
		Progress: result["status"].(string), // ZAP returns progress as status
	}

	return status, nil
}

func (c *ZAPClient) StopSpider(ctx context.Context, spiderID int) error {
	params := map[string]string{
		"scanId": strconv.Itoa(spiderID),
	}

	resp, err := c.makeRequest(ctx, "GET", "/JSON/spider/action/stop/", params)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	return nil
}

func (c *ZAPClient) StartActiveScan(ctx context.Context, url, contextID string) (int, error) {
	params := map[string]string{
		"url":       url,
		"contextId": contextID,
	}

	resp, err := c.makeRequest(ctx, "GET", "/JSON/ascan/action/scan/", params)
	if err != nil {
		return 0, err
	}
	defer resp.Body.Close()

	var result map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return 0, err
	}

	if scanStr, ok := result["scan"].(string); ok {
		return strconv.Atoi(scanStr)
	}

	return 0, fmt.Errorf("failed to get active scan ID")
}

func (c *ZAPClient) GetActiveScanStatus(ctx context.Context, scanID int) (*ZAPScanStatus, error) {
	params := map[string]string{
		"scanId": strconv.Itoa(scanID),
	}

	resp, err := c.makeRequest(ctx, "GET", "/JSON/ascan/view/status/", params)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	status := &ZAPScanStatus{
		Status:   result["status"].(string),
		Progress: result["status"].(string),
	}

	return status, nil
}

func (c *ZAPClient) StopActiveScan(ctx context.Context, scanID int) error {
	params := map[string]string{
		"scanId": strconv.Itoa(scanID),
	}

	resp, err := c.makeRequest(ctx, "GET", "/JSON/ascan/action/stop/", params)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	return nil
}

func (c *ZAPClient) GetAlerts(ctx context.Context, baseURL string) ([]ZAPAlert, error) {
	params := map[string]string{
		"baseurl": baseURL,
	}

	resp, err := c.makeRequest(ctx, "GET", "/JSON/core/view/alerts/", params)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	var alerts []ZAPAlert
	if alertsData, ok := result["alerts"].([]interface{}); ok {
		for _, alertData := range alertsData {
			if alertMap, ok := alertData.(map[string]interface{}); ok {
				alert := ZAPAlert{}
				// Map the alert data
				if val, ok := alertMap["alert"].(string); ok {
					alert.Alert = val
				}
				// ... continue mapping other fields
				alerts = append(alerts, alert)
			}
		}
	}

	return alerts, nil
}

func (c *ZAPClient) GetSpiderResults(ctx context.Context, spiderID int) ([]service.URLInfo, error) {
	// Implementation would get spider results
	return []service.URLInfo{}, nil
}

func (c *ZAPClient) SetProxyChain(ctx context.Context, proxy *ProxyConfig) error {
	// Implementation would configure proxy chain in ZAP
	return nil
}

func (c *ZAPClient) makeRequest(ctx context.Context, method, path string, params map[string]string) (*http.Response, error) {
	u, err := url.Parse(c.baseURL + path)
	if err != nil {
		return nil, err
	}

	// Add API key
	query := u.Query()
	if c.apiKey != "" {
		query.Set("apikey", c.apiKey)
	}

	// Add parameters
	for key, value := range params {
		query.Set(key, value)
	}
	u.RawQuery = query.Encode()

	req, err := http.NewRequestWithContext(ctx, method, u.String(), nil)
	if err != nil {
		return nil, err
	}

	return c.httpClient.Do(req)
}
