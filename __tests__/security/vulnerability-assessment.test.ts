/**
 * Cybersecurity-Specific Vulnerability Assessment Tests
 * iSECTECH Protect - Advanced Security Testing Suite  
 */

import { test, expect, Page } from '@playwright/test';
import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

interface VulnerabilityResult {
  category: string;
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  description: string;
  location: string;
  impact: string;
  remediation: string;
  cweId?: string;
  cvssScore?: number;
}

interface SecurityScanResult {
  timestamp: string;
  vulnerabilities: VulnerabilityResult[];
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  compliance: {
    owasp: { passed: number; failed: number; total: number };
    nist: { passed: number; failed: number; total: number };
    iso27001: { passed: number; failed: number; total: number };
  };
}

class CybersecurityVulnerabilityScanner {
  private vulnerabilities: VulnerabilityResult[] = [];
  
  async scanForSQLInjection(page: Page): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];
    
    // Test SQL injection on login form
    await page.goto('http://localhost:3000/login');
    
    const sqlPayloads = [
      "' OR '1'='1",
      "' OR '1'='1' --",
      "'; DROP TABLE users; --",
      "' UNION SELECT * FROM users --",
      "admin'/*",
      "' OR 1=1#",
    ];

    for (const payload of sqlPayloads) {
      await page.fill('[data-testid="email-input"]', `test${payload}@example.com`);
      await page.fill('[data-testid="password-input"]', `password${payload}`);
      
      const response = page.waitForResponse(/\/api\/auth\/login/);
      await page.click('[data-testid="login-button"]');
      
      const loginResponse = await response;
      const responseBody = await loginResponse.text();
      
      // Check for SQL error indicators
      const sqlErrorPatterns = [
        /SQL syntax.*error/i,
        /mysql_fetch_array/i,
        /ORA-\d+/i,
        /Microsoft.*ODBC.*SQL/i,
        /PostgreSQL.*ERROR/i,
        /Warning.*mysql_/i,
      ];
      
      const hasSqlError = sqlErrorPatterns.some(pattern => pattern.test(responseBody));
      
      if (hasSqlError || loginResponse.status() === 500) {
        vulnerabilities.push({
          category: 'SQL Injection',
          severity: 'CRITICAL',
          description: `SQL injection vulnerability detected with payload: ${payload}`,
          location: '/api/auth/login',
          impact: 'Could allow unauthorized database access, data theft, or system compromise',
          remediation: 'Use parameterized queries, input validation, and proper error handling',
          cweId: 'CWE-89',
          cvssScore: 9.8,
        });
      }
    }

    // Test SQL injection on search functionality
    await page.goto('http://localhost:3000/search');
    
    for (const payload of sqlPayloads) {
      await page.fill('[data-testid="search-input"]', payload);
      const searchResponse = page.waitForResponse(/\/api\/search/);
      await page.click('[data-testid="search-button"]');
      
      try {
        const response = await searchResponse;
        const responseBody = await response.text();
        
        const hasSqlError = sqlPayloads.some(pattern => responseBody.includes('SQL'));
        if (hasSqlError) {
          vulnerabilities.push({
            category: 'SQL Injection',
            severity: 'HIGH',
            description: `SQL injection in search endpoint with payload: ${payload}`,
            location: '/api/search',
            impact: 'Could expose sensitive security data through database manipulation',
            remediation: 'Implement proper input sanitization and parameterized queries',
            cweId: 'CWE-89',
            cvssScore: 8.6,
          });
        }
      } catch (error) {
        // Timeout or error might indicate successful injection
        vulnerabilities.push({
          category: 'SQL Injection',
          severity: 'MEDIUM',
          description: `Potential SQL injection causing server error with payload: ${payload}`,
          location: '/api/search',
          impact: 'Could cause denial of service or information disclosure',
          remediation: 'Add proper error handling and input validation',
          cweId: 'CWE-89',
          cvssScore: 6.5,
        });
      }
    }
    
    return vulnerabilities;
  }

  async scanForXSS(page: Page): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];
    
    // XSS payloads for testing
    const xssPayloads = [
      '<script>alert("XSS")</script>',
      '"><script>alert("XSS")</script>',
      '<img src="x" onerror="alert(\'XSS\')">',
      'javascript:alert("XSS")',
      '<iframe src="javascript:alert(\'XSS\')"></iframe>',
      '<svg onload="alert(\'XSS\')">',
      '${alert("XSS")}',
      '<script>fetch("/api/admin", {method:"POST"})</script>',
    ];

    // Test reflected XSS in search
    await page.goto('http://localhost:3000/search');
    
    for (const payload of xssPayloads) {
      await page.fill('[data-testid="search-input"]', payload);
      await page.click('[data-testid="search-button"]');
      
      // Check if script executed (would show alert)
      const dialogPromise = page.waitForEvent('dialog', { timeout: 2000 }).catch(() => null);
      const dialog = await dialogPromise;
      
      if (dialog) {
        await dialog.accept();
        vulnerabilities.push({
          category: 'Cross-Site Scripting (XSS)',
          severity: 'HIGH',
          description: `Reflected XSS vulnerability with payload: ${payload}`,
          location: '/search',
          impact: 'Could execute malicious scripts in user browsers, steal credentials',
          remediation: 'Implement proper output encoding and Content Security Policy',
          cweId: 'CWE-79',
          cvssScore: 8.8,
        });
      }
      
      // Check if payload appears unescaped in DOM
      const searchResults = await page.locator('[data-testid="search-results"]').textContent();
      if (searchResults && searchResults.includes('<script>')) {
        vulnerabilities.push({
          category: 'Cross-Site Scripting (XSS)',
          severity: 'MEDIUM',
          description: `Potential stored XSS - unescaped payload in results: ${payload}`,
          location: '/search',
          impact: 'Could store malicious scripts that execute for other users',
          remediation: 'Implement proper output encoding for all user input',
          cweId: 'CWE-79',
          cvssScore: 7.4,
        });
      }
    }

    // Test XSS in alert creation form
    await page.goto('http://localhost:3000/alerts');
    await page.click('[data-testid="create-alert-button"]');
    
    for (const payload of xssPayloads.slice(0, 3)) { // Test subset for performance
      await page.fill('[data-testid="alert-title"]', payload);
      await page.fill('[data-testid="alert-description"]', payload);
      
      await page.click('[data-testid="create-alert-submit"]');
      
      // Check for alert execution
      const dialogPromise = page.waitForEvent('dialog', { timeout: 1000 }).catch(() => null);
      const dialog = await dialogPromise;
      
      if (dialog) {
        await dialog.accept();
        vulnerabilities.push({
          category: 'Cross-Site Scripting (XSS)',
          severity: 'CRITICAL',
          description: `Stored XSS in alert creation with payload: ${payload}`,
          location: '/api/alerts',
          impact: 'Malicious scripts could be stored and executed for all security analysts',
          remediation: 'Implement input validation, output encoding, and CSP headers',
          cweId: 'CWE-79',
          cvssScore: 9.6,
        });
      }
    }
    
    return vulnerabilities;
  }

  async scanForCSRF(page: Page): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];
    
    // Login first
    await page.goto('http://localhost:3000/login');
    await page.fill('[data-testid="email-input"]', 'test@isectech.com');
    await page.fill('[data-testid="password-input"]', 'TestPassword123!');
    await page.click('[data-testid="login-button"]');
    await page.waitForURL('**/dashboard');

    // Test CSRF protection on state-changing operations
    const csrfTests = [
      {
        name: 'Alert Creation',
        url: '/api/alerts',
        method: 'POST',
        data: { title: 'CSRF Test Alert', severity: 'HIGH' },
      },
      {
        name: 'User Settings Update',
        url: '/api/user/settings',
        method: 'PUT',
        data: { theme: 'dark' },
      },
      {
        name: 'Security Policy Update',
        url: '/api/security/policies',
        method: 'POST',
        data: { policy: 'new_policy' },
      },
    ];

    for (const test of csrfTests) {
      // Create external page to simulate CSRF attack
      const maliciousHtml = `
        <html>
          <body>
            <form id="csrf-form" action="http://localhost:3000${test.url}" method="POST">
              <input name="title" value="${test.data.title || ''}" />
              <input name="severity" value="${test.data.severity || ''}" />
              <input name="theme" value="${test.data.theme || ''}" />
            </form>
            <script>
              document.getElementById('csrf-form').submit();
            </script>
          </body>
        </html>
      `;
      
      const tempFile = path.join(__dirname, 'csrf-test.html');
      fs.writeFileSync(tempFile, maliciousHtml);
      
      // Open malicious page in new context
      const newContext = await page.context().browser()?.newContext();
      if (newContext) {
        const csrfPage = await newContext.newPage();
        
        const responsePromise = csrfPage.waitForResponse(`**${test.url}`, { timeout: 5000 }).catch(() => null);
        await csrfPage.goto(`file://${tempFile}`);
        
        const response = await responsePromise;
        
        if (response && response.status() === 200) {
          vulnerabilities.push({
            category: 'Cross-Site Request Forgery (CSRF)',
            severity: 'HIGH',
            description: `CSRF vulnerability in ${test.name}`,
            location: test.url,
            impact: 'Attackers could perform unauthorized actions on behalf of authenticated users',
            remediation: 'Implement CSRF tokens, SameSite cookies, and referer validation',
            cweId: 'CWE-352',
            cvssScore: 8.1,
          });
        }
        
        await newContext.close();
      }
      
      // Cleanup
      if (fs.existsSync(tempFile)) {
        fs.unlinkSync(tempFile);
      }
    }
    
    return vulnerabilities;
  }

  async scanForBrokenAuthentication(page: Page): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];
    
    // Test weak password policies
    await page.goto('http://localhost:3000/register');
    
    const weakPasswords = ['123', 'password', 'admin', 'test', '1234567890', 'qwerty'];
    
    for (const weakPassword of weakPasswords) {
      await page.fill('[data-testid="email-input"]', 'weaktest@example.com');
      await page.fill('[data-testid="password-input"]', weakPassword);
      await page.fill('[data-testid="confirm-password-input"]', weakPassword);
      
      await page.click('[data-testid="register-button"]');
      
      // Check if weak password is accepted
      if (await page.locator('[data-testid="registration-success"]').count() > 0) {
        vulnerabilities.push({
          category: 'Broken Authentication',
          severity: 'MEDIUM',
          description: `Weak password accepted: ${weakPassword}`,
          location: '/register',
          impact: 'Users can create easily guessable passwords, increasing breach risk',
          remediation: 'Implement strong password policies and validation',
          cweId: 'CWE-521',
          cvssScore: 6.5,
        });
      }
    }

    // Test session management
    await page.goto('http://localhost:3000/login');
    await page.fill('[data-testid="email-input"]', 'test@isectech.com');
    await page.fill('[data-testid="password-input"]', 'TestPassword123!');
    await page.click('[data-testid="login-button"]');
    await page.waitForURL('**/dashboard');

    // Check session cookie security
    const cookies = await page.context().cookies();
    const sessionCookie = cookies.find(c => c.name.includes('session') || c.name.includes('token'));
    
    if (sessionCookie) {
      if (!sessionCookie.secure) {
        vulnerabilities.push({
          category: 'Insecure Session Management',
          severity: 'HIGH',
          description: 'Session cookie not marked as Secure',
          location: 'Session Management',
          impact: 'Session tokens could be intercepted over non-HTTPS connections',
          remediation: 'Set Secure flag on all session cookies',
          cweId: 'CWE-614',
          cvssScore: 7.5,
        });
      }
      
      if (!sessionCookie.httpOnly) {
        vulnerabilities.push({
          category: 'Insecure Session Management', 
          severity: 'HIGH',
          description: 'Session cookie not marked as HttpOnly',
          location: 'Session Management',
          impact: 'Session tokens accessible via JavaScript, vulnerable to XSS attacks',
          remediation: 'Set HttpOnly flag on session cookies',
          cweId: 'CWE-1004',
          cvssScore: 7.2,
        });
      }
      
      if (sessionCookie.sameSite !== 'Strict' && sessionCookie.sameSite !== 'Lax') {
        vulnerabilities.push({
          category: 'Insecure Session Management',
          severity: 'MEDIUM',
          description: 'Session cookie missing SameSite protection',
          location: 'Session Management',
          impact: 'Vulnerable to CSRF attacks',
          remediation: 'Set SameSite=Strict or SameSite=Lax on session cookies',
          cweId: 'CWE-352',
          cvssScore: 6.1,
        });
      }
    }
    
    return vulnerabilities;
  }

  async scanForDataExposure(page: Page): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];
    
    // Test for sensitive data in client-side code
    await page.goto('http://localhost:3000/dashboard');
    
    const sensitivePatterns = [
      { pattern: /api[_-]?key[s]?[\s]*[:=][\s]*["\']?([a-zA-Z0-9_-]{16,})/gi, type: 'API Key' },
      { pattern: /secret[s]?[\s]*[:=][\s]*["\']?([a-zA-Z0-9_-]{16,})/gi, type: 'Secret' },
      { pattern: /password[s]?[\s]*[:=][\s]*["\']?([a-zA-Z0-9_-]{8,})/gi, type: 'Password' },
      { pattern: /token[s]?[\s]*[:=][\s]*["\']?([a-zA-Z0-9_-]{16,})/gi, type: 'Token' },
      { pattern: /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, type: 'Email' },
      { pattern: /\b\d{3}-\d{2}-\d{4}\b/g, type: 'SSN' },
    ];

    // Check page source for sensitive data
    const pageContent = await page.content();
    
    sensitivePatterns.forEach(({ pattern, type }) => {
      const matches = pageContent.match(pattern);
      if (matches && matches.length > 0) {
        vulnerabilities.push({
          category: 'Sensitive Data Exposure',
          severity: 'HIGH',
          description: `${type} exposed in client-side code`,
          location: 'Frontend Code',
          impact: 'Sensitive information accessible to attackers through source code',
          remediation: 'Remove sensitive information from client-side code, use environment variables',
          cweId: 'CWE-200',
          cvssScore: 7.8,
        });
      }
    });

    // Check JavaScript files for sensitive data
    const jsFiles = await page.evaluate(() => {
      return Array.from(document.querySelectorAll('script[src]')).map(
        (script: any) => script.src
      );
    });

    for (const jsFile of jsFiles.slice(0, 5)) { // Check first 5 JS files
      try {
        const response = await page.goto(jsFile);
        const jsContent = await response?.text() || '';
        
        sensitivePatterns.forEach(({ pattern, type }) => {
          const matches = jsContent.match(pattern);
          if (matches && matches.length > 0) {
            vulnerabilities.push({
              category: 'Sensitive Data Exposure',
              severity: 'CRITICAL',
              description: `${type} hardcoded in JavaScript file: ${jsFile}`,
              location: jsFile,
              impact: 'Critical sensitive information exposed in static files',
              remediation: 'Remove all hardcoded sensitive data, implement proper secret management',
              cweId: 'CWE-798',
              cvssScore: 9.1,
            });
          }
        });
      } catch (error) {
        // Skip if file can't be loaded
      }
    }
    
    return vulnerabilities;
  }

  async scanForSecurityMisconfiguration(page: Page): Promise<VulnerabilityResult[]> {
    const vulnerabilities: VulnerabilityResult[] = [];
    
    await page.goto('http://localhost:3000/dashboard');
    
    // Check security headers
    const response = await page.goto('http://localhost:3000/dashboard');
    const headers = response?.headers() || {};
    
    const requiredSecurityHeaders = [
      { name: 'strict-transport-security', severity: 'HIGH' as const, description: 'HSTS header missing' },
      { name: 'content-security-policy', severity: 'HIGH' as const, description: 'CSP header missing' },
      { name: 'x-frame-options', severity: 'MEDIUM' as const, description: 'X-Frame-Options header missing' },
      { name: 'x-content-type-options', severity: 'MEDIUM' as const, description: 'X-Content-Type-Options header missing' },
      { name: 'x-xss-protection', severity: 'LOW' as const, description: 'X-XSS-Protection header missing' },
      { name: 'referrer-policy', severity: 'LOW' as const, description: 'Referrer-Policy header missing' },
    ];

    requiredSecurityHeaders.forEach(({ name, severity, description }) => {
      if (!headers[name]) {
        vulnerabilities.push({
          category: 'Security Misconfiguration',
          severity,
          description,
          location: 'HTTP Headers',
          impact: 'Missing security headers increase attack surface',
          remediation: `Implement ${name} header with appropriate values`,
          cweId: 'CWE-16',
          cvssScore: severity === 'HIGH' ? 7.5 : severity === 'MEDIUM' ? 5.3 : 3.7,
        });
      }
    });

    // Check for debug information exposure
    const debugPatterns = [
      /debug\s*[:=]\s*true/i,
      /development/i,
      /console\.log/i,
      /alert\(/i,
      /debugger;/i,
    ];

    const pageContent = await page.content();
    debugPatterns.forEach((pattern, index) => {
      if (pattern.test(pageContent)) {
        vulnerabilities.push({
          category: 'Information Disclosure',
          severity: 'LOW',
          description: `Debug information exposed in production code`,
          location: 'Frontend Code',
          impact: 'Debug information could reveal system internals to attackers',
          remediation: 'Remove debug code and console statements from production builds',
          cweId: 'CWE-200',
          cvssScore: 3.1,
        });
      }
    });

    // Check for default credentials or configurations
    await page.goto('http://localhost:3000/admin');
    
    const defaultCredentials = [
      { username: 'admin', password: 'admin' },
      { username: 'admin', password: 'password' },
      { username: 'root', password: 'root' },
      { username: 'test', password: 'test' },
    ];

    for (const { username, password } of defaultCredentials) {
      await page.fill('[data-testid="username-input"]', username);
      await page.fill('[data-testid="password-input"]', password);
      await page.click('[data-testid="admin-login-button"]');
      
      if (await page.locator('[data-testid="admin-dashboard"]').count() > 0) {
        vulnerabilities.push({
          category: 'Default Credentials',
          severity: 'CRITICAL',
          description: `Default admin credentials accepted: ${username}/${password}`,
          location: '/admin',
          impact: 'Immediate system compromise possible with default credentials',
          remediation: 'Change all default credentials immediately',
          cweId: 'CWE-798',
          cvssScore: 9.8,
        });
      }
    }
    
    return vulnerabilities;
  }

  async performComprehensiveVulnerabilityScan(page: Page): Promise<SecurityScanResult> {
    console.log('ðŸ” Starting comprehensive vulnerability assessment...');
    
    const startTime = Date.now();
    
    // Run all vulnerability scans
    const [
      sqlInjectionVulns,
      xssVulns,
      csrfVulns,
      authVulns,
      dataExposureVulns,
      misconfigVulns,
    ] = await Promise.all([
      this.scanForSQLInjection(page),
      this.scanForXSS(page),
      this.scanForCSRF(page),
      this.scanForBrokenAuthentication(page),
      this.scanForDataExposure(page),
      this.scanForSecurityMisconfiguration(page),
    ]);

    const allVulnerabilities = [
      ...sqlInjectionVulns,
      ...xssVulns,
      ...csrfVulns,
      ...authVulns,
      ...dataExposureVulns,
      ...misconfigVulns,
    ];

    const summary = {
      total: allVulnerabilities.length,
      critical: allVulnerabilities.filter(v => v.severity === 'CRITICAL').length,
      high: allVulnerabilities.filter(v => v.severity === 'HIGH').length,
      medium: allVulnerabilities.filter(v => v.severity === 'MEDIUM').length,
      low: allVulnerabilities.filter(v => v.severity === 'LOW').length,
    };

    // Calculate compliance scores (simplified)
    const owaspTop10Coverage = this.calculateOWASPCompliance(allVulnerabilities);
    const nistCompliance = this.calculateNISTCompliance(allVulnerabilities);
    const iso27001Compliance = this.calculateISO27001Compliance(allVulnerabilities);

    const result: SecurityScanResult = {
      timestamp: new Date().toISOString(),
      vulnerabilities: allVulnerabilities,
      summary,
      compliance: {
        owasp: owaspTop10Coverage,
        nist: nistCompliance,
        iso27001: iso27001Compliance,
      },
    };

    const scanDuration = Date.now() - startTime;
    console.log(`âœ… Vulnerability scan completed in ${scanDuration}ms`);
    console.log(`ðŸ“Š Found ${summary.total} vulnerabilities (${summary.critical} critical, ${summary.high} high)`);

    return result;
  }

  private calculateOWASPCompliance(vulnerabilities: VulnerabilityResult[]) {
    const owaspCategories = [
      'SQL Injection',
      'Cross-Site Scripting (XSS)',
      'Broken Authentication',
      'Sensitive Data Exposure',
      'Security Misconfiguration',
      'Cross-Site Request Forgery (CSRF)',
      'Insecure Session Management',
      'Information Disclosure',
    ];

    const failedCategories = new Set(vulnerabilities.map(v => v.category));
    const failed = owaspCategories.filter(cat => failedCategories.has(cat)).length;
    const passed = owaspCategories.length - failed;

    return { passed, failed, total: owaspCategories.length };
  }

  private calculateNISTCompliance(vulnerabilities: VulnerabilityResult[]) {
    // Simplified NIST compliance based on vulnerability presence
    const total = 20; // NIST cybersecurity framework controls
    const critical = vulnerabilities.filter(v => v.severity === 'CRITICAL').length;
    const high = vulnerabilities.filter(v => v.severity === 'HIGH').length;
    
    const failed = Math.min(critical * 3 + high * 2, total);
    const passed = total - failed;

    return { passed, failed, total };
  }

  private calculateISO27001Compliance(vulnerabilities: VulnerabilityResult[]) {
    // Simplified ISO 27001 compliance
    const total = 114; // ISO 27001 controls
    const totalVulns = vulnerabilities.length;
    
    const failed = Math.min(totalVulns * 2, total);
    const passed = total - failed;

    return { passed, failed, total };
  }
}

test.describe('ðŸ›¡ï¸ Cybersecurity Vulnerability Assessment', () => {
  let scanner: CybersecurityVulnerabilityScanner;

  test.beforeEach(() => {
    scanner = new CybersecurityVulnerabilityScanner();
  });

  test('should detect SQL injection vulnerabilities', async ({ page }) => {
    const vulnerabilities = await scanner.scanForSQLInjection(page);
    
    // Assert no critical SQL injection vulnerabilities
    const criticalSQLVulns = vulnerabilities.filter(v => v.severity === 'CRITICAL');
    expect(criticalSQLVulns.length).toBe(0);
    
    console.log(`ðŸ” SQL Injection Scan: ${vulnerabilities.length} vulnerabilities found`);
    vulnerabilities.forEach(vuln => {
      console.log(`  ${vuln.severity}: ${vuln.description}`);
    });
  });

  test('should detect XSS vulnerabilities', async ({ page }) => {
    const vulnerabilities = await scanner.scanForXSS(page);
    
    // Assert no high or critical XSS vulnerabilities
    const highXSSVulns = vulnerabilities.filter(v => 
      v.severity === 'CRITICAL' || v.severity === 'HIGH'
    );
    expect(highXSSVulns.length).toBe(0);
    
    console.log(`ðŸ” XSS Scan: ${vulnerabilities.length} vulnerabilities found`);
  });

  test('should detect CSRF vulnerabilities', async ({ page }) => {
    const vulnerabilities = await scanner.scanForCSRF(page);
    
    // Assert CSRF protection is in place
    expect(vulnerabilities.length).toBe(0);
    
    console.log(`ðŸ” CSRF Scan: ${vulnerabilities.length} vulnerabilities found`);
  });

  test('should detect authentication weaknesses', async ({ page }) => {
    const vulnerabilities = await scanner.scanForBrokenAuthentication(page);
    
    // Assert strong authentication practices
    const criticalAuthVulns = vulnerabilities.filter(v => v.severity === 'CRITICAL');
    expect(criticalAuthVulns.length).toBe(0);
    
    console.log(`ðŸ” Authentication Scan: ${vulnerabilities.length} vulnerabilities found`);
  });

  test('should detect sensitive data exposure', async ({ page }) => {
    const vulnerabilities = await scanner.scanForDataExposure(page);
    
    // Assert no sensitive data is exposed
    expect(vulnerabilities.length).toBe(0);
    
    console.log(`ðŸ” Data Exposure Scan: ${vulnerabilities.length} vulnerabilities found`);
  });

  test('should detect security misconfigurations', async ({ page }) => {
    const vulnerabilities = await scanner.scanForSecurityMisconfiguration(page);
    
    // Assert proper security configuration
    const criticalMisconfigVulns = vulnerabilities.filter(v => v.severity === 'CRITICAL');
    expect(criticalMisconfigVulns.length).toBe(0);
    
    console.log(`ðŸ” Security Configuration Scan: ${vulnerabilities.length} vulnerabilities found`);
  });

  test('should perform comprehensive security assessment', async ({ page }) => {
    const scanResult = await scanner.performComprehensiveVulnerabilityScan(page);
    
    // Save detailed report
    const reportPath = path.join(__dirname, '../../test-results/security-assessment-report.json');
    fs.mkdirSync(path.dirname(reportPath), { recursive: true });
    fs.writeFileSync(reportPath, JSON.stringify(scanResult, null, 2));
    
    // Assert overall security posture
    expect(scanResult.summary.critical).toBe(0);
    expect(scanResult.summary.high).toBeLessThanOrEqual(2); // Allow up to 2 high severity issues
    
    // Assert compliance scores
    expect(scanResult.compliance.owasp.failed).toBeLessThanOrEqual(2);
    expect(scanResult.compliance.nist.passed).toBeGreaterThanOrEqual(15);
    
    console.log('\nðŸ“Š Comprehensive Security Assessment Results:');
    console.log(`  Total Vulnerabilities: ${scanResult.summary.total}`);
    console.log(`  Critical: ${scanResult.summary.critical}`);
    console.log(`  High: ${scanResult.summary.high}`);
    console.log(`  Medium: ${scanResult.summary.medium}`);
    console.log(`  Low: ${scanResult.summary.low}`);
    console.log(`\nðŸ›ï¸ Compliance Scores:`);
    console.log(`  OWASP: ${scanResult.compliance.owasp.passed}/${scanResult.compliance.owasp.total} passed`);
    console.log(`  NIST: ${scanResult.compliance.nist.passed}/${scanResult.compliance.nist.total} passed`);
    console.log(`  ISO 27001: ${scanResult.compliance.iso27001.passed}/${scanResult.compliance.iso27001.total} passed`);
    
    if (scanResult.vulnerabilities.length > 0) {
      console.log(`\nðŸ”§ Detailed Vulnerabilities:`);
      scanResult.vulnerabilities.forEach((vuln, index) => {
        console.log(`  ${index + 1}. [${vuln.severity}] ${vuln.category}`);
        console.log(`     Location: ${vuln.location}`);
        console.log(`     Description: ${vuln.description}`);
        console.log(`     Remediation: ${vuln.remediation}`);
        if (vuln.cvssScore) {
          console.log(`     CVSS Score: ${vuln.cvssScore}`);
        }
        console.log('');
      });
    }
    
    // Generate compliance report
    const complianceReport = `# Security Compliance Assessment Report

## Executive Summary
- **Total Vulnerabilities Found:** ${scanResult.summary.total}
- **Critical Issues:** ${scanResult.summary.critical}
- **Assessment Date:** ${scanResult.timestamp}

## OWASP Top 10 Compliance
- **Passed Controls:** ${scanResult.compliance.owasp.passed}/${scanResult.compliance.owasp.total}
- **Compliance Rate:** ${Math.round((scanResult.compliance.owasp.passed / scanResult.compliance.owasp.total) * 100)}%

## NIST Cybersecurity Framework
- **Passed Controls:** ${scanResult.compliance.nist.passed}/${scanResult.compliance.nist.total}
- **Compliance Rate:** ${Math.round((scanResult.compliance.nist.passed / scanResult.compliance.nist.total) * 100)}%

## ISO 27001 Information Security
- **Passed Controls:** ${scanResult.compliance.iso27001.passed}/${scanResult.compliance.iso27001.total}
- **Compliance Rate:** ${Math.round((scanResult.compliance.iso27001.passed / scanResult.compliance.iso27001.total) * 100)}%

## Recommendations
${scanResult.summary.critical > 0 ? 'ðŸš¨ **URGENT:** Address critical vulnerabilities immediately' : ''}
${scanResult.summary.high > 0 ? 'âš ï¸ **HIGH PRIORITY:** Address high severity vulnerabilities within 24-48 hours' : ''}
${scanResult.summary.medium > 0 ? 'ðŸ“‹ **MEDIUM PRIORITY:** Address medium severity vulnerabilities within 1-2 weeks' : ''}
`;

    const complianceReportPath = path.join(__dirname, '../../test-results/compliance-report.md');
    fs.writeFileSync(complianceReportPath, complianceReport);
    
    console.log(`\nðŸ“‹ Reports saved:`);
    console.log(`  Detailed: ${reportPath}`);
    console.log(`  Compliance: ${complianceReportPath}`);
  }, 300000); // 5 minute timeout for comprehensive scan
});